<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профиль | VimeStats</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link href="css/common.css" rel="stylesheet">
    <link href="css/responsive.css" rel="stylesheet">
    <link rel="stylesheet" href="css/settings.css">
    <style>
        @font-face {
            font-family: 'VimeArtBold';
            src: url('assets/fonts/vimeartbold.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background: linear-gradient(135deg, #ffffff 0%, #e6f3ff 100%);
            min-height: 100vh;
            color: #2c3e50;
            margin: 0;
            padding: 0;
            scrollbar-width: thin;
            scrollbar-color: #3498db transparent; /* Цвет ползунка и трека */
        }
        .player-container {
            max-width: 1200px;
            margin: 20px auto 0;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        /* Добавляем медиа-запросы для мобильных устройств */
        @media (max-width: 768px) {
            .player-container {
                margin: 60px auto 0;
                padding: 10px;
            }
            .player-header {
                flex-direction: column;
                text-align: center;
                padding: 16px;
            }
            .player-avatar {
                width: 100px;
                height: 100px;
                margin: 0 auto;
            }
            .player-name {
                font-size: 1.4rem;
                justify-content: center;
            }
            .player-status {
                justify-content: center;
            }
            .stats-grid {
                display: flex !important;
                flex-direction: column !important;
            }
            .stats-row {
                display: flex !important;
                flex-direction: column !important;
                grid-template-columns: none !important;
            }
            .stat-card {
                width: 100% !important;
                max-width: 100% !important;
            }
            .friends-list {
                grid-template-columns: 1fr !important;
            }
            .achievements-grid,
            [class*="achievements-grid"] {
                grid-template-columns: 1fr !important;
            }
            .matches-list,
            [class*="matches-list"] {
                grid-template-columns: 1fr !important;
            }
            .nav-tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 8px;
            }
            .nav-tabs .nav-link {
                white-space: nowrap;
                padding: 8px 16px;
                font-size: 0.9rem;
            }
            #skin-preview-section {
                flex-direction: column;
            }
            #skin3d-container {
                width: 100%;
                height: 500px;
            }
            #skin3d-controls {
                min-width: 100%;
            }
        }
        @media (max-width: 480px) {
            .stats-grid {
                display: flex !important;
                flex-direction: column !important;
            }
            .stats-row {
                display: flex !important;
                flex-direction: column !important;
                grid-template-columns: none !important;
            }
            .stat-card {
                width: 100% !important;
                max-width: 100% !important;
            }
            .friends-list {
                grid-template-columns: 1fr !important;
            }
            .achievements-grid,
            [class*="achievements-grid"] {
                grid-template-columns: 1fr !important;
            }
            .matches-list,
            [class*="matches-list"] {
                grid-template-columns: 1fr !important;
            }
            .player-name {
                font-size: 1.2rem;
            }
            .status-item {
                font-size: 0.8rem;
            }
        }
        .player-header {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            margin-bottom: 24px;
            display: flex;
            gap: 24px;
            align-items: center;
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeInHeader 0.6s ease-out 0.2s forwards;
        }
        
        @keyframes fadeInHeader {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .player-avatar {
            width: 120px;
            height: 120px;
            border-radius: 0;
            background: #e6f3ff;
            position: relative;
        }
        .player-avatar-base {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .player-avatar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform: scale(1.1);
            transform-origin: center center;
        }
        .player-avatar img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .player-info {
            flex: 1;
        }
        .player-name {
            font-family: 'VimeArtBold', sans-serif;
            font-size: 1.8rem;
            color: #2c3e50; /* Черный цвет по умолчанию */
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-name #player-name {
            cursor: pointer;
            display: inline-block;
            transition: transform 0.2s ease;
        }
        
        .player-name #player-name:hover {
            transform: scale(1.05);
        }
        .player-privileges { /* Новый класс для контейнера привилегий */
            display: flex;
            align-items: center;
            gap: 6px; /* Отступ между отдельными привилегиями */
            position: relative; /* Для возможности смещения */
            top: 1px; /* Смещаем на 2px вниз */
        }
        .rank-badge {
            padding: 4px 8px; /* Отступы внутри блока */
            border-radius: 4px; /* Скругление углов */
            display: inline-block; /* Блок занимает только необходимую ширину */
            vertical-align: middle; /* Выравнивание по центру с текстом имени */
            font-size: 0.3rem; /* Размер шрифта контейнера */
            /* position: relative; */ /* Переносим позиционирование в .player-privileges */
            /* top: 3px; */ /* Переносим позиционирование в .player-privileges */
        }
        .rank-badge .player-rank {
            font-size: 0.9rem; /* Крупный размер для белого текста основной привилегии */
        }
        .prime-badge {
            background: rgba(52, 152, 219, 0.2); /* Голубой фон с прозрачностью */
            padding: 4px 10px; /* Увеличенный padding */
            border-radius: 4px; /* Скругление как у рангов */
            font-size: 0.7rem; /* Увеличенный размер шрифта */
            color: #3498db; /* Голубой текст */
            position: relative; /* Для позиционирования tooltip */
        }
        
        .prime-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            color: #2c3e50;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            margin-bottom: 8px;
            z-index: 1000;
        }
        
        .prime-badge:hover .prime-tooltip {
            opacity: 1;
        }
        .player-status {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .status-item {
            position: relative; /* Добавляем для правильного позиционирования тултипа */
            display: flex;
            align-items: center;
            gap: 8px;
            color: #7f8c8d;
        }
        .status-item.online {
            color: #2ecc71;
        }
        .status-item.offline {
            color: #e74c3c;
        }
        .experience-bar {
            width: 100%;
            height: 14px;
            background: #e6f3ff;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
            position: relative;
        }
        .experience-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .experience-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #2c3e50;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 2;
            user-select: none;
        }
        /* Удален неиспользуемый класс experience-percent */
        .experience-remain {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            color: #2c3e50;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.75rem;
            z-index: 2;
            user-select: none;
            margin-left: 10px;
            transition: color 0.3s ease;
        }
        .nav-tabs {
            border: none;
            margin-bottom: 24px;
            gap: 8px;
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeInTabs 0.6s ease-out 0.4s forwards;
        }
        
        @keyframes fadeInTabs {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .nav-tabs .nav-link {
            border: none;
            color: #7f8c8d;
            padding: 12px 24px;
            border-radius: 12px;
            font-family: 'VimeArtBold', sans-serif;
            transition: all 0.3s ease;
        }
        
        /* Плавное появление контента вкладок */
        .tab-content {
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeInContent 0.6s ease-out 0.6s forwards;
        }
        
        @keyframes fadeInContent {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Стили для тултипа истории ников */
        #nick-history-tooltip {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10000;
            font-family: 'VimeArtBold', sans-serif;
            animation: fadeInTooltip 0.2s ease-out;
        }
        
        @keyframes fadeInTooltip {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        #nick-history-tooltip::-webkit-scrollbar {
            width: 6px;
        }
        
        #nick-history-tooltip::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        #nick-history-tooltip::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            #nick-history-tooltip {
                min-width: 280px;
                max-width: calc(100vw - 40px);
                left: 20px !important;
                right: 20px;
            }
        }
        .nav-tabs .nav-link:hover {
            background: #e6f3ff;
            color: #3498db;
        }
        .nav-tabs .nav-link.active {
            background: #3498db;
            color: #fff;
        }
        .stats-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
        }
        .stat-card {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            position: relative;
            max-height: 300px;
            overflow: hidden;
            cursor: default;
        }
        .stat-card.dragging {
            opacity: 0.6;
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 12px 32px rgba(52, 152, 219, 0.25);
            z-index: 1000;
        }
        .stat-card.drag-over {
            transform: scale(0.95);
            border: 2px dashed #3498db;
            background: #f0f8ff;
        }
        
        .drag-ghost {
            opacity: 0.95 !important;
            box-shadow: 0 20px 60px rgba(52, 152, 219, 0.3) !important;
            transform-style: preserve-3d;
            perspective: 1000px;
            animation: none !important;
        }
        
        .drag-handle {
            position: absolute;
            top: 24px;
            right: 8px;
            width: 24px;
            height: 24px;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 3px;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s ease, transform 0.2s ease;
            z-index: 10;
        }
        
        .drag-handle:hover {
            background: rgba(52, 152, 219, 0.1);
            transform: scale(1.1);
        }
        
        .drag-handle:active {
            cursor: grabbing;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .drag-handle-dot {
            width: 3px;
            height: 3px;
            background: #3498db;
            border-radius: 50%;
            transition: background 0.2s ease;
        }
        
        .drag-handle-row {
            display: flex;
            gap: 3px;
        }
        
        .drag-handle:hover .drag-handle-dot {
            background: #2980b9;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .stat-card {
            animation: slideIn 0.3s ease-out;
        }
        .stat-card.expanded {
            max-height: none;
        }
        .stat-card.expanded .stat-values {
            max-height: none;
        }
        .stat-values {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
            transition: scrollbar-color 0.2s ease;
            padding-right: 4px;
        }
        .stat-values:hover {
            scrollbar-color: rgba(52, 152, 219, 0.5) transparent;
        }
        .stat-values::-webkit-scrollbar {
            width: 6px;
            background: transparent;
        }
        .stat-values::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 10px;
            margin: 4px 0;
        }
        .stat-values::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: padding-box;
            transition: background 0.2s ease;
        }
        .stat-values:hover::-webkit-scrollbar-track {
            background: rgba(230, 243, 255, 0.3);
        }
        .stat-values:hover::-webkit-scrollbar-thumb {
            background: #3498db;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        .stat-values:hover::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        .expand-button {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            padding: 20px 0 0 0;
            text-align: center;
            cursor: pointer;
            color: transparent;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            display: block;
        }
        .stat-card.expanded .expand-button {
            background: transparent;
            padding: 10px 0;
        }
        .stat-title {
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e6f3ff;
            display: flex;
            align-items: center;
        }
        .stat-values {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem; /* Уменьшаем размер шрифта для всей строки */
            padding: 6px 8px; /* Увеличиваем вертикальный padding и добавляем горизонтальный */
            background: #f8fbff; /* Светлый фон */
            border-radius: 4px; /* Слегка скругляем углы */
            margin: 2px 0; /* Небольшой отступ между строками */
        }
        .stat-name {
            color: #7f8c8d;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.7rem; /* Уменьшаем размер шрифта имени */
            font-weight: normal; /* Уменьшаем жирность */
        }
        .stat-value {
            font-family: 'VimeArtBold', sans-serif;
            color: #2c3e50;
            background: #f8fbff;
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 60px;
            text-align: right;
            font-size: 0.7rem; /* Уменьшаем размер шрифта значения */
        }
        .friends-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 24px;
        }
        .friend-card {
            background: #fff;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 3px 12px rgba(52, 152, 219, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease;
            position: relative;
            overflow: hidden;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInFriend 0.4s ease-out forwards;
        }
        
        @keyframes fadeInFriend {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Задержки для каждой карточки друга */
        .friend-card:nth-child(1) { animation-delay: 0.05s; }
        .friend-card:nth-child(2) { animation-delay: 0.1s; }
        .friend-card:nth-child(3) { animation-delay: 0.15s; }
        .friend-card:nth-child(4) { animation-delay: 0.2s; }
        .friend-card:nth-child(5) { animation-delay: 0.25s; }
        .friend-card:nth-child(6) { animation-delay: 0.3s; }
        .friend-card:nth-child(7) { animation-delay: 0.35s; }
        .friend-card:nth-child(8) { animation-delay: 0.4s; }
        .friend-card:nth-child(9) { animation-delay: 0.45s; }
        .friend-card:nth-child(10) { animation-delay: 0.5s; }
        .friend-card:nth-child(11) { animation-delay: 0.55s; }
        .friend-card:nth-child(12) { animation-delay: 0.6s; }
        .friend-card:nth-child(n+13) { animation-delay: 0.65s; }
        
        .friend-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(52, 152, 219, 0.15);
        }
        .friend-card-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .friend-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: #e6f3ff;
            position: relative;
            overflow: hidden;
        }
        .friend-avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .friend-avatar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .friend-info {
            flex: 1;
            overflow: hidden;
        }
        .friend-name {
            font-size: 0.85rem;
            font-family: 'VimeArtBold', sans-serif;
            color: #2c3e50;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .friend-rank {
            font-size: 0.65rem;
            padding: 2px 4px;
            border-radius: 3px;
            margin-right: 4px;
            white-space: nowrap;
        }
        .friend-status {
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 3px;
        }
        .friend-status.online {
            color: #2ecc71;
        }
        .friend-status.offline {
            color: #e74c3c;
        }
        .friend-level {
            font-size: 0.8rem;
            color: #7f8c8d;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .friend-level-bar {
            flex: 1;
            height: 5px;
            background: #e6f3ff;
            border-radius: 3px;
            overflow: hidden;
        }
        .friend-level-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 3px;
        }
        .friends-loading {
            text-align: center;
            padding: 50px;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friends-error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            font-family: 'VimeArtBold', sans-serif;
        }
        #friends-sort {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%233498db' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px !important;
        }
        #friends-sort:hover {
            border-color: #3498db;
            background-color: #e6f3ff;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
        }
        #friends-sort:focus {
            border-color: #3498db;
            background-color: #fff;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        #friends-sort option {
            padding: 10px;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friend-prime {
            font-size: 0.7rem;
            background: rgba(52, 152, 219, 0.2);
            padding: 2px 5px;
            border-radius: 4px;
            color: #3498db;
        }
        .friend-guild {
            margin-top: 3px;
            font-size: 0.7rem;
            color: #7f8c8d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friend-guild-tag {
            font-weight: bold;
            margin-right: 3px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
        }
        .error-message {
            text-align: center;
            padding: 40px;
            font-family: 'VimeArtBold', sans-serif;
            color: #e74c3c;
        }
        .skin3d-ctrl-btn {
            display: inline-block;
            width: 100%;
            margin: 0 0 6px 0;
            padding: 8px 12px;
            background: #e6f3ff;
            color: #3498db;
            border: none;
            border-radius: 8px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.08);
        }
        .skin3d-ctrl-btn:hover {
            background: #d1e7ff;
            transform: translateY(-1px);
        }
        .skin3d-ctrl-btn.active {
            background: #3498db;
            color: #fff;
        }
        .skin3d-ctrl-btn:active {
            transform: translateY(1px);
        }
        .skin3d-ctrl-btn i {
            margin-right: 6px;
        }
        .skin3d-ctrl-btn.rotate-left i {
            transform: scaleX(-1);
        }
        .skin3d-ctrl-btn.rotate-right i {
            transform: scaleX(1);
        }
        .skin3d-ctrl-btn.zoom-in i {
            transform: scale(1.2);
        }
        .skin3d-ctrl-btn.zoom-out i {
            transform: scale(0.8);
        }
        .skin3d-ctrl-btn.reset i {
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }
        .skin3d-ctrl-btn.reset:hover i {
            transform: rotate(180deg);
        }
        .button.download-btn {
            min-width: 140px;
            padding: 10px 0;
            height: 40px;
            display: inline-block;
            background: #3498db;
            color: white;
            border-radius: 12px;
            text-decoration: none;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            margin-right: 8px;
            transition: all 0.3s ease;
            border: none;
            box-sizing: border-box;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.15);
        }
        .button.download-btn:last-child {
            margin-right: 0;
        }
        .button.download-btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        .button.download-btn:active {
            transform: translateY(1px);
        }
        #skin-preview-section {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            display: flex;
            gap: 24px;
            opacity: 0;
            transform: scale(0.95);
            animation: fadeInSkin 0.5s ease-out forwards;
        }
        
        @keyframes fadeInSkin {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        #skin3d-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 240px;
            opacity: 0;
            transform: translateX(-20px);
            animation: fadeInControls 0.5s ease-out 0.2s forwards;
        }
        
        @keyframes fadeInControls {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        #skin3d-container {
            width: 480px;
            height: 700px;
            margin: 0 auto 60px auto;
            opacity: 0;
            transform: translateX(20px);
            animation: fadeInContainer 0.5s ease-out 0.2s forwards;
        }
        
        @keyframes fadeInContainer {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .control-group {
            background: #f8fbff;
            border-radius: 10px;
            padding: 12px;
            text-align: left;
        }
        .control-group-title {
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        .control-label {
            flex: 1;
            font-size: 12px;
            color: #2c3e50;
        }
        .control-value {
            font-size: 12px;
            color: #7f8c8d;
            min-width: 35px;
            text-align: right;
            margin-left: 6px;
        }
        .download-buttons {
            display: flex;
            gap: 24px;
            margin-top: 8px;
            padding: 0 12px;
        }
        .skin3d-ctrl-btn {
            width: 100%;
            margin: 0 0 8px 0;
        }
        /* Добавляем стили для выпадающего списка недавних ников в навигации */
        .recent-nicks {
            position: absolute;
            left: 0px;
            top: 100%;
            margin-top: 5px;
            z-index: 10;
            background: #fff;
            border: 1px solid #3498db;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(52,152,219,0.10);
            padding: 0;
            display: block;
            width: 310px;
            box-sizing: border-box;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s;
        }
        .recent-nicks.active {
            padding: 8px 0;
            max-height: 300px;
            opacity: 1;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .recent-nicks.active::-webkit-scrollbar {
            width: 0;
            display: none;
        }
        .recent-nicks-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .recent-nicks-list li {
            padding: 8px 12px;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            transition: background 0.2s;
        }
        .recent-nicks-list li:hover {
            background: #e6f3ff;
        }

        .status-icon-square {
            width: 10px; /* Уменьшенный размер квадратика */
            height: 10px;
            border-radius: 2px;
            display: inline-block;
            margin-left: 0px;
            margin-right: 1px;
            vertical-align: middle;
            position: relative;
            top: 2px;
        }
        .player-avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .additional-ranks {
            display: flex;
            gap: 6px; 
        }
        .additional-rank-badge {
            background: linear-gradient(to right, #3498db, #ffffff);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            display: inline-block;
            vertical-align: middle;
        }

        .playtime-trigger {
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
        }

        .playtime-label {
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            margin-right: 4px;
            line-height: 1;
        }

        #player-playtime-header {
            line-height: 1;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            position: relative;
        }

        .full-playtime-tooltip {
            position: absolute;
            left: 80px;
            top: -8px;
            transform: none;
            background: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            z-index: 10;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            margin-left: 4px;
            color: #7f8c8d;
        }

        .playtime-trigger:hover .full-playtime-tooltip {
            opacity: 1;
        }

        html {
            scrollbar-width: thin;
            scrollbar-color: rgba(52, 152, 219, 0.7) transparent;
        }

        body {
            scrollbar-width: thin;
            scrollbar-color: rgba(52, 152, 219, 0.7) transparent;
        }
        .mini-head {
            width: 25px;
            height: 25px;
            border-radius: 0;
            object-fit: cover;
            position: relative;
            margin-right: 4px;
            transition: transform 0.3s ease;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .mini-head-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform: scale(1.1);
            transform-origin: center center;
        }
        .recent-nicks-list li .player-rank {
            font-size: 0.7rem; /* Уменьшаем размер шрифта ранга */
            padding: 2px 6px; /* Уменьшаем padding */
            border-radius: 3px; /* Уменьшаем скругление */
            margin-left: 4px;
            display: inline-block;
            vertical-align: middle;
        }
        .recent-nicks-list li .additional-rank-badge {
            font-size: 0.7rem; /* Уменьшаем размер шрифта дополнительного ранга */
            padding: 2px 6px; /* Уменьшаем padding */
            border-radius: 3px; /* Уменьшаем скругление */
            margin-left: 4px;
            display: inline-block;
            vertical-align: middle;
        }
        .online-status {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            margin-left: 4px;
            margin-right: 4px;
            transition: all 0.3s ease;
            align-self: center;
        }
        .online-status.online {
            background-color: #2ecc71;
            box-shadow: 0 0 12px #2ecc71;
            -webkit-animation: blink 2s ease-in-out infinite;
            -moz-animation: blink 2s ease-in-out infinite;
            -o-animation: blink 2s ease-in-out infinite;
            animation: blink 2s ease-in-out infinite;
        }
        .online-status.offline {
            background-color: #e74c3c;
            box-shadow: 0 0 4px #e74c3c;
            animation: none;
        }
        .online-status.unknown {
            background-color: #95a5a6;
            box-shadow: none;
            animation: none;
        }

        @-webkit-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @-moz-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @-o-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        #player-status.online .status-icon-square {
            background-color: #2ecc71;
            box-shadow: 0 0 6px #2ecc71;
            -webkit-animation: blink 2s ease-in-out infinite;
            -moz-animation: blink 2s ease-in-out infinite;
            -o-animation: blink 2s ease-in-out infinite;
            animation: blink 2s ease-in-out infinite;
        }

        #player-status.offline .status-icon-square {
            background-color: #e74c3c;
            box-shadow: 0 0 3px #e74c3c;
            animation: none;
        }

        /* Класс для отключения кастомного шрифта */
        body.no-custom-font * {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        }

        /* Стили для баннера профиля */
        .profile-banner {
            width: 100%;
            height: 300px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            margin-bottom: 5px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: height 0.4s ease, box-shadow 0.3s ease;
            opacity: 0;
            transform: translateY(-20px);
            animation: fadeInBanner 0.6s ease-out forwards;
        }
        
        @keyframes fadeInBanner {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .profile-banner:hover {
            box-shadow: 0 12px 40px rgba(52, 152, 219, 0.15);
        }
        
        .profile-banner.expanded {
            height: auto;
            cursor: pointer;
        }
        
        .profile-banner img {
            width: 100%;
            height: 300px;
            object-fit: cover;
            object-position: center center;
            display: block;
            transition: height 0.4s ease, opacity 0.3s ease;
            opacity: 0;
        }
        
        .profile-banner img.loaded {
            opacity: 1;
        }
        
        .profile-banner.expanded img {
            height: auto;
            object-fit: contain;
        }

        @media (max-width: 768px) {
            .profile-banner {
                height: 200px;
                margin-bottom: 16px;
            }
            
            .profile-banner img {
                height: 200px;
            }
        }

        @media (max-width: 480px) {
            .profile-banner {
                height: 150px;
            }
            
            .profile-banner img {
                height: 150px;
            }
        }

        /* Стили для вкладки матчей */
        .matches-loading {
            text-align: center;
            padding: 50px;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
        }
        
        .matches-error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            font-family: 'VimeArtBold', sans-serif;
        }
        
        .matches-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }
        
        .match-card {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInMatch 0.4s ease-out forwards;
        }
        
        @keyframes fadeInMatch {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .match-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.15);
        }
        
        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e6f3ff;
        }
        
        .match-game {
            font-family: 'VimeArtBold', sans-serif;
            font-size: 1.1rem;
            color: #3498db;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .match-game-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            object-fit: cover;
        }
        
        .match-result {
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .match-result.win {
            background: rgba(46, 204, 113, 0.2);
            color: #27ae60;
        }
        
        .match-result.lose {
            background: rgba(231, 76, 60, 0.2);
            color: #c0392b;
        }
        
        .match-result.draw {
            background: rgba(149, 165, 166, 0.2);
            color: #7f8c8d;
        }
        
        .match-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .match-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .match-info-label {
            color: #7f8c8d;
            font-family: 'VimeArtBold', sans-serif;
        }
        
        .match-info-value {
            color: #2c3e50;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: bold;
        }
        
        .match-date {
            text-align: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e6f3ff;
            color: #95a5a6;
            font-size: 0.8rem;
            font-family: 'VimeArtBold', sans-serif;
        }
        
        .match-map {
            background: #f8fbff;
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            margin-top: 12px;
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 0.85rem;
        }
        
        @media (max-width: 768px) {
            .matches-list {
                grid-template-columns: 1fr;
            }
            
            #matches-filters > div {
                flex-direction: column;
                align-items: stretch !important;
            }
            
            #matches-filters select {
                max-width: 100% !important;
            }
            
            #matches-filters label {
                margin-left: 0 !important;
            }
        }

        /* Стили для модального окна истории скинов */
        .history-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
        }

        .history-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .history-modal-content {
            background: #fff;
            border-radius: 16px;
            padding: 32px;
            max-width: 1400px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: #3498db #e6f3ff;
        }

        .history-modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .history-modal-content::-webkit-scrollbar-track {
            background: #e6f3ff;
            border-radius: 10px;
        }

        .history-modal-content::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
        }

        .history-modal-content::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .history-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e6f3ff;
        }

        .history-modal-title {
            font-family: 'VimeArtBold', sans-serif;
            font-size: 1.5rem;
            color: #3498db;
        }

        .history-modal-close {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: #e6f3ff;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease, color 0.2s ease;
            color: #3498db;
            font-size: 24px;
            line-height: 1;
        }

        .history-modal-close:hover {
            background: #3498db;
            color: #fff;
        }

        .history-tabs {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }

        .history-tab-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            background: #e6f3ff;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-tab-btn:hover {
            background: #d1e7ff;
        }

        .history-tab-btn.active {
            background: #3498db;
            color: #fff;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .history-item {
            background: #f8fbff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08);
            transition: all 0.3s ease;
            cursor: pointer;
            opacity: 0;
            animation: fadeInHistoryItem 0.4s ease-out forwards;
        }

        @keyframes fadeInHistoryItem {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .history-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(52, 152, 219, 0.15);
        }

        .history-item-preview {
            width: 100%;
            height: 300px;
            margin-bottom: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: #fff;
        }

        .history-item-date {
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            color: #7f8c8d;
            text-align: center;
            margin-bottom: 8px;
        }

        .history-item-download {
            width: 100%;
            padding: 8px 16px;
            background: #3498db;
            color: #fff;
            border: none;
            border-radius: 8px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .history-item-download:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .history-item-download:active {
            transform: translateY(0);
        }

        .history-loading {
            text-align: center;
            padding: 60px 20px;
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 1.1rem;
        }

        .history-error {
            text-align: center;
            padding: 60px 20px;
            font-family: 'VimeArtBold', sans-serif;
            color: #e74c3c;
            font-size: 1.1rem;
        }

        .history-empty {
            text-align: center;
            padding: 60px 20px;
            font-family: 'VimeArtBold', sans-serif;
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .history-modal-content {
                padding: 20px;
                max-height: 95vh;
            }

            .history-grid {
                grid-template-columns: 1fr;
            }

            .history-tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Навигация генерируется динамически через navbar.js -->
    <div id="navbar-placeholder"></div>

    <!-- Кнопка настроек -->
    <div id="settings-btn">
        <div class="gear">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="gear-inner"></div>
        </div>
    </div>

    <!-- Меню настроек -->
    <div id="settings-menu">
        <div class="settings-item">
            <span class="settings-label">Отключить кастомный шрифт</span>
            <div class="settings-toggle" id="font-toggle"></div>
        </div>
    </div>

    <div class="player-container">
        <div id="loading" class="loading">
            Загрузка статистики...
        </div>
        <div id="error" class="error-message" style="display: none;">
            Игрок не найден
        </div>
        <div id="player-content" style="display: none;">
            <div class="profile-banner">
                <img src="assets/images/vimefurrybanner.jpg" alt="Баннер профиля" id="profile-banner-img">
            </div>
            <div class="player-header">
                <div class="player-avatar" id="player-avatar"></div>
                <div class="player-info">
                    <h1 class="player-name">
                        <span id="player-name" style="display: inline-block; vertical-align: middle;"></span>
                        <div class="player-privileges"> <!-- Новый контейнер для привилегий -->
                            <span class="rank-badge">
                                <span class="player-rank" id="player-rank"></span>
                            </span>
                            <div class="additional-ranks"></div>
                            <span class="prime-badge" id="prime-badge" style="display: none;">Prime</span>
                        </div>
                    </h1>
                    <div class="player-meta" style="font-size: 0.9rem; color: #7f8c8d; margin-bottom: 12px;">
                        <span id="player-id" style="font-size: 0.7rem; font-family: 'VimeArtBold', sans-serif;"></span>
                    </div>
                    <span id="player-level-meta" style="font-size: 0.9rem; color: #2c3e50; font-weight: bold; font-family: 'VimeArtBold', sans-serif;"></span>
                    <div class="experience-bar">
                        <div class="experience-progress" id="experience-progress" style="width: 0%"></div>
                        <div class="experience-text" id="experience-text">0% - 0 / 8000 XP</div>
                        <div class="experience-remain" id="experience-remain">8000 XP</div>
                    </div>
                    <div class="player-status">
                        <div class="status-item" id="player-status">
                            <span>Оффлайн</span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                            <span id="friends-count-link" style="cursor: pointer; display: flex; align-items: center;">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 2px; line-height: 1; white-space: pre;">Друзей: </span>
                                <span id="player-friends" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">0</span>
                            </span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                            </svg>
                            <span id="player-guild" style="font-family: 'VimeArtBold', sans-serif;">Нет гильдии</span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            <span class="playtime-trigger">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Наиграно:</span> <span id="player-playtime-header"></span>
                            </span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            <span class="playtime-trigger" style="display: flex; align-items: center; gap: 4px;">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Последний вход:</span>
                                <span id="player-last-seen" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">${formatUnixTimestamp(player.lastSeen)}</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <ul class="nav nav-tabs" id="playerTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab" style="display: flex; flex-direction: column; align-items: center; gap: 2px; padding: 8px 16px;">
                        <span>Статистика</span>
                        <span id="stats-mode-label" style="font-size: 0.8rem; opacity: 0.8;">Общая</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="friends-tab" data-bs-toggle="tab" data-bs-target="#friends" type="button" role="tab">Друзья</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="skin-tab" data-bs-toggle="tab" data-bs-target="#skin" type="button" role="tab">Скин</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="achievements-tab" data-bs-toggle="tab" data-bs-target="#achievements" type="button" role="tab">Достижения</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="matches-tab" data-bs-toggle="tab" data-bs-target="#matches" type="button" role="tab">Матчи</button>
                </li>
            </ul>

            <div class="tab-content" id="playerTabContent">
                <div class="tab-pane fade show active" id="stats" role="tabpanel">
                    <div class="stats-grid">
                        <!-- Статистика будет добавлена динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="friends" role="tabpanel">
                    <div class="friends-loading" id="friends-loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Загрузка...</span>
                        </div>
                        <div style="margin-top: 10px;">Загрузка списка друзей...</div>
                    </div>
                    <div class="friends-error" id="friends-error" style="display: none;">
                        <div>Не удалось загрузить список друзей</div>
                        <button class="btn btn-primary mt-3" id="retry-friends-btn">Повторить</button>
                    </div>
                    <!-- Добавляем селектор сортировки -->
                    <div id="friends-sort-container" style="display: none; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; gap: 12px; background: #fff; padding: 16px 20px; border-radius: 12px; box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08);">
                            <label for="friends-sort" style="font-family: 'VimeArtBold', sans-serif; font-size: 1rem; color: #3498db; margin: 0;">Сортировка:</label>
                            <select id="friends-sort" style="flex: 1; max-width: 220px; padding: 10px 16px; font-family: 'VimeArtBold', sans-serif; font-size: 0.95rem; color: #2c3e50; background: #f8fbff; border: 2px solid #e6f3ff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; outline: none;">
                                <option value="online">Онлайн</option>
                                <option value="last_seen">Последний вход</option>
                                <option value="rank">По рангу</option>
                                <option value="name">По имени</option>
                            </select>
                        </div>
                    </div>
                    <div class="friends-list" id="friends-list" style="display: none;">
                        <!-- Друзья будут добавлены динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="skin" role="tabpanel">
                    <div id="skin-preview-section">
                        <div id="skin3d-controls">
                            <div class="control-group">
                                <div class="control-group-title">Анимация</div>
                                <button id="toggleWalkAnimBtn" class="skin3d-ctrl-btn active">Анимация ходьбы</button>
                                <button id="toggleRunAnimBtn" class="skin3d-ctrl-btn">Анимация бега</button>
                            </div>
                            <div class="control-group">
                                <div class="control-group-title">Камера</div>
                                <button id="toggleAutoRotateBtn" class="skin3d-ctrl-btn">Автовращение</button>
                            </div>
                            <div class="control-group">
                                <div class="control-group-title">Отображение</div>
                                <button id="toggleCapeBtn" class="skin3d-ctrl-btn active">Скрыть плащ</button>
                            </div>
                            <div class="control-group">
                                <div class="control-group-title">История</div>
                                <button id="showHistoryBtn" class="skin3d-ctrl-btn">История скинов</button>
                            </div>
                            <div class="download-buttons">
                                <a id="downloadSkinBtn" class="button download-btn">Скачать скин</a>
                                <a id="downloadCapeBtn" class="button download-btn" style="display:none;">Скачать плащ</a>
                            </div>
                        </div>
                        <div id="skin3d-container"></div>
                    </div>
                </div>

                <div class="tab-pane fade" id="achievements" role="tabpanel">
                    <div class="achievements-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                        <!-- Достижения будут добавлены динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="matches" role="tabpanel">
                    <div class="matches-loading" id="matches-loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Загрузка...</span>
                        </div>
                        <div style="margin-top: 10px;">Загрузка истории матчей...</div>
                    </div>
                    <div class="matches-error" id="matches-error" style="display: none;">
                        <div>Не удалось загрузить историю матчей</div>
                        <button class="btn btn-primary mt-3" id="retry-matches-btn">Повторить</button>
                    </div>
                    <!-- Фильтры для матчей -->
                    <div id="matches-filters" style="display: none; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; gap: 12px; background: #fff; padding: 16px 20px; border-radius: 12px; box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08); flex-wrap: wrap;">
                            <label for="matches-game-filter" style="font-family: 'VimeArtBold', sans-serif; font-size: 1rem; color: #3498db; margin: 0;">Игра:</label>
                            <select id="matches-game-filter" style="flex: 1; min-width: 150px; max-width: 220px; padding: 10px 16px; font-family: 'VimeArtBold', sans-serif; font-size: 0.95rem; color: #2c3e50; background: #f8fbff; border: 2px solid #e6f3ff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; outline: none;">
                                <option value="all">Все игры</option>
                            </select>
                            
                            <label for="matches-result-filter" style="font-family: 'VimeArtBold', sans-serif; font-size: 1rem; color: #3498db; margin: 0 0 0 12px;">Результат:</label>
                            <select id="matches-result-filter" style="flex: 1; min-width: 150px; max-width: 220px; padding: 10px 16px; font-family: 'VimeArtBold', sans-serif; font-size: 0.95rem; color: #2c3e50; background: #f8fbff; border: 2px solid #e6f3ff; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; outline: none;">
                                <option value="all">Все результаты</option>
                                <option value="win">Победы</option>
                                <option value="lose">Поражения</option>
                                <option value="draw">Ничьи</option>
                            </select>
                        </div>
                    </div>
                    <div class="matches-list" id="matches-list" style="display: none;">
                        <!-- Матчи будут добавлены динамически -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/skinview3d@latest/bundles/skinview3d.bundle.js"></script>
    <script src="js/ranks.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/search.js"></script>
    <script src="js/navbar.js"></script>
    <script src="js/settings.js"></script>
    <script>
        // Обработчик клика для баннера профиля
        document.addEventListener('DOMContentLoaded', function() {
            const profileBanner = document.querySelector('.profile-banner');
            if (profileBanner) {
                profileBanner.addEventListener('click', function() {
                    this.classList.toggle('expanded');
                });
            }
            
            // Плавная загрузка изображения баннера
            const bannerImg = document.getElementById('profile-banner-img');
            if (bannerImg) {
                // Если изображение уже загружено
                if (bannerImg.complete) {
                    bannerImg.classList.add('loaded');
                } else {
                    // Добавляем обработчик загрузки
                    bannerImg.addEventListener('load', function() {
                        this.classList.add('loaded');
                    });
                    
                    // Обработчик ошибки загрузки
                    bannerImg.addEventListener('error', function() {
                        // Если изображение не загрузилось, все равно показываем фон
                        this.classList.add('loaded');
                    });
                }
            }
        });

        // Получаем никнейм из URL
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username');
        
        if (!username) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = 'Никнейм не указан';
        } else {
            // Функция для форматирования времени игры
            function formatPlaytime(seconds, full = false) {
                const days = Math.floor(seconds / (3600 * 24));
                const hours = Math.floor((seconds % (3600 * 24)) / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                // Функция для получения правильного окончания
                function getEnding(number, endings) {
                    if (number === 0) return endings[2];
                    const lastDigit = number % 10;
                    const lastTwoDigits = number % 100;
                    
                    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                        return endings[2];
                    }
                    
                    if (lastDigit === 1) {
                        return endings[0];
                    }
                    
                    if (lastDigit >= 2 && lastDigit <= 4) {
                        return endings[1];
                    }
                    
                    return endings[2];
                }

                if (!full) {
                    if (days > 0) return `${days} ${getEnding(days, ['день', 'дня', 'дней'])}`;
                    if (hours > 0) return `${hours} ${getEnding(hours, ['час', 'часа', 'часов'])}`;
                    if (minutes > 0) return `${minutes} ${getEnding(minutes, ['минута', 'минуты', 'минут'])}`;
                    return `${remainingSeconds} ${getEnding(remainingSeconds, ['секунда', 'секунды', 'секунд'])}`;
                }

                let result = '';
                if (days > 0) result += `${days} ${getEnding(days, ['день', 'дня', 'дней'])} `;
                if (hours > 0 || days > 0) result += `${hours} ${getEnding(hours, ['час', 'часа', 'часов'])} `;
                if (minutes > 0 || hours > 0 || days > 0) result += `${minutes} ${getEnding(minutes, ['минута', 'минуты', 'минут'])} `;
                result += `${remainingSeconds} ${getEnding(remainingSeconds, ['секунда', 'секунды', 'секунд'])}`;

                return result.trim();
            }

            // Функция для форматирования Unix timestamp
            function formatUnixTimestamp(timestamp) {
                if (!timestamp || timestamp === -1) return 'неизвестно';
                
                const date = new Date(timestamp * 1000); // Конвертируем в миллисекунды
                
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                
                return `${day}.${month}.${year} ${hours}:${minutes}:${seconds}`;
            }

            // Функция для конвертации цветовых кодов Minecraft в HTML цвета
            function convertMinecraftColors(text) {
                const colorMap = {
                    '&0': '#000000', // Черный
                    '&1': '#0000AA', // Темно-синий
                    '&2': '#00AA00', // Темно-зеленый
                    '&3': '#00AAAA', // Темно-бирюзовый
                    '&4': '#AA0000', // Темно-красный
                    '&5': '#AA00AA', // Темно-пурпурный
                    '&6': '#FFAA00', // Золотой
                    '&7': '#AAAAAA', // Серый
                    '&8': '#555555', // Темно-серый
                    '&9': '#5555FF', // Синий
                    '&a': '#55FF55', // Зеленый
                    '&b': '#55FFFF', // Бирюзовый
                    '&c': '#FF5555', // Красный
                    '&d': '#FF55FF', // Пурпурный
                    '&e': '#FFFF55', // Желтый
                    '&f': '#FFFFFF', // Белый
                    '&l': 'font-weight: bold;', // Жирный
                    '&n': 'text-decoration: underline;', // Подчеркнутый
                    '&o': 'font-style: italic;', // Курсив
                    '&k': 'text-decoration: line-through;', // Зачеркнутый
                    '&r': 'color: inherit; font-weight: normal; text-decoration: none; font-style: normal;' // Сброс форматирования
                };

                let result = text;
                for (const [code, style] of Object.entries(colorMap)) {
                    const regex = new RegExp(code, 'g');
                    if (style.startsWith('#')) {
                        // Добавляем тень для белого цвета (&f)
                        if (code === '&f') {
                            result = result.replace(regex, `<span style="color: ${style}; text-shadow: 0px 0px 2px rgba(0,0,0,0.3);">`);
                        } else {
                            result = result.replace(regex, `<span style="color: ${style}">`);
                        }
                    } else {
                        result = result.replace(regex, `<span style="${style}">`);
                    }
                }
                return result;
            }

            // Добавляем функции для работы с кешем
            function savePlayerData(nick, data) {
                const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
                playerCache[nick] = {
                    ...data,
                    timestamp: Date.now()
                };
                localStorage.setItem('playerCache', JSON.stringify(playerCache));
            }

            function getPlayerData(nick) {
                const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
                return playerCache[nick];
            }

            // Функция для обновления статуса игрока из данных сессии
            function updatePlayerStatusFromData(sessionData) {
                const playerStatus = document.getElementById('player-status');
                
                // Очищаем содержимое перед обновлением
                playerStatus.innerHTML = '';
                
                if (sessionData.online && sessionData.online.value) {
                    playerStatus.classList.add('online');
                    playerStatus.classList.remove('offline');
                    const statusTextSpan = document.createElement('span');
                    const message = sessionData.online.message || 'Онлайн';
                    statusTextSpan.textContent = message.replace(/^(Играет|Находится) (в|на) /, '');
                    statusTextSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    statusTextSpan.style.fontWeight = 'normal';
                    statusTextSpan.style.fontSize = '0.8rem';
                    playerStatus.appendChild(statusTextSpan);
                    
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'status-icon-square';
                    playerStatus.appendChild(statusIndicator);
                } else {
                    playerStatus.classList.add('offline');
                    playerStatus.classList.remove('online');
                    const statusTextSpan = document.createElement('span');
                    statusTextSpan.textContent = 'Оффлайн';
                    statusTextSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    statusTextSpan.style.fontWeight = 'normal';
                    statusTextSpan.style.fontSize = '0.8rem';
                    playerStatus.appendChild(statusTextSpan);
                    
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'status-icon-square';
                    playerStatus.appendChild(statusIndicator);
                }
            }

            function getPlayerSkin(username) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        resolve(img.src); 
                    };
                    
                    img.onerror = () => {
                        resolve(`/assets/skins/steve.png`);
                    };

                    img.src = `https://skin.vimeworld.com/raw/skin/${username}.png`;
                });
            }
            
            // Функция для обновления статуса игрока через новый запрос
            async function updatePlayerStatus() {
                try {
                    const sessionResponse = await fetch(`https://api.vimeworld.com/user/name/${username}/session`);
                    const sessionData = await sessionResponse.json();
                    updatePlayerStatusFromData(sessionData);
                } catch (error) {
                    console.error('Ошибка при обновлении статуса:', error);
                }
            }

            // Загрузка всех данных игрока параллельно
            async function loadPlayerData() {
                try {
                    // Делаем запросы к API параллельно
                    const [playerResponse, sessionResponse, statsResponse] = await Promise.all([
                        fetch(`https://api.vimeworld.com/user/name/${username}`),
                        fetch(`https://api.vimeworld.com/user/name/${username}/session`),
                        fetch(`https://api.vimeworld.com/user/name/${username}/stats`)
                    ]);
                    
                    // Запрос к friends делаем только при переключении на вкладку
                    
                    // Обрабатываем ответы параллельно
                    const [playerData, sessionData, statsData] = await Promise.all([
                        playerResponse.json(),
                        sessionResponse.json(),
                        statsResponse.json()
                    ]);

                    if (playerData.length === 0) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').style.display = 'block';
                        return;
                    }

                    const player = playerData[0];
                    const playerRankElement = document.getElementById('player-rank');
                    const rankBadgeElement = playerRankElement.closest('.rank-badge');
                    const primeBadgeElement = document.getElementById('prime-badge');
                    const additionalRanksContainer = document.querySelector('.additional-ranks');
                    additionalRanksContainer.innerHTML = '';

                    // Обновляем статус игрока на основе полученных данных сессии
                    updatePlayerStatusFromData(sessionData);
                    loadFriendsBasicInfo(username);
                    // Запускаем периодическое обновление статуса
                    setInterval(updatePlayerStatus, 10000); // Обновляем каждые 10 секунд

                    // Обновляем информацию о ранге
                    const mainRank = player.rank || "PLAYER";
                    const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                    playerRankElement.textContent = rankInfo.name;

                    // Устанавливаем цвет текста основного ранга в белый и фон обертки
                    playerRankElement.style.color = '#fff';
                    playerRankElement.style['-webkit-background-clip'] = '';
                    playerRankElement.style['-webkit-text-fill-color'] = '';

                    if (rankInfo.colors.length > 0) {
                        if (rankInfo.colors.length === 1) {
                            rankBadgeElement.style.background = `#${rankInfo.colors[0]}`;
                        } else {
                            const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                            rankBadgeElement.style.background = gradient;
                        }
                         rankBadgeElement.style.display = 'inline-block';
                    } else {
                         rankBadgeElement.style.display = 'none';
                    }

                    // Отображаем Prime статус
                    if (player.prime) {
                        primeBadgeElement.style.display = 'inline-block';
                        
                        // Добавляем tooltip с датой приобретения Prime
                        if (player.primeStart) {
                            // Удаляем старый tooltip если есть
                            const oldTooltip = primeBadgeElement.querySelector('.prime-tooltip');
                            if (oldTooltip) {
                                oldTooltip.remove();
                            }
                            
                            // Создаем новый tooltip
                            const tooltip = document.createElement('span');
                            tooltip.classList.add('prime-tooltip');
                            
                            // Конвертируем Unix timestamp в дату
                            const primeDate = new Date(player.primeStart * 1000);
                            const day = String(primeDate.getDate()).padStart(2, '0');
                            const month = String(primeDate.getMonth() + 1).padStart(2, '0');
                            const year = primeDate.getFullYear();
                            const hours = String(primeDate.getHours()).padStart(2, '0');
                            const minutes = String(primeDate.getMinutes()).padStart(2, '0');
                            const seconds = String(primeDate.getSeconds()).padStart(2, '0');
                            
                            tooltip.textContent = `Подписка действует с ${day}.${month}.${year} ${hours}:${minutes}:${seconds}`;
                            primeBadgeElement.appendChild(tooltip);
                        }
                    } else {
                        primeBadgeElement.style.display = 'none';
                    }

                    // Добавляем дополнительные ранги
                    if (player.ranks && player.ranks.length > 0) {
                        player.ranks.forEach(rank => {
                            // Проверяем, не является ли это основным рангом
                            if (rank !== mainRank) {
                                const additionalRankBadge = document.createElement('span');
                                additionalRankBadge.classList.add('additional-rank-badge');
                                // Используем полное название ранга из ranksData, если доступно
                                const additionalRankInfo = ranksData[rank] || { name: rank, colors: [] }; // Получаем информацию о дополнительном ранге, включая цвета
                                additionalRankBadge.textContent = additionalRankInfo.name;

                                // Применяем цвета из ranksData к фону
                                if (additionalRankInfo.colors && additionalRankInfo.colors.length > 0) {
                                    if (additionalRankInfo.colors.length === 1) {
                                        // Один цвет
                                        additionalRankBadge.style.background = `#${additionalRankInfo.colors[0]}`;
                                    } else {
                                        // Несколько цветов - создаем градиент
                                        const gradient = `linear-gradient(to right, ${additionalRankInfo.colors.map(color => `#${color}`).join(', ')})`;
                                        additionalRankBadge.style.background = gradient;
                                    }
                                } else {
                                    // Если цветов нет, можно использовать дефолтный фон или скрыть
                                    // В данном случае оставим дефолтный фон из CSS (сине-белый градиент)
                                }

                                // Текст дополнительных рангов всегда белый
                                additionalRankBadge.style.color = '#fff';

                                additionalRanksContainer.appendChild(additionalRankBadge);
                            }
                        });
                    }

                    // Обновляем остальную информацию на странице
                    const playerNameElement = document.getElementById('player-name');
                    
                    // Добавляем префикс, если он есть
                    if (player.prefix) {
                        const prefixSpan = document.createElement('span');
                        prefixSpan.textContent = `[${player.prefix}]`;
                        prefixSpan.style.marginRight = '0';
                        // Устанавливаем цвет префикса в соответствии с первым цветом ранга
                        const mainRank = player.rank || "PLAYER";
                        const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                        if (rankInfo.colors && rankInfo.colors.length > 0) {
                            prefixSpan.style.color = `#${rankInfo.colors[0]}`;
                        } else {
                            prefixSpan.style.color = '#7f8c8d'; // Дефолтный серый цвет, если у ранга нет цветов
                        }
                        prefixSpan.style.fontSize = '1.8rem';
                        playerNameElement.parentNode.insertBefore(prefixSpan, playerNameElement);
                    }
                    
                    playerNameElement.textContent = player.username;
                    
                    // Делаем никнейм кликабельным для открытия истории ников
                    playerNameElement.style.cursor = 'pointer';
                    playerNameElement.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                    playerNameElement.title = 'Нажмите, чтобы посмотреть историю ников';
                    
                    playerNameElement.onclick = function(e) {
                        e.stopPropagation();
                        showNickHistoryTooltip(player.id, this);
                    };
                    
                    // Добавляем primeIcon после никнейма, если он есть
                    if (player.primeIcon) {
                        const primeIconSpan = document.createElement('span');
                        primeIconSpan.innerHTML = convertMinecraftColors(player.primeIcon);
                        primeIconSpan.style.marginLeft = '4px';
                        primeIconSpan.style.fontSize = '1.4rem'; // Немного меньше чем никнейм
                        // Вставляем после элемента с именем, а не внутрь него
                        playerNameElement.parentNode.insertBefore(primeIconSpan, playerNameElement.nextSibling);
                    }
                    
                    // Применяем кастомные цвета к никнейму, если они есть
                    if (player.customColors && player.customColors.length > 0) {
                        if (player.customColors.length === 1) {
                            playerNameElement.style.color = `#${player.customColors[0]}`;
                        } else {
                            const gradient = `linear-gradient(to right, ${player.customColors.map(color => `#${color}`).join(', ')})`;
                            playerNameElement.style.background = gradient;
                            playerNameElement.style.webkitBackgroundClip = 'text';
                            playerNameElement.style.webkitTextFillColor = 'transparent';
                        }
                    } else {
                        // Сбрасываем стили к дефолтным, если кастомных цветов нет
                        playerNameElement.style.color = '#2c3e50'; /* Черный цвет по умолчанию */
                        playerNameElement.style.background = '';
                        playerNameElement.style.webkitBackgroundClip = '';
                        playerNameElement.style.webkitTextFillColor = '';
                    }

                    document.getElementById('player-id').textContent = `id: ${player.id}`;
                    
                    // Сохраняем ID игрока для использования в истории скинов
                    window.currentPlayerId = player.id;
                    
                    // Обновляем информацию об уровне (без процента)
                    document.getElementById('player-level-meta').textContent = `Уровень: ${player.level}`;
                    
                    // Функция для расчета опыта для уровня
                    function calculateXPForLevel(level) {
                        if (level <= 1) return 8000;
                        if (level === 2) return 10000;
                        if (level === 3) return 12000;
                        return 8000 + (level - 1) * 2000;
                    }
                    
                    // Рассчитываем необходимый опыт для текущего уровня
                    const requiredXP = calculateXPForLevel(player.level);
                    const currentXP = Math.floor(player.levelPercentage * requiredXP);
                    const progressPercent = Math.floor(player.levelPercentage * 100);
                    
                    // Обновляем текст опыт-бара
                    const experienceText = document.getElementById('experience-text');
                    if (experienceText) {
                        experienceText.textContent = `${progressPercent}% - ${currentXP} / ${requiredXP} XP`;
                    }
                    
                    // Обновляем информацию о оставшемся опыте справа
                    const experienceRemain = document.getElementById('experience-remain');
                    if (experienceRemain) {
                        const remainXP = requiredXP - currentXP;
                        experienceRemain.textContent = `${remainXP} XP`;
                    }
                    
                    // Обновляем полосу прогресса опыта
                    const experienceProgress = document.getElementById('experience-progress');
                    if (experienceProgress && player.levelPercentage !== undefined) {
                        experienceProgress.style.width = `${progressPercent}%`;
                    }

                    const playtimeHeaderSpan = document.getElementById('player-playtime-header');
                    const playtimeContainer = playtimeHeaderSpan.parentElement; // Получаем родительский div.status-item

                    playtimeHeaderSpan.textContent = formatPlaytime(player.playedSeconds);

                    // Создаем и добавляем элемент для отображения полного времени при наведении
                    const fullPlaytimeSpan = document.createElement('span');
                    fullPlaytimeSpan.classList.add('full-playtime-tooltip');
                    // Стили для fullPlaytimeSpan определены в CSS классе .full-playtime-tooltip
                    fullPlaytimeSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    fullPlaytimeSpan.style.fontSize = '0.8rem';
                    fullPlaytimeSpan.style.color = '#7f8c8d';
                    fullPlaytimeSpan.style.fontWeight = 'normal'; // Убираем жирность

                    playtimeContainer.appendChild(fullPlaytimeSpan);

                    // Получаем кликабельный элемент для "Наиграно" (уточняем селектор)
                    const playtimeTriggerSpan = document.querySelector('.status-item:has(#player-playtime-header) .playtime-trigger');

                    // Добавляем обработчик клика, если элемент найден
                    if (playtimeTriggerSpan) {
                        // Находим всплывающее окно внутри того же контейнера status-item
                        const fullPlaytimeSpan = playtimeTriggerSpan.closest('.status-item').querySelector('.full-playtime-tooltip');
                        // Удаляем зависимость от lastSeenContainer

                        if (fullPlaytimeSpan) {
                            // Скрываем полное время по умолчанию
                            fullPlaytimeSpan.style.opacity = '0';

                            // Добавляем обработчик клика
                            playtimeTriggerSpan.style.cursor = 'pointer'; // Добавляем курсор-указатель
                            playtimeTriggerSpan.addEventListener('click', () => {
                                const isHidden = fullPlaytimeSpan.style.opacity === '0' || fullPlaytimeSpan.style.display === 'none';
                                // Находим блок с последним входом
                                const lastSeenContainer = document.querySelector('.status-item:has(#player-last-seen)');
                                
                                if (isHidden) {
                                    // Обеспечиваем корректное отображение перед показом
                                    fullPlaytimeSpan.style.display = '';
                                    // Скрываем блок с последним входом
                                    if (lastSeenContainer) {
                                        lastSeenContainer.style.display = 'none';
                                    }
                                    // Используем setTimeout, чтобы изменение display применилось перед установкой opacity
                                    setTimeout(() => {
                                        fullPlaytimeSpan.textContent = formatPlaytime(player.playedSeconds, true);
                                        fullPlaytimeSpan.style.opacity = '1';
                                    }, 10);
                                } else {
                                    // Полностью скрываем информацию используя функцию hideFullPlaytime
                                    hideFullPlaytime();
                                    // Показываем блок с последним входом обратно
                                    if (lastSeenContainer) {
                                        lastSeenContainer.style.display = '';
                                    }
                                }
                            });

                            // Функция полного сброса и скрытия всплывающего окна
                            const hideFullPlaytime = () => {
                                fullPlaytimeSpan.style.opacity = '0';
                                fullPlaytimeSpan.textContent = ''; // Очищаем содержимое
                                fullPlaytimeSpan.style.display = 'none'; // Полностью скрываем элемент
                                
                                // Показываем блок с последним входом
                                const lastSeenContainer = document.querySelector('.status-item:has(#player-last-seen)');
                                if (lastSeenContainer) {
                                    lastSeenContainer.style.display = '';
                                }
                                
                                // Через небольшую задержку возвращаем display для будущих показов
                                setTimeout(() => {
                                    fullPlaytimeSpan.style.display = ''; // Восстанавливаем display
                                }, 200);
                            };

                            // Создаем уникальный идентификатор для обработчика
                            const clickHandlerId = 'playtime_click_handler_' + Date.now();
                            
                            // Добавляем обработчик на document для скрытия при клике вне блока
                            const documentClickHandler = function(event) {
                                if (!playtimeTriggerSpan.contains(event.target) && !fullPlaytimeSpan.contains(event.target)) {
                                    hideFullPlaytime();
                                    // После срабатывания удаляем обработчик, чтобы он больше не влиял на страницу
                                    document.removeEventListener('click', documentClickHandler);
                                }
                            };
                            
                            // Устанавливаем обработчик только когда открывается всплывающее окно
                            playtimeTriggerSpan.addEventListener('click', function() {
                                // Добавляем обработчик с задержкой, чтобы он не сработал сразу же на текущем клике
                                setTimeout(() => {
                                    if (fullPlaytimeSpan.style.opacity === '1') {
                                        document.addEventListener('click', documentClickHandler);
                                    }
                                }, 50);
                            });

                            // Обработчик нажатия клавиши ESC для скрытия
                            const escKeyHandler = function(event) {
                                if (event.key === 'Escape') {
                                    hideFullPlaytime();
                                    // Удаляем обработчик после срабатывания
                                    document.removeEventListener('keydown', escKeyHandler);
                                }
                            };
                            
                            // Устанавливаем обработчик ESC только когда открывается всплывающее окно
                            playtimeTriggerSpan.addEventListener('click', function() {
                                // Добавляем обработчик с задержкой
                                setTimeout(() => {
                                    if (fullPlaytimeSpan.style.opacity === '1') {
                                        document.addEventListener('keydown', escKeyHandler);
                                    }
                                }, 50);
                            });
                        }
                    }

                    document.getElementById('player-friends').textContent = '0';
                    
                    // Обновляем информацию о гильдии
                    const playerGuildElement = document.getElementById('player-guild');
                    if (player.guild) {
                        // Создаем элемент для отображения гильдии
                        let guildText = '';
                        
                        // Добавляем тег гильдии, если он есть
                        if (player.guild.tag && player.guild.tag.trim() !== '') {
                            // Добавляем серые скобки и тег с нужным цветом
                            guildText += '<span style="color: #AAAAAA">&lt;</span>';
                            
                            // Определяем цвет тега
                            let tagColor = '#7f8c8d'; // Цвет по умолчанию
                            if (player.guild.color && player.guild.color.startsWith('&')) {
                                const colorCode = player.guild.color;
                                const colorMap = {
                                    '&0': '#000000', // Черный
                                    '&1': '#0000AA', // Темно-синий
                                    '&2': '#00AA00', // Темно-зеленый
                                    '&3': '#00AAAA', // Темно-бирюзовый
                                    '&4': '#AA0000', // Темно-красный
                                    '&5': '#AA00AA', // Темно-пурпурный
                                    '&6': '#FFAA00', // Золотой
                                    '&7': '#AAAAAA', // Серый
                                    '&8': '#555555', // Темно-серый
                                    '&9': '#5555FF', // Синий
                                    '&a': '#55FF55', // Зеленый
                                    '&b': '#55FFFF', // Бирюзовый
                                    '&c': '#FF5555', // Красный
                                    '&d': '#FF55FF', // Пурпурный
                                    '&e': '#FFFF55', // Желтый
                                    '&f': '#FFFFFF'  // Белый
                                };
                                if (colorMap[colorCode]) {
                                    tagColor = colorMap[colorCode];
                                    // Добавляем тень для белого цвета (&f)
                                    if (colorCode === '&f') {
                                        guildText += `<span style="color: ${tagColor}; text-shadow: 0px 0px 2px rgba(0,0,0,0.3); font-weight: bold;">${player.guild.tag}</span>`;
                                    } else {
                                        guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                                    }
                                } else {
                                    guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                                }
                            } else {
                                guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                            }
                            
                            guildText += '<span style="color: #AAAAAA">&gt;</span> ';
                        }
                        
                        // Обрабатываем название гильдии с учетом форматирования Minecraft
                        let guildName = player.guild.name;
                        guildText += convertMinecraftColors(guildName);
                        
                        playerGuildElement.innerHTML = guildText;
                    } else {
                        playerGuildElement.textContent = 'Нет гильдии';
                    }
                    
                    document.getElementById('player-playtime-header').textContent = formatPlaytime(player.playedSeconds);
                    const lastSeenElement = document.getElementById('player-last-seen');
                    const lastSeenContainer = lastSeenElement.closest('.status-item');
                    lastSeenContainer.innerHTML = `
                        <span style="display: flex; align-items: center; gap: 4px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Последний вход:</span>
                            <span id="player-last-seen" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">${formatUnixTimestamp(player.lastSeen)}</span>
                        </span>
                    `;

                    // Добавляем голову игрока
                    const playerAvatarDiv = document.getElementById('player-avatar');
                    playerAvatarDiv.innerHTML = ''; // Очищаем placeholder

                    // Добавляем обработчик клика для переключения на вкладку "Скин"
                    playerAvatarDiv.style.cursor = 'pointer';
                    playerAvatarDiv.addEventListener('click', () => {
                        const skinTab = document.getElementById('skin-tab');
                        const skinTabInstance = new bootstrap.Tab(skinTab);
                        skinTabInstance.show();
                    });

                    // Добавляем базовую голову
                    const playerHeadImg = document.createElement('img');
                    playerHeadImg.src = `https://skin.vimeworld.com/head/${player.username}.png`;
                    playerHeadImg.alt = `${player.username} head`;
                    playerHeadImg.classList.add('player-avatar-base');
                    playerAvatarDiv.appendChild(playerHeadImg);

                    // Добавляем оверлей головы из полного скина
                    const skinFullUrl = await getPlayerSkin(player.username);
                    const skinFullImg = new Image();
                    
                    skinFullImg.onerror = function() {
                        // Игнорируем ошибку загрузки скина (например, если у игрока нет кастомного скина)
                        // Не логируем, чтобы не засорять консоль
                    };

                    skinFullImg.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Определяем размер скина и рассчитываем масштабирование
                        const skinResolution = skinFullImg.width; // Предполагаем квадратный скин
                        const scale = skinResolution / 64;

                        // Координаты и размер оверлея головы на стандартном скине (64x64)
                        const baseOverlayX = 40;
                        const baseOverlayY = 8;
                        const baseOverlaySize = 8;

                        // Масштабируем координаты и размер под текущее разрешение скина
                        const scaledOverlayX = baseOverlayX * scale;
                        const scaledOverlayY = baseOverlayY * scale;
                        const scaledOverlaySize = baseOverlaySize * scale;

                        canvas.width = scaledOverlaySize; // Размер оверлея головы
                        canvas.height = scaledOverlaySize;

                        // Вырезаем оверлей головы из масштабированного скина
                        ctx.drawImage(skinFullImg, scaledOverlayX, scaledOverlayY, scaledOverlaySize, scaledOverlaySize, 0, 0, scaledOverlaySize, scaledOverlaySize);

                        // Создаем изображение из canvas и добавляем на страницу
                        const overlayImg = document.createElement('img');
                        overlayImg.src = canvas.toDataURL();
                        overlayImg.alt = `${player.username} head overlay`;
                        // Применяем стили для оверлея
                        overlayImg.classList.add('player-avatar-overlay');
                         playerAvatarDiv.appendChild(overlayImg);
                    };

                    // Устанавливаем crossOrigin и src после обработчиков
                    skinFullImg.crossOrigin = "Anonymous";
                    skinFullImg.src = skinFullUrl;

                    // Инициализация SkinViewer
                   // const skinUrl = `https://skin.vimeworld.com/raw/skin/${player.username}.png`;
                    const skinUrl = await getPlayerSkin(player.username);
                    const capeUrl = `https://skin.vimeworld.com/raw/cape/${player.username}.png`;

                    const skinContainer = document.getElementById('skin3d-container');
                    skinContainer.innerHTML = ""; // очищаем
                    const viewer = new skinview3d.SkinViewer({
                        canvas: Object.assign(document.createElement("canvas"), { width: 480, height: 700 }),
                        width: 480,
                        height: 700,
                        skin: skinUrl,
                        cape: capeUrl,
                        background: '#ffffff',
                        lighting: true,
                        ambientLight: 0.5,
                        directionalLight: 0.8
                    });
                    skinContainer.appendChild(viewer.canvas);
                    viewer.controls.enableRotate = true;
                    viewer.controls.enableZoom = true;
                    viewer.controls.enablePan = false;
                    viewer.controls.autoRotate = false;
                    viewer.controls.autoRotateSpeed = 1.0;

                    // Инициализация анимации ходьбы
                    viewer.animation = new skinview3d.WalkingAnimation();
                    viewer.animation.speed = 1.2;

                    // Анимации
                    const walkAnimBtn = document.getElementById('toggleWalkAnimBtn');
                    const runAnimBtn = document.getElementById('toggleRunAnimBtn');

                    function resetAnimationButtons() {
                        [walkAnimBtn, runAnimBtn].forEach(btn => {
                            btn.classList.remove('active');
                        });
                    }

                    walkAnimBtn.onclick = function () {
                        if (walkAnimBtn.classList.toggle('active')) {
                            resetAnimationButtons();
                            walkAnimBtn.classList.add('active');
                            viewer.animation = new skinview3d.WalkingAnimation();
                            viewer.animation.speed = 1.2;
                        } else {
                            viewer.animation = null;
                        }
                    };

                    runAnimBtn.onclick = function () {
                        if (runAnimBtn.classList.toggle('active')) {
                            resetAnimationButtons();
                            runAnimBtn.classList.add('active');
                            viewer.animation = new skinview3d.RunningAnimation();
                            viewer.animation.speed = 0.8;
                        } else {
                            viewer.animation = null;
                        }
                    };

                    // Кнопки скачивания
                    document.getElementById('downloadSkinBtn').onclick = function (e) {
                        e.preventDefault();
                        downloadFile(skinUrl, `${player.username}.png`);
                    };
                    // Проверяем наличие плаща перед отображением кнопки скачивания плаща
                    fetch(capeUrl, { method: 'HEAD' })
                        .then(res => {
                            const capeBtn = document.getElementById('downloadCapeBtn');
                            if (res.ok) {
                                capeBtn.style.display = '';
                                capeBtn.onclick = function (e) {
                                    e.preventDefault();
                                    downloadFile(capeUrl, `${player.username}_cape.png`);
                                };
                            } else {
                                capeBtn.style.display = 'none';
                            }
                        });

                    // Управление камерой
                    const autoRotateBtn = document.getElementById('toggleAutoRotateBtn');

                    autoRotateBtn.onclick = function () {
                        const isActive = autoRotateBtn.classList.toggle('active');
                        viewer.controls.autoRotate = isActive;
                    };

                    // Управление отображением
                    const capeBtn = document.getElementById('toggleCapeBtn');

                    capeBtn.onclick = function () {
                        if (capeBtn.classList.toggle('active')) {
                            fetch(capeUrl, { method: 'HEAD' })
                                .then(res => { if (res.ok) viewer.loadCape(capeUrl); });
                        } else {
                            viewer.loadCape(null);
                        }
                    };

                    // Показываем контент
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('player-content').style.display = 'block';

                    // Сохраняем статистику в кэш окна для переключения режимов
                    window.cachedStatsData = statsData;
                    
                    // Загружаем статистику из уже полученных данных
                    processPlayerStats(statsData, false);
                    
                    // Загружаем данные о топах игрока
                    loadPlayerLeaderboards(player.id);

                } catch (error) {
                    console.error('Ошибка при загрузке данных:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                }
            }

            // Добавляем обработчик клика для переключения между общей и сезонной статистикой
            document.getElementById('stats-tab').addEventListener('click', function(e) {
                // Проверяем, активна ли вкладка "Статистика"
                const statsTab = document.getElementById('stats');
                const isStatsActive = statsTab.classList.contains('show') && statsTab.classList.contains('active');
                
                if (isStatsActive) {
                    e.preventDefault();
                    const statsModeLabel = document.getElementById('stats-mode-label');
                    const isCurrentlySeasonal = statsModeLabel.textContent.includes('Сезонная');
                    
                    // Переключаем режим, используя кэшированные данные, если они есть
                    if (window.cachedStatsData) {
                        if (isCurrentlySeasonal) {
                            statsModeLabel.textContent = 'Общая';
                            processPlayerStats(window.cachedStatsData, false);
                        } else {
                            statsModeLabel.textContent = 'Сезонная';
                            processPlayerStats(window.cachedStatsData, true);
                        }
                    } else {
                        // Если данные не кэшированы, загружаем заново
                        if (isCurrentlySeasonal) {
                            statsModeLabel.textContent = 'Общая';
                            loadPlayerStats(username, false);
                        } else {
                            statsModeLabel.textContent = 'Сезонная';
                            loadPlayerStats(username, true);
                        }
                    }

                    // Предотвращаем стандартное поведение вкладки Bootstrap
                    e.stopPropagation();
                }
            });

            // Загружаем данные при загрузке страницы
            loadPlayerData();
        }

        async function loadPlayerStats(username, isSeasonal = false) {
            try {
                const response = await fetch(`https://api.vimeworld.com/user/name/${username}/stats`);
                const data = await response.json();
                processPlayerStats(data, isSeasonal);
            } catch (error) {
                console.error('Ошибка при загрузке статистики:', error);
            }
        }
        
        // Глобальная переменная для хранения данных о топах
        let playerLeaderboards = {};
        
        // Функция загрузки данных о топах игрока
        async function loadPlayerLeaderboards(playerId) {
            try {
                const response = await fetch(`https://api.vimeworld.com/user/${playerId}/leaderboards`);
                const data = await response.json();
                
                // Маппинг типов из API топов на коды игр в статистике
                const leaderboardTypeMapping = {
                    'ann': 'ANN',
                    'bb': 'BB',
                    'bp': 'BP',
                    'bw': 'BW',
                    'bwhype': 'BWHYPE',
                    'bwt': 'BWT',
                    'cp': 'CP',
                    'duels': 'DUELS',
                    'gg': 'GG',
                    'hg': 'HG',
                    'kpvp': 'KPVP',
                    'eggwars': 'EGGWARS',
                    'mw': 'MW',
                    'prison': 'PRISON',
                    'prison_lite': 'PRISON_LITE',
                    'sw': 'SW',
                    'arc': 'ARC',
                    'bridge': 'BRIDGE',
                    'jumpleague': 'JUMPLEAGUE',
                    'murder': 'MURDER',
                    'sheep': 'SHEEP',
                    'turfwars': 'TURFWARS',
                    'tnttag': 'TNTTAG',
                    'tntrun': 'TNTRUN',
                    'luckywars': 'LUCKYWARS',
                    'whitecold': 'WHITECOLD',
                    'hide': 'HIDE',
                    'speedbuilders': 'SPEEDBUILDERS',
                    'fallguys': 'FALLGUYS',
                    'teamfortress': 'TEAMFORTRESS',
                    'battlebox': 'BATTLEBOX',
                    'farm': 'FARM',
                    'fireballfight': 'FIREBALLFIGHT',
                    'deathrun': 'DEATHRUN'
                };
                
                // Сохраняем данные о топах
                playerLeaderboards = {};
                if (data.leaderboards) {
                    data.leaderboards.forEach(lb => {
                        const lbType = lb.type.toLowerCase();
                        const gameCode = leaderboardTypeMapping[lbType] || lbType.toUpperCase();
                        if (!playerLeaderboards[gameCode] || lb.place < playerLeaderboards[gameCode]) {
                            playerLeaderboards[gameCode] = lb.place;
                        }
                    });
                }
                
                // Перерисовываем статистику с учетом топов
                if (window.cachedStatsData) {
                    const isCurrentlySeasonal = document.getElementById('stats-mode-label').textContent === 'Сезонная';
                    processPlayerStats(window.cachedStatsData, isCurrentlySeasonal);
                }
            } catch (error) {
                console.error('Ошибка при загрузке топов:', error);
            }
        }
        
        function processPlayerStats(data, isSeasonal = false) {
            const statsGrid = document.querySelector('.stats-grid');
            statsGrid.innerHTML = ''; // Очищаем текущую статистику

            // Получаем сохраненный порядок из localStorage
            const savedOrder = JSON.parse(localStorage.getItem('statsBlocksOrder') || '[]');
            
            // Собираем все игры с данными
            const gamesWithStats = [];
            for (const [gameCode, gameConfig] of Object.entries(GAMES_CONFIG)) {
                const gameStats = isSeasonal ? 
                    (data.stats[gameCode]?.season?.monthly || {}) : 
                    (data.stats[gameCode]?.global || {});

                if (Object.keys(gameStats).length > 0) {
                    gamesWithStats.push({
                        gameCode,
                        gameConfig,
                        gameStats,
                        // Показываем топы только для общей статистики
                        leaderboardPlace: isSeasonal ? null : (playerLeaderboards[gameCode] || null)
                    });
                }
            }
            
            // Сортируем игры: сначала по топам (чем меньше место - тем выше), затем по сохраненному порядку
            gamesWithStats.sort((a, b) => {
                // Если у обеих игр есть место в топе
                if (a.leaderboardPlace && b.leaderboardPlace) {
                    return a.leaderboardPlace - b.leaderboardPlace;
                }
                // Если только у первой есть место в топе
                if (a.leaderboardPlace && !b.leaderboardPlace) {
                    return -1;
                }
                // Если только у второй есть место в топе
                if (!a.leaderboardPlace && b.leaderboardPlace) {
                    return 1;
                }
                // Если ни у одной нет места в топе, используем сохраненный порядок
                if (savedOrder.length > 0) {
                    const indexA = savedOrder.indexOf(a.gameCode);
                    const indexB = savedOrder.indexOf(b.gameCode);
                    if (indexA === -1 && indexB === -1) return 0;
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                }
                return 0;
            });

            // Счетчик для отслеживания количества блоков в ряду
            let blocksInRow = 0;
            let currentRow = document.createElement('div');
            currentRow.className = 'stats-row';
            statsGrid.appendChild(currentRow);

            // Создаем блоки в отсортированном порядке
            gamesWithStats.forEach(({ gameCode, gameConfig, gameStats, leaderboardPlace }) => {
                const gameData = {
                    ...gameConfig,
                    global: gameStats
                };
                
                const statsBlock = createStatsBlock(gameCode, gameData, leaderboardPlace);
                
                // Если в текущем ряду уже 4 блока, создаем новый ряд
                if (blocksInRow === 4) {
                    currentRow = document.createElement('div');
                    currentRow.className = 'stats-row';
                    statsGrid.appendChild(currentRow);
                    blocksInRow = 0;
                }

                currentRow.appendChild(statsBlock);
                blocksInRow++;
            });
        }

        // Переменная для хранения перетаскиваемого элемента
        let draggedElement = null;
        let autoScrollInterval = null;
        let currentMouseY = 0;
        let currentMouseX = 0;
        let isDragging = false;
        let dragGhost = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let velocityX = 0;
        let velocityY = 0;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function handleMouseDown(e) {
            // Начинаем перетаскивание
            draggedElement = this;
            isDragging = true;
            this.classList.add('dragging');
            
            // Вычисляем смещение от точки клика до верхнего левого угла элемента
            const rect = this.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Инициализируем позицию мыши
            currentMouseX = e.clientX;
            currentMouseY = e.clientY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            // Создаем визуальную копию элемента
            dragGhost = this.cloneNode(true);
            dragGhost.style.position = 'fixed';
            dragGhost.style.pointerEvents = 'none';
            dragGhost.style.zIndex = '10000';
            dragGhost.style.width = this.offsetWidth + 'px';
            dragGhost.style.height = this.offsetHeight + 'px';
            dragGhost.style.transition = 'transform 0.1s ease-out';
            dragGhost.classList.remove('dragging');
            dragGhost.classList.add('drag-ghost');
            document.body.appendChild(dragGhost);
            
            // Скрываем оригинальный элемент
            this.style.opacity = '0.3';
            
            // Обновляем позицию ghost
            updateGhostPosition(e.clientX, e.clientY);
            
            // Запускаем автоскролл
            startAutoScroll();
            
            // Разрешаем ручной скролл во время перетаскивания
            enableManualScroll();
            
            // Добавляем глобальные обработчики
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Предотвращаем выделение текста
            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            
            // Сохраняем текущую позицию мыши
            currentMouseY = e.clientY;
            currentMouseX = e.clientX;
            
            // Обновляем позицию ghost элемента
            if (dragGhost) {
                updateGhostPosition(e.clientX, e.clientY);
            }
            
            // Проверяем, над каким элементом находится курсор
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            const droppableBelow = elementBelow?.closest('.stat-card');
            
            // Убираем класс drag-over со всех элементов
            document.querySelectorAll('.stat-card').forEach(card => {
                if (card !== draggedElement) {
                    card.classList.remove('drag-over');
                }
            });
            
            // Добавляем класс drag-over к элементу под курсором
            if (droppableBelow && droppableBelow !== draggedElement) {
                droppableBelow.classList.add('drag-over');
            }
        }

        function handleMouseUp(e) {
            if (!isDragging) return;
            
            // Находим элемент под курсором
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            const droppableBelow = elementBelow?.closest('.stat-card');
            
            // Если есть целевой элемент, выполняем перемещение
            if (droppableBelow && droppableBelow !== draggedElement) {
                // Получаем родительские ряды
                const draggedRow = draggedElement.parentNode;
                const targetRow = droppableBelow.parentNode;
                
                // Если элементы в одном ряду
                if (draggedRow === targetRow) {
                    const allCards = Array.from(draggedRow.children);
                    const draggedIndex = allCards.indexOf(draggedElement);
                    const targetIndex = allCards.indexOf(droppableBelow);
                    
                    if (draggedIndex < targetIndex) {
                        draggedRow.insertBefore(draggedElement, droppableBelow.nextSibling);
                    } else {
                        draggedRow.insertBefore(draggedElement, droppableBelow);
                    }
                } else {
                    // Элементы в разных рядах - меняем их местами
                    const draggedNext = draggedElement.nextSibling;
                    const targetNext = droppableBelow.nextSibling;
                    
                    if (draggedNext) {
                        targetRow.insertBefore(draggedElement, targetNext);
                        draggedRow.insertBefore(droppableBelow, draggedNext);
                    } else {
                        targetRow.insertBefore(draggedElement, targetNext);
                        draggedRow.appendChild(droppableBelow);
                    }
                }
            }
            
            // Очищаем состояние
            draggedElement.style.opacity = '';
            draggedElement.classList.remove('dragging');
            isDragging = false;
            
            // Удаляем ghost элемент
            if (dragGhost) {
                dragGhost.remove();
                dragGhost = null;
            }
            
            // Убираем класс drag-over со всех элементов
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            // Останавливаем автоскролл
            stopAutoScroll();
            
            // Отключаем ручной скролл
            disableManualScroll();
            
            // Удаляем глобальные обработчики
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // Сохраняем новый порядок
            saveStatsOrder();
            
            draggedElement = null;
            currentMouseY = 0;
            currentMouseX = 0;
            velocityX = 0;
            velocityY = 0;
            dragOffsetX = 0;
            dragOffsetY = 0;
        }

        // Старые функции для совместимости (больше не используются)
        function handleDragStart(e) {
            // Эта функция больше не используется, но оставлена для совместимости
        }

        function handleDragEnd(e) {
            // Эта функция больше не используется, но оставлена для совместимости
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            return false;
        }
        
        function globalDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            return false;
        }
        
        function updateGhostPosition(mouseX, mouseY) {
            if (!dragGhost) return;
            
            // Вычисляем скорость движения
            velocityX = mouseX - lastMouseX;
            velocityY = mouseY - lastMouseY;
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Увеличиваем максимальный угол наклона и коэффициенты для более сильного эффекта
            const maxRotation = 25;
            const rotationX = Math.max(-maxRotation, Math.min(maxRotation, velocityY * 1.5));
            const rotationZ = Math.max(-maxRotation, Math.min(maxRotation, velocityX * 1.2));
            
            // Позиционируем ghost элемент относительно точки клика (где находятся точки)
            const x = mouseX - dragOffsetX;
            const y = mouseY - dragOffsetY;
            
            // Применяем трансформации с более сильным эффектом
            dragGhost.style.left = x + 'px';
            dragGhost.style.top = y + 'px';
            dragGhost.style.transform = `
                rotateX(${-rotationX}deg) 
                rotateZ(${rotationZ}deg) 
                scale(1.08)
            `;
            dragGhost.style.boxShadow = '0 25px 70px rgba(52, 152, 219, 0.4)';
        }

        // Обработчик ручного скролла колесиком мыши
        function handleManualScroll(e) {
            if (isDragging) {
                // Предотвращаем стандартное поведение и скроллим вручную
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                // Получаем величину прокрутки (разные события используют разные свойства)
                const scrollAmount = e.deltaY || e.wheelDelta || e.detail || 0;
                
                // Скроллим страницу
                window.scrollBy({
                    top: scrollAmount,
                    behavior: 'instant'
                });
                
                // Обновляем позицию ghost элемента после скролла
                if (dragGhost && currentMouseX && currentMouseY) {
                    updateGhostPosition(currentMouseX, currentMouseY);
                }
                
                return false;
            }
        }

        function enableManualScroll() {
            // Добавляем обработчики для всех типов событий прокрутки
            const scrollHandler = handleManualScroll;
            const options = { passive: false, capture: true };
            
            // Современные браузеры
            window.addEventListener('wheel', scrollHandler, options);
            document.addEventListener('wheel', scrollHandler, options);
            document.body.addEventListener('wheel', scrollHandler, options);
            
            // Старые браузеры и альтернативные события
            window.addEventListener('mousewheel', scrollHandler, options);
            document.addEventListener('mousewheel', scrollHandler, options);
            document.body.addEventListener('mousewheel', scrollHandler, options);
            
            // Firefox
            window.addEventListener('DOMMouseScroll', scrollHandler, options);
            document.addEventListener('DOMMouseScroll', scrollHandler, options);
        }

        function disableManualScroll() {
            // Удаляем все обработчики
            const scrollHandler = handleManualScroll;
            const options = { passive: false, capture: true };
            
            window.removeEventListener('wheel', scrollHandler, options);
            document.removeEventListener('wheel', scrollHandler, options);
            document.body.removeEventListener('wheel', scrollHandler, options);
            
            window.removeEventListener('mousewheel', scrollHandler, options);
            document.removeEventListener('mousewheel', scrollHandler, options);
            document.body.removeEventListener('mousewheel', scrollHandler, options);
            
            window.removeEventListener('DOMMouseScroll', scrollHandler, options);
            document.removeEventListener('DOMMouseScroll', scrollHandler, options);
        }

        function startAutoScroll() {
            if (autoScrollInterval) return;
            
            autoScrollInterval = setInterval(() => {
                if (!draggedElement) {
                    stopAutoScroll();
                    return;
                }
                
                // Выполняем автоскролл на основе текущей позиции мыши
                performAutoScroll();
            }, 16); // ~60fps
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
        }

        function performAutoScroll() {
            if (!currentMouseY) return;
            
            const scrollThreshold = 150; // Зона в пикселях от края экрана
            const scrollSpeed = 25; // Скорость скролла
            const viewportHeight = window.innerHeight;
            
            // Скролл вверх
            if (currentMouseY < scrollThreshold) {
                const intensity = 1 - (currentMouseY / scrollThreshold);
                window.scrollBy(0, -scrollSpeed * intensity);
            }
            // Скролл вниз
            else if (currentMouseY > viewportHeight - scrollThreshold) {
                const intensity = (currentMouseY - (viewportHeight - scrollThreshold)) / scrollThreshold;
                window.scrollBy(0, scrollSpeed * intensity);
            }
        }

        // Старые функции удалены, логика перемещения теперь в handleMouseUp

        function saveStatsOrder() {
            const statsGrid = document.querySelector('.stats-grid');
            const allCards = statsGrid.querySelectorAll('.stat-card');
            const order = Array.from(allCards).map(card => card.getAttribute('data-game-code'));
            localStorage.setItem('statsBlocksOrder', JSON.stringify(order));
        }


        function formatLargeNumber(num) {
            // Если число меньше 1000, возвращаем его как есть
            if (num < 1000) {
                return num.toString();
            }

            const units = [
                '', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc',
                'UDc', 'DDc', 'TDc', 'QaDc', 'QiDc', 'SxDc', 'SpDc', 'OcDc', 'NoDc', 'Vg',
                'UVg', 'DVg', 'TVg', 'QaVg', 'QiVg', 'SxVg', 'SpVg', 'OcVg', 'NoVg', 'Tg',
                'UTg', 'DTg', 'TTg', 'QaTg', 'QiTg', 'SxTg', 'SpTg', 'OcTg', 'NoTg', 'Qd',
                'UQd', 'DQd', 'TQd', 'QaQd', 'QiQd', 'SxQd', 'SpQd', 'OcQd', 'NoQd', 'Qq',
                'UQq', 'DQq', 'TQq', 'QaQq', 'QiQq', 'SxQq', 'SpQq', 'OcQq', 'NoQq', 'Sg',
                'USg', 'DSg', 'TSg', 'QaSg', 'QiSg', 'SxSg', 'SpSg', 'OcSg', 'NoSg', 'St',
                'USt', 'DSt', 'TSt', 'QaSt', 'QiSt', 'SxSt', 'SpSt', 'OcSt', 'NoSt', 'Og',
                'UOg', 'DOg', 'TOg', 'QaOg', 'QiOg', 'SxOg', 'SpOg', 'OcOg', 'NoOg', 'Ng',
                'UNg', 'DNg', 'TNg', 'QaNg', 'QiNg', 'SxNg', 'SpNg', 'OcNg', 'NoNg', 'Ce'
            ];
            
            const k = 1000;
            const magnitude = Math.floor(Math.log(num) / Math.log(k));
            
            const value = num / Math.pow(k, magnitude);
            const formattedValue = value.toFixed(2).replace(/\.?0+$/, '');
            return formattedValue + ' ' + units[magnitude];
        }

        function createStatsBlock(gameCode, gameData, leaderboardPlace = null) {
            const block = document.createElement('div');
            block.className = 'stat-card';
            block.setAttribute('data-game-code', gameCode);
            
            // Если игра в топе, добавляем только золотую рамку
            if (leaderboardPlace) {
                block.style.border = '2px solid #e67e22';
            }
            
            // Создаем drag handle (ручку для перетаскивания) или показываем позицию в топе
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle';
            
            if (leaderboardPlace) {
                // Показываем позицию в топе вместо точек
                dragHandle.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: flex-end;
                    padding-right: 4px;
                    font-family: 'VimeArtBold', sans-serif;
                    font-size: 0.85rem;
                    font-weight: bold;
                    color: #e67e22;
                    cursor: grab;
                `;
                
                dragHandle.textContent = leaderboardPlace;
            } else {
                // Создаем 3 ряда по 2 точки (6 точек всего)
                for (let i = 0; i < 3; i++) {
                    const row = document.createElement('div');
                    row.className = 'drag-handle-row';
                    for (let j = 0; j < 2; j++) {
                        const dot = document.createElement('div');
                        dot.className = 'drag-handle-dot';
                        row.appendChild(dot);
                    }
                    dragHandle.appendChild(row);
                }
            }
            
            // Добавляем обработчик mousedown к handle для начала перетаскивания
            dragHandle.addEventListener('mousedown', function(e) {
                handleMouseDown.call(block, e);
            });
            
            block.appendChild(dragHandle);
            
            // Заголовок блока
            const title = document.createElement('div');
            title.className = 'stat-title';
            
            // Если игра в топе, делаем заголовок золотым
            if (leaderboardPlace) {
                title.style.color = '#e67e22';
            }
            
            // Маппинг иконок игр
            const gameIcons = {
                'ANN': 'Annihilation.png',
                'BB': 'BuildBattle.png',
                'BP': 'BlockParty.png',
                'BW': 'bedwars.png',
                'BWHYPE': 'BedWarsHype.png',
                'BWT': 'BedWars Turbo.png',
                'CP': 'ClashPoint.png',
                'DUELS': 'Duels.png',
                'GG': 'GunGame.png',
                'HG': 'HungerGames.png',
                'KPVP': 'kitpvp.png',
                'EGGWARS': 'EggWars.png',
                'MW': 'MobWars.png',
                'PRISON': 'Prison.png',
                'PRISON_LITE': 'prisonalphabeta.png',
                'SW': 'SkyWars.png',
                'ARC': 'arcade.png',
                'BRIDGE': 'TheBridge.png',
                'JUMPLEAGUE': 'JumpLeague.png',
                'MURDER': 'MurderMystery.png',
                'SPEEDBUILDERS': 'speedbuilders.png',
                'FALLGUYS': 'FallGuys.png',
                'BATTLEBOX': 'battlebox.png',
                'FARM': 'MyFarm.png',
                'FIREBALLFIGHT': 'firebollfight.png',
                'HIDE': 'hideandseek.png',
                'TNTTAG': 'tnttag.png',
                'TNTRUN': 'tntrun.png',
                'LUCKYWARS': 'LuckyWars.png',
                'DEATHRUN': 'money.png',
                'TURFWARS': 'turfwars.png'
            };
            
            // Добавляем иконку
            const icon = document.createElement('img');
            // Используем иконку игры, если есть, иначе 404.png
            icon.src = gameIcons[gameCode] ? `assets/images/icons/${gameIcons[gameCode]}` : 'assets/images/icons/404.png';
            icon.style.cssText = 'width: 40px; height: 40px; margin-right: 8px; vertical-align: middle; flex-shrink: 0;';
            icon.onerror = function() { 
                // Если иконка не загрузилась, пробуем загрузить 404.png
                if (this.src.indexOf('404.png') === -1) {
                    this.src = 'assets/images/icons/404.png';
                }
            };
            title.appendChild(icon);
            
            const titleText = document.createElement('span');
            titleText.textContent = gameData.name;
            title.appendChild(titleText);
            
            block.appendChild(title);

            // Контейнер для статистики
            const statsContainer = document.createElement('div');
            statsContainer.className = 'stat-values';

            // Выбираем набор статистик в зависимости от режима
            const statsToShow = gameData.seasonalStats || gameData.stats;

            // Добавляем статистику из конфига
            statsToShow.forEach(stat => {
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                
                let value = gameData.global[stat.key] || 0;
                
                // Форматируем большие числа для My Farm и Prison Lite
                if ((gameCode === 'FARM' && (stat.key === 'dollars' || stat.key === 'farm_cost')) ||
                    (gameCode === 'PRISON_LITE' && stat.key === 'earned_money')) {
                    value = formatLargeNumber(value);
                }
                
                statItem.innerHTML = `
                    <span class="stat-name">${stat.label}:</span>
                    <span class="stat-value">${value}</span>
                `;
                statsContainer.appendChild(statItem);
            });

            block.appendChild(statsContainer);

            // Добавляем кнопку разворачивания, если статистики больше 5 строк
            if (statsToShow.length > 5) {
                const expandButton = document.createElement('div');
                expandButton.className = 'expand-button';
                expandButton.onclick = function() {
                    block.classList.toggle('expanded');
                };
                block.appendChild(expandButton);
            }

            return block;
        }

        const GAMES_CONFIG = {
            'ANN': {
                name: 'Annihilation',
                stats: [
                    { label: 'Ударов по базе', key: 'nexus' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Убийств с лука', key: 'bowkills' },
                    { label: 'Добыто дуба', key: 'wood' },
                    { label: 'Добыто руды', key: 'ores' },
                    { label: 'Добыто земли', key: 'digged' }
                ],
                seasonalStats: [
                    { label: 'Ударов по базе', key: 'nexus' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Убийств с лука', key: 'bowkills' },
                    { label: 'Добыто дуба', key: 'wood' },
                    { label: 'Добыто руды', key: 'ores' },
                    { label: 'Добыто земли', key: 'digged' }
                ]
            },
            'BB': {
                name: 'BuildBattle',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                    ],
                seasonalStats: [
                { label: 'Игр', key: 'games' },
                { label: 'Побед', key: 'wins' }
                ]
            },
            'BP': {
                name: 'BlockParty',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Пройдено волн', key: 'rounds' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Пройдено волн', key: 'rounds' }
                ]
            },
            'BW': {
                name: 'BedWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' }
                ]
            },
            'BWHYPE': {
                name: 'BedWars Hype',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'BWT': {
                name: 'BedWars Turbo',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Заработано монет', key: 'spent_coins' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Заработано монет', key: 'spent_coins' }
                ]
            },
            'CP': {
                name: 'ClashPoint',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кристаллов', key: 'resourcePointsBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кристаллов', key: 'resourcePointsBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'DUELS': {
                name: 'Дуэли',
                stats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр в одиночку', key: 'solo_games' },
                    { label: 'Побед в одиночку', key: 'solo_wins' },
                    { label: 'Игр в команде', key: 'team_games' },
                    { label: 'Побед в команде', key: 'team_wins' },
                    { label: 'Рейтинговых игр', key: 'ranked_games' },
                    { label: 'Рейтинговых побед', key: 'ranked_wins' },
                    { label: 'Максимальная серия побед', key: 'maxstrike' },
                    { label: 'Побед "Classic"', key: 'wins_classic' },
                    { label: 'Побед "На луках"', key: 'wins_bow' },
                    { label: 'Побед "OP"', key: 'wins_op' },
                    { label: 'Побед "На зельях"', key: 'wins_potion' },
                    { label: 'Побед "UHC"', key: 'wins_uhc' },
                    { label: 'Побед "BWH"', key: 'wins_bwh' }
                ],
                seasonalStats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр в одиночку', key: 'solo_games' },
                    { label: 'Побед в одиночку', key: 'solo_wins' },
                    { label: 'Игр в команде', key: 'team_games' },
                    { label: 'Побед в команде', key: 'team_wins' },
                    { label: 'Рейтинговых игр', key: 'ranked_games' },
                    { label: 'Рейтинговых побед', key: 'ranked_wins' },
                    { label: 'Максимальная серия побед', key: 'maxstrike' },
                    { label: 'Побед "Classic"', key: 'wins_classic' },
                    { label: 'Побед "На луках"', key: 'wins_bow' },
                    { label: 'Побед "OP"', key: 'wins_op' },
                    { label: 'Побед "На зельях"', key: 'wins_potion' },
                    { label: 'Побед "UHC"', key: 'wins_uhc' },
                    { label: 'Побед "BWH"', key: 'wins_bwh' }
                ]
            },
            'GG': {
                name: 'GunGame',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Получено уровней', key: 'levels' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Получено уровней', key: 'levels' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'HG': {
                name: 'HungerGames',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'KPVP': {
                name: 'KitPvP',
                stats: [
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Очков', key: 'points' }
                    ],
                seasonalStats: [
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Очков', key: 'points' }
                ]
            },
            'EGGWARS': {
                name: 'EggWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено яиц', key: 'eggs' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено яиц', key: 'eggs' }
                ]
            },
            'MW': {
                name: 'MobWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'mobsKilled' },
                    { label: 'Отправлено мобов', key: 'mobsSended' },
                    { label: 'Максимальный доход', key: 'mobsSended' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'mobsKilled' },
                    { label: 'Отправлено мобов', key: 'mobsSended' },
                    { label: 'Максимальный доход', key: 'mobsSended' }
                ]
            },
            'PRISON': {
                name: 'Prison',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'PRISON_LITE': {
                name: 'Prison Lite | Alpha',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'SW': {
                name: 'SkyWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Потрачено стрел', key: 'arrowsFired' },
                    { label: 'Блоков сломано', key: 'blocksBroken' },
                    { label: 'Блоков размещено', key: 'blocksPlaced' },
                    { label: 'Текущая серия побед', key: 'currentWinStreak' },
                    { label: 'Максимальная серия побед', key: 'winStreak' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Потрачено стрел', key: 'arrowsFired' },
                    { label: 'Блоков сломано', key: 'blocksBroken' },
                    { label: 'Блоков размещено', key: 'blocksPlaced' },
                    { label: 'Текущая серия побед', key: 'currentWinStreak' },
                    { label: 'Максимальная серия побед', key: 'winStreak' }
                ]
            },
            'ARC': {
                name: 'Аркады',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'BRIDGE': {
                name: 'The Bridge',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'points' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'points' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'JUMPLEAGUE': {
                name: 'Jump League',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Чекпоинтов', key: 'checkpoints' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Чекпоинтов', key: 'checkpoints' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'MURDER': {
                name: 'Murder Mystery',
                stats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед за невинного ', key: 'wins_as_innocent' },
                    { label: 'Побед за маньяка', key: 'wins_as_maniac' },
                    { label: 'Побед за детектива', key: 'wins_as_detective' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед за невинного ', key: 'wins_as_innocent' },
                    { label: 'Побед за маньяка', key: 'wins_as_maniac' },
                    { label: 'Побед за детектива', key: 'wins_as_detective' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'SHEEP': {
                name: 'Sheep Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'TURFWARS': {
                name: 'Turf Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'TNTTAG': {
                name: 'TNT Tag',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'TNTRUN': {
                name: 'TNT Run',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано блоков', key: 'broken_blocks' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано блоков', key: 'broken_blocks' }
                ]
            },
            'LUCKYWARS': {
                name: 'Lucky Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано Лаки-Блоков', key: 'lucky_blocks' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано Лаки-Блоков', key: 'lucky_blocks' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'WHITECOLD': {
                name: 'Белый Холод',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'kills' },
                    { label: 'Собрано подарков', key: 'gifts' },
                    { label: 'Собрано сундуков', key: 'chests' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'kills' },
                    { label: 'Собрано подарков', key: 'gifts' },
                    { label: 'Собрано сундуков', key: 'chests' }
                ]
            },
            'HIDE': {
                name: 'Прятки',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Побед за охотника', key: 'wins_as_seeker' },
                    { label: 'Побед за прячущего', key: 'wins_as_hider' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Побед за охотника', key: 'wins_as_seeker' },
                    { label: 'Побед за прячущего', key: 'wins_as_hider' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'SPEEDBUILDERS': {
                name: 'Speed Builders',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                ]
            },
            'FALLGUYS': {
                name: 'Fall Guys',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                ]
            },
            'TEAMFORTRESS': {
                name: 'Team Fortess',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'EGGWARS': {
                name: 'Egg Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Помощей', key: 'assists' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Подобрано рун', key: 'runes' },
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Помощей', key: 'assists' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Подобрано рун', key: 'runes' },
                ]
            },
            'BATTLEBOX': {
                name: 'BattleBox',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'score' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'score' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'DEATHRUN': {
                name: 'DeathRun',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Максимальный рекорд', key: 'max_score' },
                    { label: 'Бонусов собрано', key: 'bonuses_collect' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Максимальный рекорд', key: 'max_score' },
                    { label: 'Бонусов собрано', key: 'bonuses_collect' }
                ]
            },
            'FARM': {
                name: 'MyLittleFarm',
                stats: [
                    { label: 'Денег', key: 'dollars' },
                    { label: 'Стоимость фермы', key: 'farm_cost' }
                    ],
                seasonalStats: [
                    { label: 'Денег', key: 'dollars' },
                    { label: 'Стоимость фермы', key: 'farm_cost' }
                ]
            },
            'FIREBALLFIGHT': {
                name: 'FireBall Fight',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'CSS': {
                name: 'Custom Steve Survival',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сыграно дуэлей', key: 'duel_games' },
                    { label: 'Побед в дуэлях', key: 'duel_wins' },
                    { label: 'Пройдено волн', key: 'passed_waves' },
                    { label: 'Максимальная волна', key: 'max_passed_waves_per_game' },
                    { label: 'Монет заработано', key: 'money_earned' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сыграно дуэлей', key: 'duel_games' },
                    { label: 'Побед в дуэлях', key: 'duel_wins' },
                    { label: 'Пройдено волн', key: 'passed_waves' },
                    { label: 'Максимальная волна', key: 'max_passed_waves_per_game' },
                    { label: 'Монет заработано', key: 'money_earned' }
                ]
            },
            'COR': {
                name: 'Chaos Of Reign',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Время в игре', key: 'played_time' },
                    { label: 'Монет заработано', key: 'money_earned' },
                    { label: 'Убийств', key: 'player_kills' },
                    { label: 'Сломано башен', key: 'towers_destroyed' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сфер подобрано', key: 'pickup_spheres' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Время в игре', key: 'played_time' },
                    { label: 'Монет заработано', key: 'money_earned' },
                    { label: 'Убийств', key: 'player_kills' },
                    { label: 'Сломано башен', key: 'towers_destroyed' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сфер подобрано', key: 'pickup_spheres' }
                ]
            },
        };

        // Добавляем функции для работы с кешем
        function savePlayerData(nick, data) {
            const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
            playerCache[nick] = {
                ...data,
                timestamp: Date.now()
            };
            localStorage.setItem('playerCache', JSON.stringify(playerCache));
        }

        function getPlayerData(nick) {
            const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
            return playerCache[nick];
        }

        // Функция для сохранения никнейма в localStorage
        function saveNick(nick) {
            // Получаем оригинальный никнейм из API
            fetch(`https://api.vimeworld.com/user/name/${nick}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const originalUsername = data[0].username;
                        let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                        nicks = nicks.filter(n => n !== originalUsername);
                        nicks.unshift(originalUsername);
                        nicks = nicks.slice(0, 5); // Максимум 5 никнеймов
                        localStorage.setItem('recentNicks', JSON.stringify(nicks));
                    }
                })
                .catch(error => {
                    console.error('Ошибка при получении оригинального никнейма:', error);
                    // Если не удалось получить оригинальный никнейм, сохраняем введенный
                    let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                    nicks = nicks.filter(n => n !== nick);
                    nicks.unshift(nick);
                    nicks = nicks.slice(0, 5);
                    localStorage.setItem('recentNicks', JSON.stringify(nicks));
                });
        }

        // Обработчик отправки формы поиска
        document.addEventListener('DOMContentLoaded', function() {
            // Находим элементы поиска и добавляем обработчики
            const quickSearchInput = document.getElementById('quick-search');
            const quickSearchBtn = document.getElementById('quick-search-btn');
            
            if (quickSearchBtn && quickSearchInput) {
                // Обработчик клика по кнопке поиска
                quickSearchBtn.addEventListener('click', function() {
                    const username = quickSearchInput.value.trim();
                    if (!username) return;
                    
                    getOriginalNameAndRedirect(username);
                });
                
                // Обработчик нажатия Enter в поле поиска
                quickSearchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        const username = quickSearchInput.value.trim();
                        if (username) {
                            getOriginalNameAndRedirect(username);
                        }
                    }
                });
            }
        });

        // Функция для отображения тултипа с историей ников
        async function showNickHistoryTooltip(playerId, buttonElement) {
            // Проверяем, что playerId передан
            if (!playerId) {
                console.error('Player ID не передан');
                return;
            }
            // Удаляем существующий тултип, если он есть
            const existingTooltip = document.getElementById('nick-history-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
                return;
            }
            
            // Создаем контейнер для тултипа
            const tooltip = document.createElement('div');
            tooltip.id = 'nick-history-tooltip';
            tooltip.style.cssText = `
                position: fixed;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
                padding: 20px;
                padding-top: 40px;
                min-width: 300px;
                max-width: 400px;
                max-height: 500px;
                overflow-y: auto;
                z-index: 10000;
                font-family: 'VimeArtBold', sans-serif;
                cursor: default;
            `;
            
            // Создаем заголовок для перетаскивания
            const dragHeader = document.createElement('div');
            dragHeader.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 40px;
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                border-radius: 12px 12px 0 0;
                cursor: move;
                display: flex;
                align-items: center;
                padding: 0 12px;
                color: white;
                font-weight: bold;
                font-size: 0.9rem;
                user-select: none;
            `;
            dragHeader.textContent = 'История ников';
            tooltip.appendChild(dragHeader);
            
            // Создаем кнопку закрытия
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '×';
            closeButton.style.cssText = `
                position: absolute;
                top: 3px;
                right: 8px;
                width: 28px;
                height: 28px;
                border: none;
                background: transparent;
                color: white;
                font-size: 24px;
                line-height: 24px;
                border-radius: 6px;
                cursor: pointer;
                transition: transform 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                z-index: 10001;
            `;
            closeButton.onmouseover = function() {
                this.style.transform = 'scale(1.15)';
            };
            closeButton.onmouseout = function() {
                this.style.transform = 'scale(1)';
            };
            closeButton.onclick = function(e) {
                e.stopPropagation();
                tooltip.remove();
            };
            dragHeader.appendChild(closeButton);
            
            // Переменные для перетаскивания
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            
            // Обработчики перетаскивания
            dragHeader.addEventListener('mousedown', function(e) {
                if (e.target === closeButton || closeButton.contains(e.target)) {
                    return;
                }
                
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                isDragging = true;
                dragHeader.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    tooltip.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    dragHeader.style.cursor = 'move';
                }
            });
            
            // Позиционируем тултип по центру экрана
            const tooltipWidth = 350;
            const tooltipHeight = 400;
            
            let left = (window.innerWidth - tooltipWidth) / 2;
            let top = (window.innerHeight - tooltipHeight) / 2;
            
            // Убеждаемся, что окно не выходит за границы экрана
            if (left < 10) left = 10;
            if (top < 10) top = 10;
            
            tooltip.style.top = top + 'px';
            tooltip.style.left = left + 'px';
            
            // Добавляем индикатор загрузки
            const loadingDiv = document.createElement('div');
            loadingDiv.textContent = 'Загрузка...';
            loadingDiv.style.cssText = 'text-align: center; padding: 20px; color: #7f8c8d;';
            tooltip.appendChild(loadingDiv);
            
            document.body.appendChild(tooltip);
            
            try {
                // Загружаем историю ников по ID через vimetop.ru API
                // Используем CORS proxy для обхода ограничений CORS
                const targetUrl = `https://vimetop.ru/api/v1/player/${playerId}/history/usernames`;
                // Пробуем несколько CORS proxy сервисов
                const corsProxies = [
                    `https://api.allorigins.win/get?url=${encodeURIComponent(targetUrl)}`,
                    `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
                    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(targetUrl)}`
                ];
                
                console.log('Запрос истории ников для ID:', playerId);
                console.log('Целевой URL:', targetUrl);
                
                // Функция для fetch с таймаутом
                const fetchWithTimeout = (url, timeout = 3000) => {
                    return Promise.race([
                        fetch(url),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Таймаут запроса')), timeout)
                        )
                    ]);
                };
                
                let historyResponse;
                let historyData;
                let lastError;
                
                // Пробуем каждый прокси по очереди с таймаутом 3 секунды
                for (let i = 0; i < corsProxies.length; i++) {
                    try {
                        console.log(`Пробуем прокси ${i + 1}:`, corsProxies[i]);
                        historyResponse = await fetchWithTimeout(corsProxies[i], 3000);
                        
                        if (historyResponse.ok) {
                            const proxyData = await historyResponse.json();
                            historyData = proxyData['response']['data']['history']
                            
                            console.log('Успешно получены данные через прокси', i + 1);
                            break;
                        }
                    } catch (error) {
                        console.log(`Прокси ${i + 1} не сработал:`, error.message);
                        lastError = error;
                        continue;
                    }
                }
                
                // Если все прокси не сработали, пробуем прямой запрос
                if (!historyData) {
                    console.log('Пробуем прямой запрос...');
                    try {
                        historyResponse = await fetch(targetUrl, {
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        if (!historyResponse.ok) {
                            throw new Error(`HTTP ${historyResponse.status}: ${historyResponse.statusText}`);
                        }
                        
                        historyData = await historyResponse.json();
                    } catch (directError) {
                        console.error('Прямой запрос также не сработал:', directError);
                        throw new Error('Не удалось загрузить историю ников. Возможно, требуется использовать VPN или расширение для обхода CORS.');
                    }
                }
                
                console.log('Статус ответа:', historyResponse.status, historyResponse.statusText);
                
                if (!historyResponse.ok) {
                    // Пробуем получить текст ошибки
                    let errorText = 'Не удалось загрузить историю ников';
                    try {
                        const errorData = await historyResponse.json();
                        console.log('Данные ошибки:', errorData);
                        if (errorData && errorData.error) {
                            errorText = errorData.error;
                        } else if (errorData && errorData.message) {
                            errorText = errorData.message;
                        }
                    } catch (e) {
                        const responseText = await historyResponse.text();
                        console.log('Текст ответа:', responseText);
                        errorText = `Ошибка ${historyResponse.status}: ${historyResponse.statusText}`;
                    }
                    throw new Error(errorText);
                }
                
                console.log('Полученные данные истории:', historyData);
                
                // Удаляем индикатор загрузки
                loadingDiv.remove();
                
                // Проверяем, что данные в правильном формате
                if (!historyData) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'История ников пуста';
                    emptyMessage.style.cssText = 'text-align: center; padding: 40px; color: #7f8c8d;';
                    tooltip.appendChild(emptyMessage);
                    return;
                }
                
                // Обрабатываем разные форматы ответа от API
                let actualHistoryData = historyData;
                
                // Если это массив - используем его напрямую
                if (Array.isArray(historyData)) {
                    actualHistoryData = historyData;
                }
                // Если это объект, ищем массив в разных полях
                else if (typeof historyData === 'object') {
                    if (historyData.data && Array.isArray(historyData.data)) {
                        actualHistoryData = historyData.data;
                    } else if (historyData.names && Array.isArray(historyData.names)) {
                        actualHistoryData = historyData.names;
                    } else if (historyData.history && Array.isArray(historyData.history)) {
                        actualHistoryData = historyData.history;
                    } else if (historyData.usernames && Array.isArray(historyData.usernames)) {
                        actualHistoryData = historyData.usernames;
                    }
                }
                
                // Проверяем, что у нас есть массив данных
                if (!Array.isArray(actualHistoryData) || actualHistoryData.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'История ников пуста';
                    emptyMessage.style.cssText = 'text-align: center; padding: 40px; color: #7f8c8d;';
                    tooltip.appendChild(emptyMessage);
                    return;
                }
                
                // Создаем список истории ников
                const historyList = document.createElement('div');
                historyList.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
                
                // Сортируем по дате (от новых к старым)
                // Поддерживаем разные форматы полей даты
                const sortedHistory = actualHistoryData.sort((a, b) => {
                    const dateA = a.changedToAt ? new Date(a.changedToAt) : 
                                  (a.changed_at ? new Date(a.changed_at) : 
                                  (a.date ? new Date(a.date) : 
                                  (a.timestamp ? new Date(a.timestamp) : 
                                  (a.changedAt ? new Date(a.changedAt) : new Date(0)))));
                    const dateB = b.changedToAt ? new Date(b.changedToAt) : 
                                  (b.changed_at ? new Date(b.changed_at) : 
                                  (b.date ? new Date(b.date) : 
                                  (b.timestamp ? new Date(b.timestamp) : 
                                  (b.changedAt ? new Date(b.changedAt) : new Date(0)))));
                    return dateB - dateA;
                });
                
                sortedHistory.forEach((item) => {
                    const historyItem = document.createElement('div');
                    historyItem.style.cssText = `
                        background: #f8fbff;
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        transition: background 0.2s ease;
                    `;
                    
                    historyItem.onmouseover = function() {
                        this.style.background = '#e6f3ff';
                    };
                    
                    historyItem.onmouseout = function() {
                        this.style.background = '#f8fbff';
                    };
                    
                    // Создаем контейнер для имен
                    const namesContainer = document.createElement('div');
                    namesContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        flex-wrap: wrap;
                    `;
                    
                    // Если есть old_name и new_name, показываем оба
                    if (item.old_name && item.new_name) {
                        const oldNameSpan = document.createElement('span');
                        oldNameSpan.style.cssText = `
                            font-size: 1rem;
                            color: #7f8c8d;
                            font-weight: 500;
                            text-decoration: line-through;
                        `;
                        oldNameSpan.textContent = item.old_name;
                        namesContainer.appendChild(oldNameSpan);
                        
                        const arrow = document.createElement('span');
                        arrow.textContent = '→';
                        arrow.style.cssText = `
                            font-size: 1rem;
                            color: #3498db;
                            font-weight: bold;
                        `;
                        namesContainer.appendChild(arrow);
                        
                        const newNameSpan = document.createElement('span');
                        newNameSpan.style.cssText = `
                            font-size: 1rem;
                            color: #2c3e50;
                            font-weight: 500;
                        `;
                        newNameSpan.textContent = item.new_name;
                        namesContainer.appendChild(newNameSpan);
                    } else {
                        // Используем старый формат для обратной совместимости
                        const nickName = document.createElement('span');
                        nickName.style.cssText = `
                            font-size: 1rem;
                            color: #2c3e50;
                            font-weight: 500;
                        `;
                        nickName.textContent = item.username || item.name || item.nickname || item.value || item.new_name || item.old_name || String(item) || 'Неизвестно';
                        namesContainer.appendChild(nickName);
                    }
                    
                    historyItem.appendChild(namesContainer);
                    
                    const dateInfo = document.createElement('div');
                    dateInfo.style.cssText = `
                        font-size: 0.8rem;
                        color: #7f8c8d;
                        text-align: left;
                    `;
                    
                    // Поддерживаем разные форматы полей даты
                    const changeDate = item.created_at;
                    if (changeDate) {
                        const date = new Date(changeDate);
                        if (!isNaN(date.getTime())) {
                            const now = new Date();
                            const diffMs = now - date;
                            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                            
                            if (diffDays === 0) {
                                dateInfo.textContent = 'Сегодня';
                            } else if (diffDays === 1) {
                                dateInfo.textContent = 'Вчера';
                            } else if (diffDays < 30) {
                                dateInfo.textContent = `${diffDays} дн. назад`;
                            } else {
                                dateInfo.textContent = date.toLocaleDateString('ru-RU', {
                                    year: 'numeric',
                                    month: 'short',
                                    day: 'numeric'
                                });
                            }
                        } else {
                            dateInfo.textContent = 'Дата неизвестна';
                        }
                    } else {
                        dateInfo.textContent = 'Дата неизвестна';
                    }
                    
                    historyItem.appendChild(dateInfo);
                    historyList.appendChild(historyItem);
                });
                
                tooltip.appendChild(historyList);
                
            } catch (error) {
                console.error('Ошибка при загрузке истории ников:', error);
                console.error('Player ID:', playerId);
                
                // Удаляем индикатор загрузки
                loadingDiv.remove();
                
                // Показываем сообщение об ошибке
                const errorMessage = document.createElement('div');
                errorMessage.textContent = error.message || 'Не удалось загрузить историю ников';
                errorMessage.style.cssText = 'text-align: center; padding: 40px; color: #e74c3c;';
                tooltip.appendChild(errorMessage);
            }
            
            // Закрытие тултипа при клике вне его
            const closeTooltipHandler = function(e) {
                if (!tooltip.contains(e.target) && e.target !== buttonElement && !buttonElement.contains(e.target)) {
                    tooltip.remove();
                    document.removeEventListener('click', closeTooltipHandler);
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            
            // Закрытие при нажатии Escape
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    tooltip.remove();
                    document.removeEventListener('keydown', escapeHandler);
                    document.removeEventListener('click', closeTooltipHandler);
                }
            };
            
            // Добавляем обработчики с небольшой задержкой, чтобы не закрыть сразу после открытия
            setTimeout(() => {
                document.addEventListener('click', closeTooltipHandler);
                document.addEventListener('keydown', escapeHandler);
            }, 100);
        }

        // Функция для загрузки списка друзей без статусов (быстрая загрузка)
async function loadFriendsBasicInfo(username) {
    try {
        const response = await fetch(`https://api.vimeworld.com/user/name/${username}/friends`);
        
        if (!response.ok) {
            throw new Error('Не удалось загрузить список друзей');
        }
        
        const data = await response.json();
        
        // Проверяем, есть ли массив друзей в ответе
        if (!data.friends || !Array.isArray(data.friends)) {
            console.error('Неверный формат данных:', data);
            return;
        }
        
        // Сохраняем список друзей в глобальную переменную
        window.friendsData = data.friends.map(friend => ({
            ...friend,
            online: false,
            friendStatus: null
        }));
        
        // Обновляем счетчик друзей на странице
        const friendsCount =  data.friends.length;
        document.getElementById('player-friends').textContent = friendsCount;
        
        return data.friends;
    } catch (error) {
        console.error('Ошибка при загрузке списка друзей:', error);
        return [];
    }
}

// Функция для полной загрузки друзей со статусами (вызывается при открытии вкладки)
async function loadFriendsList(username) {
    const friendsLoading = document.getElementById('friends-loading');
    const friendsError = document.getElementById('friends-error');
    const friendsList = document.getElementById('friends-list');
    const friendsSortContainer = document.getElementById('friends-sort-container');
    
    // Показываем загрузку, скрываем ошибку и список
    friendsLoading.style.display = 'block';
    friendsError.style.display = 'none';
    friendsList.style.display = 'none';
    friendsSortContainer.style.display = 'none';
    
    // Устанавливаем стиль сетки для списка друзей заранее
    friendsList.style.gridTemplateColumns = 'repeat(3, 1fr)';
    friendsList.style.gap = '20px';
    
    try {
        let friends = window.friendsData;
        
        // Если данные ещё не загружены, загружаем их
        if (!friends || !friends.length) {
            const response = await fetch(`https://api.vimeworld.com/user/name/${username}/friends`);
            
            if (!response.ok) {
                throw new Error('Не удалось загрузить список друзей');
            }
            
            const data = await response.json();
            
            // Проверяем, есть ли массив друзей в ответе
            if (!data.friends || !Array.isArray(data.friends)) {
                console.error('Неверный формат данных:', data);
                throw new Error('Неверный формат данных от API');
            }
            
            friends = data.friends;
            
            // Сохраняем список друзей без статусов
            window.friendsData = friends.map(friend => ({
                ...friend,
                online: false,
                friendStatus: null
            }));
        }
        
        // Обновляем счетчик друзей на странице
        const friendsCount = friends.length;
        document.getElementById('player-friends').textContent = friendsCount;
        
        // Проверяем, есть ли друзья
        if (friends.length === 0) {
            friendsList.innerHTML = '<div class="text-center w-100 py-5" style="color: #7f8c8d; font-family: \'VimeArtBold\', sans-serif; font-size: 1.1rem;">Кажется, никто не хочет с ним дружить</div>';
            friendsLoading.style.display = 'none';
            friendsSortContainer.style.display = 'none';
            friendsList.style.display = 'flex'; // Используем flex для центрирования сообщения
            friendsList.style.justifyContent = 'center';
            friendsList.style.alignItems = 'center';
            return;
        }
        
        // Загружаем статусы и отображаем список
        await loadFriendsStatuses(friends);
        
    } catch (error) {
        console.error('Ошибка при загрузке списка друзей:', error);
        
        // Показываем ошибку, скрываем загрузку и список
        friendsLoading.style.display = 'none';
        friendsError.style.display = 'block';
        friendsSortContainer.style.display = 'none';
        friendsList.style.display = 'none';
    }
}

// Функция для загрузки статусов друзей
async function loadFriendsStatuses(friends) {
    const friendsLoading = document.getElementById('friends-loading');
    const friendsList = document.getElementById('friends-list');
    
    try {
        // Подготавливаем массив никнеймов для получения онлайн-статусов
        const friendUsernames = friends.map(friend => friend.username);
        
        // Получаем онлайн-статусы для всех друзей
        const onlineStatuses = {};
        
        // Для каждого друга создаем отдельный запрос в цикле
        const statusPromises = friendUsernames.map(async (username) => {
            try {
                // Индивидуальный запрос для каждого друга
                const response = await fetch(`https://api.vimeworld.com/user/name/${username}/session`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${username}`);
                }
                
                const sessionData = await response.json();
                
                // Сохраняем данные о статусе в общий объект
                onlineStatuses[username.toLowerCase()] = sessionData.online;
            } catch (error) {
                console.error(`Ошибка при получении статуса для ${username}:`, error);
                // При ошибке для этого друга статус останется undefined
            }
        });
        
        // Ждем завершения всех запросов
        await Promise.all(statusPromises);
        
        // Обновляем friendsData с полученными статусами
        window.friendsData = friends.map(friend => {
            const friendStatus = onlineStatuses[friend.username.toLowerCase()];
            const isOnline = friendStatus && friendStatus.value;
            return {
                ...friend,
                online: isOnline,
                friendStatus: friendStatus
            };
        });
        
        // Добавляем обработчик изменения сортировки
        const sortSelect = document.getElementById('friends-sort');
        sortSelect.addEventListener('change', function() {
            renderFriendsList(window.friendsData, onlineStatuses, this.value);
        });
        
        // Отрисовываем список с сортировкой по умолчанию
        renderFriendsList(window.friendsData, onlineStatuses, sortSelect.value);
        
        // Показываем список, контейнер сортировки и скрываем индикатор загрузки
        friendsLoading.style.display = 'none';
        friendsList.style.display = 'grid';
        document.getElementById('friends-sort-container').style.display = 'block';
    } catch (error) {
        console.error('Ошибка при загрузке статусов друзей:', error);
        friendsLoading.style.display = 'none';
    }
}



// Функция для отрисовки списка друзей с указанной сортировкой
function renderFriendsList(friends, onlineStatuses, sortType = 'online') {
    const friendsList = document.getElementById('friends-list');
    friendsList.innerHTML = '';
    
    // Копируем массив друзей для сортировки
    const sortedFriends = [...friends];
    
    // Сортируем друзей в зависимости от выбранного типа сортировки
    switch (sortType) {
        case 'online':
            // Сначала онлайн, потом по времени последнего входа
            sortedFriends.sort((a, b) => {
                if (a.online && !b.online) return -1;
                if (!a.online && b.online) return 1;
                return b.lastSeen - a.lastSeen; // По убыванию времени последнего входа
            });
            break;
        case 'last_seen':
            // По времени последнего входа
            sortedFriends.sort((a, b) => b.lastSeen - a.lastSeen);
            break;
        case 'rank':
            // По значимости ранга
            const rankOrder = {
                "ADMIN": 1, "CHIEF": 2, "WARDEN": 3, "MODER": 4, "HELPER": 5, "ORGANIZER": 6, 
                "DEV": 7, "YOUTUBE": 8, "MAPLEAD": 9, "SRBUILDER": 10, "BUILDER": 11, "JRBUILDER": 12, 
                "VIME": 13, "ULTIMATE": 14, "IMPERIUM": 15, "IMPERIAL": 15, "ABSOLUTE": 16, "CELESTIAL": 17, 
                "ETERNAL": 18, "ELITE": 19, "THANE": 20, "DIVINE": 21, "IMMORTAL": 22, 
                "HOLY": 23, "PREMIUM": 24, "VIP": 25, "PLAYER": 26
            };
            
            sortedFriends.sort((a, b) => {
                const rankA = a.rank || "PLAYER";
                const rankB = b.rank || "PLAYER";
                return (rankOrder[rankA] || 999) - (rankOrder[rankB] || 999);
            });
            break;
        case 'name':
            // По имени в алфавитном порядке
            sortedFriends.sort((a, b) => a.username.localeCompare(b.username));
            break;
    }
    
    // Отрисовываем отсортированный список
    sortedFriends.forEach((friend, index) => {
        const friendElement = createFriendElement(friend, onlineStatuses);
        // Сбрасываем анимацию и добавляем задержку
        friendElement.style.animation = 'none';
        friendElement.style.opacity = '0';
        friendElement.style.transform = 'translateY(10px)';
        
        // Применяем анимацию с задержкой
        setTimeout(() => {
            friendElement.style.animation = `fadeInFriend 0.4s ease-out ${index * 0.05}s forwards`;
        }, 10);
        
        friendsList.appendChild(friendElement);
    });
    
    // Устанавливаем стиль сетки для списка друзей
    friendsList.style.display = 'grid';
    friendsList.style.gridTemplateColumns = 'repeat(3, 1fr)';
    friendsList.style.gap = '20px';
}

// Функция для создания элемента друга
function createFriendElement(friend, onlineStatuses) {
    // Создаем элемент для друга
    const friendElement = document.createElement('div');
    friendElement.className = 'friend-card';
    
    // Формируем уровень с процентами
    const levelProgress = friend.levelPercentage * 100;
    
    // Определяем цвет ранга (первый ранг из списка рангов)
    let rankColor = '#7f8c8d'; // Цвет по умолчанию
    let rankName = 'Игрок';
    
    const friendRank = friend.rank || "PLAYER";
    if (ranksData[friendRank]) {
        rankName = ranksData[friendRank].name;
        
        // Берем первый цвет из массива цветов ранга
        if (ranksData[friendRank].colors && ranksData[friendRank].colors.length > 0) {
            rankColor = `#${ranksData[friendRank].colors[0]}`;
        }
    }
    
    // Проверяем онлайн-статус из полученных данных
    const friendStatus = onlineStatuses[friend.username.toLowerCase()];
    // Если статус не определен (undefined) из-за ошибки, это будет обработано ниже
    const isOnline = friendStatus && friendStatus.value;
    
    // Создаем контейнер для головы 3D
    const avatarContainer = document.createElement('div');
    avatarContainer.className = 'friend-avatar';
    avatarContainer.style.background = 'transparent';
    avatarContainer.style.width = '64px';
    avatarContainer.style.height = '64px';
    avatarContainer.style.display = 'flex';
    avatarContainer.style.justifyContent = 'center';
    avatarContainer.style.alignItems = 'center';
    
    // Добавляем 3D голову
    const headImg = document.createElement('img');
    headImg.src = `https://skin.vimeworld.com/helm/3d/${friend.username}.png`;
    headImg.alt = `${friend.username}`;
    headImg.className = 'friend-avatar-img';
    headImg.style.fontFamily = 'VimeArtBold, sans-serif';
    headImg.style.background = 'transparent';
    headImg.style.imageRendering = 'pixelated';
    headImg.style.width = '64px';
    headImg.style.height = '64px';
    avatarContainer.appendChild(headImg);
    
    // Формируем HTML-содержимое для карточки друга
    const friendContent = document.createElement('div');
    friendContent.className = 'friend-card-content';
    
    // Добавляем аватар
    friendContent.appendChild(avatarContainer);
    
    // Создаем блок с информацией
    const infoDiv = document.createElement('div');
    infoDiv.className = 'friend-info';
    
    // 1. Создаем элемент с именем и рангом
    const nameDiv = document.createElement('div');
    nameDiv.className = 'friend-name';
    nameDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    
    // Создаем ранг только если это не PLAYER (не обычный игрок)
    let rankSpan;
    const rankInfo = ranksData[friendRank] || ranksData["PLAYER"];
    
    if (friendRank !== "PLAYER") {
        rankSpan = document.createElement('span');
        rankSpan.className = 'friend-rank';
        rankSpan.textContent = rankName;
        rankSpan.style.marginLeft = '3px';
        rankSpan.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Применяем градиент для рангов с несколькими цветами
        if (rankInfo.colors && rankInfo.colors.length > 0) {
            if (rankInfo.colors.length === 1) {
                // Один цвет
                rankSpan.style.background = `#${rankInfo.colors[0]}`;
                rankSpan.style.color = '#fff'; // Белый текст на цветном фоне
            } else {
                // Градиент для нескольких цветов
                const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                rankSpan.style.background = gradient;
                rankSpan.style.color = '#fff'; // Белый текст на градиентном фоне
            }
        }
    }
    
    // Создаем ссылку для имени
    const nameLink = document.createElement('a');
    nameLink.href = `player.html?username=${friend.username}`;
    nameLink.textContent = friend.username;
    nameLink.style.textDecoration = 'none';
    nameLink.style.cursor = 'pointer';
    
    // Применяем custom colors к имени игрока, если они есть
    if (friend.customColors && friend.customColors.length > 0) {
        if (friend.customColors.length === 1) {
            nameLink.style.color = `#${friend.customColors[0]}`;
        } else {
            const gradient = `linear-gradient(to right, ${friend.customColors.map(color => `#${color}`).join(', ')})`;
            nameLink.style.background = gradient;
            nameLink.style.webkitBackgroundClip = 'text';
            nameLink.style.webkitTextFillColor = 'transparent';
        }
    } else {
        nameLink.style.color = 'inherit';
    }
    
    nameDiv.appendChild(nameLink);
    
    // Добавляем Prime иконку, если есть
    if (friend.prime && friend.primeIcon) {
        const primeIconSpan = document.createElement('span');
        primeIconSpan.style.marginLeft = '3px';
        primeIconSpan.style.fontSize = '0.75rem';
        
        // Преобразуем Minecraft-формат (&c\u273e) в HTML
        let primeIcon = friend.primeIcon;
        
        // Заменяем &c, &4, &f и т.д. на соответствующие цвета
        const colorMap = {
            '&0': '#000000', // Черный
            '&1': '#0000AA', // Темно-синий
            '&2': '#00AA00', // Темно-зеленый
            '&3': '#00AAAA', // Темно-бирюзовый
            '&4': '#AA0000', // Темно-красный
            '&5': '#AA00AA', // Темно-пурпурный
            '&6': '#FFAA00', // Золотой
            '&7': '#AAAAAA', // Серый
            '&8': '#555555', // Темно-серый
            '&9': '#5555FF', // Синий
            '&a': '#55FF55', // Зеленый
            '&b': '#55FFFF', // Бирюзовый
            '&c': '#FF5555', // Красный
            '&d': '#FF55FF', // Пурпурный
            '&e': '#FFFF55', // Желтый
            '&f': '#FFFFFF'  // Белый
        };
        
        // Извлекаем код форматирования и символ
        const formatMatch = primeIcon.match(/^&([0-9a-fklmnor])(.+)$/);
        if (formatMatch) {
            const formatCode = '&' + formatMatch[1];
            const symbol = formatMatch[2];
            
            // Проверяем, это цветовой код или форматирующий
            if (colorMap[formatCode]) {
                // Цветовой код
                const color = colorMap[formatCode];
                primeIconSpan.style.color = color;
                // Добавляем тень для белого цвета (&f)
                if (formatCode === '&f') {
                    primeIconSpan.style.textShadow = '0px 0px 2px rgba(0,0,0,0.3)';
                }
                primeIconSpan.textContent = symbol;
            } else {
                // Форматирующий код (&k, &l, &m, &n, &o, &r)
                primeIconSpan.textContent = symbol;
                
                // Применяем соответствующее форматирование
                switch (formatCode) {
                    case '&k': // Случайные символы (обфускация)
                        // Для &k просто отображаем символ как есть
                        // В браузере сложно реализовать анимацию случайных символов
                        break;
                    case '&l': // Жирный
                        primeIconSpan.style.fontWeight = 'bold';
                        break;
                    case '&m': // Зачеркнутый
                        primeIconSpan.style.textDecoration = 'line-through';
                        break;
                    case '&n': // Подчеркнутый
                        primeIconSpan.style.textDecoration = 'underline';
                        break;
                    case '&o': // Курсив
                        primeIconSpan.style.fontStyle = 'italic';
                        break;
                    case '&r': // Сброс форматирования
                        // Просто отображаем символ без дополнительного форматирования
                        break;
                }
            }
        } else {
            // Если формат не соответствует ожидаемому
            primeIconSpan.textContent = 'Prime';
            primeIconSpan.className = 'friend-prime';
        }
        
        nameDiv.appendChild(primeIconSpan);
    }
    
    // Добавляем ранг после прайм-иконки (только если не PLAYER)
    if (friendRank !== "PLAYER" && rankSpan) {
        nameDiv.appendChild(rankSpan);
    }
    
    infoDiv.appendChild(nameDiv);
    
    // 2. Добавляем гильдию, если есть
    if (friend.guild) {
        const guildDiv = document.createElement('div');
        guildDiv.className = 'friend-guild';
        guildDiv.style.marginTop = '2px';
        guildDiv.style.marginBottom = '2px';
        guildDiv.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Добавляем тег гильдии только если он есть
        if (friend.guild.tag && friend.guild.tag.trim() !== '') {
            // Создаем контейнер для тега гильдии
            const guildTagContainer = document.createElement('span');
            guildTagContainer.style.fontFamily = 'VimeArtBold, sans-serif';
            
            // Добавляем открывающую скобку серого цвета (&7)
            const openBracket = document.createElement('span');
            openBracket.style.color = '#AAAAAA'; // Цвет &7
            openBracket.textContent = '<';
            guildTagContainer.appendChild(openBracket);
            
            // Сам тег гильдии с цветом из API
            const guildTagSpan = document.createElement('span');
            guildTagSpan.className = 'friend-guild-tag';
            // Преобразуем код цвета Minecraft в CSS
            let tagColor = '#7f8c8d'; // Цвет по умолчанию
            if (friend.guild.color && friend.guild.color.startsWith('&')) {
                const colorCode = friend.guild.color;
                const colorMap = {
                    '&0': '#000000', // Черный
                    '&1': '#0000AA', // Темно-синий
                    '&2': '#00AA00', // Темно-зеленый
                    '&3': '#00AAAA', // Темно-бирюзовый
                    '&4': '#AA0000', // Темно-красный
                    '&5': '#AA00AA', // Темно-пурпурный
                    '&6': '#FFAA00', // Золотой
                    '&7': '#AAAAAA', // Серый
                    '&8': '#555555', // Темно-серый
                    '&9': '#5555FF', // Синий
                    '&a': '#55FF55', // Зеленый
                    '&b': '#55FFFF', // Бирюзовый
                    '&c': '#FF5555', // Красный
                    '&d': '#FF55FF', // Пурпурный
                    '&e': '#FFFF55', // Желтый
                    '&f': '#FFFFFF'  // Белый
                };
                if (colorMap[colorCode]) {
                    tagColor = colorMap[colorCode];
                    // Добавляем тень для белого цвета (&f)
                    if (colorCode === '&f') {
                        guildTagSpan.style.textShadow = '0px 0px 2px rgba(0,0,0,0.3)';
                    }
                }
            }
            guildTagSpan.style.color = tagColor;
            guildTagSpan.style.fontFamily = 'VimeArtBold, sans-serif';
            guildTagSpan.textContent = friend.guild.tag;
            guildTagContainer.appendChild(guildTagSpan);
            
            // Добавляем закрывающую скобку серого цвета (&7)
            const closeBracket = document.createElement('span');
            closeBracket.style.color = '#AAAAAA'; // Цвет &7
            closeBracket.textContent = '>';
            guildTagContainer.appendChild(closeBracket);
            guildDiv.appendChild(guildTagContainer);
        }
        
        // Обрабатываем название гильдии с учетом форматирования Minecraft
        const guildNameSpan = document.createElement('span');
        guildNameSpan.style.marginLeft = '4px';
        guildNameSpan.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Преобразуем Minecraft форматирование в HTML
        let guildName = friend.guild.name;
        let formattedName = '';
        let currentColor = '';
        let isBold = false;
        let isItalic = false;
        
        const colorMap = {
            '&0': '#000000', // Черный
            '&1': '#0000AA', // Темно-синий
            '&2': '#00AA00', // Темно-зеленый
            '&3': '#00AAAA', // Темно-бирюзовый
            '&4': '#AA0000', // Темно-красный
            '&5': '#AA00AA', // Темно-пурпурный
            '&6': '#FFAA00', // Золотой
            '&7': '#AAAAAA', // Серый
            '&8': '#555555', // Темно-серый
            '&9': '#5555FF', // Синий
            '&a': '#55FF55', // Зеленый
            '&b': '#55FFFF', // Бирюзовый
            '&c': '#FF5555', // Красный
            '&d': '#FF55FF', // Пурпурный
            '&e': '#FFFF55', // Желтый
            '&f': '#FFFFFF'  // Белый
        };
        
        if (guildName.includes('&')) {
            for (let i = 0; i < guildName.length; i++) {
                if (guildName[i] === '&' && i + 1 < guildName.length) {
                    const code = guildName[i] + guildName[i + 1];
                    
                    if (code === '&l') {
                        isBold = true;
                        i++;
                    } else if (code === '&o') {
                        isItalic = true;
                        i++;
                    } else if (code === '&r') {
                        currentColor = '';
                        isBold = false;
                        isItalic = false;
                        i++;
                    } else if (colorMap[code]) {
                        currentColor = colorMap[code];
                        // Добавляем стиль тени для белого цвета
                        if (code === '&f') {
                            formattedName += '<span style="text-shadow: 0px 0px 2px rgba(0,0,0,0.3);">';
                        }
                        i++;
                    } else {
                        formattedName += guildName[i];
                    }
                } else {
                    formattedName += guildName[i];
                }
            }
            
            guildNameSpan.innerHTML = formattedName;
            if (currentColor) {
                guildNameSpan.style.color = currentColor;
            }
            if (isBold) {
                guildNameSpan.style.fontWeight = 'bold';
            }
            if (isItalic) {
                guildNameSpan.style.fontStyle = 'italic';
            }
        } else {
            guildNameSpan.textContent = guildName;
        }
        
        guildDiv.appendChild(guildNameSpan);
        
        infoDiv.appendChild(guildDiv);
    }
    
    // 3. Создаем элемент с последним входом
    const lastSeenDiv = document.createElement('div');
    lastSeenDiv.className = 'friend-last-seen';
    lastSeenDiv.style.fontSize = '0.7rem';
    lastSeenDiv.style.color = '#7f8c8d';
    lastSeenDiv.style.marginBottom = '2px';
    lastSeenDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    
    const lastSeen = new Date(friend.lastSeen * 1000);
    const now = new Date();
    
    // Вычисляем разницу времени в миллисекундах
    const diffMs = now - lastSeen;
    
    // Переводим в минуты, часы, дни
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    let lastSeenText;
    if (diffMinutes < 60) {
        lastSeenText = `Вход: ${diffMinutes} мин. назад`;
    } else if (diffHours < 24) {
        const remainMinutes = diffMinutes % 60;
        lastSeenText = `Вход: ${diffHours} ч. ${remainMinutes} мин. назад`;
    } else {
        lastSeenText = `Вход: ${diffDays} д. назад`;
    }
    
    lastSeenDiv.textContent = lastSeenText;
    infoDiv.appendChild(lastSeenDiv);
    
    // 4. Создаем элемент со статусом
    const statusDiv = document.createElement('div');
    statusDiv.style.fontSize = '0.7rem';
    statusDiv.style.color = '#7f8c8d'; 
    statusDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    statusDiv.style.display = 'flex';
    statusDiv.style.alignItems = 'center';
    statusDiv.style.gap = '4px';
    
    // Добавляем индикатор статуса (аналогично профилю)
    const statusIndicator = document.createElement('div');
    statusIndicator.className = 'status-icon-square';
    statusIndicator.style.width = '8px';
    statusIndicator.style.height = '8px';
    statusIndicator.style.minWidth = '8px';
    statusIndicator.style.position = 'relative';
    statusIndicator.style.top = '0px';
    
    const statusTextSpan = document.createElement('span');
    
    // Получаем статус непосредственно из объекта сессии
    if (friendStatus === undefined) {
        // Нет данных о статусе - ошибка запроса или сервера
        statusIndicator.style.backgroundColor = '#95a5a6'; // Серый для ошибки/неизвестно
        statusIndicator.style.boxShadow = 'none';
        
        statusTextSpan.textContent = 'Неизвестно';
        statusTextSpan.style.color = '#95a5a6'; // Серый цвет для неизвестного статуса
    } else if (isOnline) {
        // Онлайн статус - берем сообщение из сессии
        statusIndicator.style.backgroundColor = '#2ecc71'; // Зеленый для онлайн
        statusIndicator.style.boxShadow = '0 0 6px #2ecc71';
        statusIndicator.style.animation = 'blink 2s ease-in-out infinite';
        
        // Отображаем конкретный статус из объекта сессии
        const message = friendStatus.message || 'Онлайн';
        statusTextSpan.textContent = message.replace(/^(Играет|Находится) (в|на) /, '');
        statusTextSpan.style.color = '#2ecc71'; // Зеленый цвет для онлайн
    } else {
        // Оффлайн статус
        statusIndicator.style.backgroundColor = '#e74c3c'; // Красный для оффлайн
        statusIndicator.style.boxShadow = '0 0 3px #e74c3c';
        
        statusTextSpan.textContent = 'Оффлайн';
        statusTextSpan.style.color = '#e74c3c'; // Красный цвет для оффлайн
    }
    
    statusDiv.appendChild(statusTextSpan);
    statusDiv.appendChild(statusIndicator);
    
    infoDiv.appendChild(statusDiv);
    
    friendContent.appendChild(infoDiv);
    
    // Добавляем элемент в DOM
    friendElement.appendChild(friendContent);
    
    return friendElement;
}

        // Добавляем обработчик нажатия на вкладку друзей для загрузки данных

        // Добавляем обработчик нажатия на кнопку повтора загрузки
document.addEventListener('DOMContentLoaded', function() {
    const retryBtn = document.getElementById('retry-friends-btn');
    if (retryBtn) {
        retryBtn.addEventListener('click', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const username = urlParams.get('username');
            
            if (username) {
                loadFriendsList(username);
            }
        });
    }
    
    // Добавляем обработчик клика на счетчик друзей
    const friendsCountLink = document.getElementById('friends-count-link');
    if (friendsCountLink) {
        friendsCountLink.addEventListener('click', function() {
            // Активируем вкладку друзей
            const friendsTab = document.getElementById('friends-tab');
            if (friendsTab) {
                const tabInstance = new bootstrap.Tab(friendsTab);
                tabInstance.show();
            }
        });
    }
    
    // Добавляем обработчик переключения на вкладку друзей
    const friendsTab = document.getElementById('friends-tab');
    if (friendsTab) {
        // Флаг, который показывает, были ли загружены статусы друзей
        let friendsStatusesLoaded = false;
        
        friendsTab.addEventListener('shown.bs.tab', function() {
            // Загружаем статусы только при первом переключении на вкладку
            if (!friendsStatusesLoaded) {
                const urlParams = new URLSearchParams(window.location.search);
                const username = urlParams.get('username');
                if (username) {
                    loadFriendsList(username);
                    friendsStatusesLoaded = true;
                }
            }
        });
    }
});

// Функция для скачивания файла
function downloadFile(url, fileName) {
    fetch(url)
        .then(response => response.blob())
        .then(blob => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        })
        .catch(error => {
            console.error('Ошибка при скачивании файла:', error);
            alert('Не удалось скачать файл. Попробуйте позже.');
        });
}

// Функция для скачивания файлов из истории через прокси
async function downloadHistoryFile(url, fileName) {
    try {
        const proxies = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            url // Пробуем без прокси
        ];
        
        let blob = null;
        
        for (const proxyUrl of proxies) {
            try {
                const response = await fetch(proxyUrl);
                blob = await response.blob();
                break;
            } catch (error) {
                console.log('Прокси не сработал для скачивания, пробуем следующий...', error);
            }
        }
        
        if (!blob) {
            throw new Error('Не удалось загрузить файл');
        }
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    } catch (error) {
        console.error('Ошибка при скачивании файла:', error);
        alert('Не удалось скачать файл. Попробуйте позже.');
    }
}

// История скинов и плащей
let historyViewers = [];

function openHistoryModal() {
    const modal = document.getElementById('historyModal');
    modal.classList.add('active');
    
    // Загружаем историю скинов по умолчанию
    loadSkinsHistory();
}

function closeHistoryModal() {
    const modal = document.getElementById('historyModal');
    modal.classList.remove('active');
    
    // Очищаем все viewers
    historyViewers.forEach(viewer => {
        if (viewer && viewer.dispose) {
            viewer.dispose();
        }
    });
    historyViewers = [];
}

// Закрытие модального окна при клике вне его
document.addEventListener('click', function(e) {
    const modal = document.getElementById('historyModal');
    if (modal && e.target === modal) {
        closeHistoryModal();
    }
});

function switchHistoryTab(type) {
    const skinsBtn = document.getElementById('historySkinsBtn');
    const capesBtn = document.getElementById('historyCapesBtn');
    
    if (type === 'skins') {
        skinsBtn.classList.add('active');
        capesBtn.classList.remove('active');
        loadSkinsHistory();
    } else {
        capesBtn.classList.add('active');
        skinsBtn.classList.remove('active');
        loadCapesHistory();
    }
}

async function loadSkinsHistory() {
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get('username');
    const playerId = window.currentPlayerId;
    
    const container = document.getElementById('historyContent');
    container.innerHTML = '<div class="history-loading">Загрузка истории скинов...</div>';
    
    // Очищаем предыдущие viewers
    historyViewers.forEach(viewer => {
        if (viewer && viewer.dispose) {
            viewer.dispose();
        }
    });
    historyViewers = [];
    
    try {
        // Пробуем разные прокси
        const apiUrl = `https://vimetop.ru/api/v1/player/${playerId}/history/skins`;
        const proxies = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`,
            apiUrl // Пробуем без прокси
        ];
        
        let data = null;
        let lastError = null;
        
        for (const proxyUrl of proxies) {
            try {
                const response = await fetch(proxyUrl);
                const text = await response.text();
                data = JSON.parse(text);
                break; // Успешно загрузили
            } catch (error) {
                lastError = error;
                console.log('Прокси не сработал, пробуем следующий...', error);
            }
        }
        
        if (!data) {
            throw lastError || new Error('Не удалось загрузить данные');
        }
        
        if (!data || !data.response || !data.response.data || data.response.data.length === 0) {
            container.innerHTML = '<div class="history-empty">История скинов пуста</div>';
            return;
        }
        
        const grid = document.createElement('div');
        grid.className = 'history-grid';
        
        data.response.data.forEach((item, index) => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.style.animationDelay = `${index * 0.05}s`;
            
            const preview = document.createElement('div');
            preview.className = 'history-item-preview';
            preview.id = `history-skin-${index}`;
            
            const date = document.createElement('div');
            date.className = 'history-item-date';
            date.textContent = new Date(item.created_at).toLocaleString('ru-RU', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'history-item-download';
            downloadBtn.textContent = 'Скачать скин';
            downloadBtn.onclick = function(e) {
                e.stopPropagation();
                downloadHistoryFile(item.url, `skin_${new Date(item.created_at).getTime()}.png`);
            };
            
            historyItem.appendChild(preview);
            historyItem.appendChild(date);
            historyItem.appendChild(downloadBtn);
            grid.appendChild(historyItem);
            
            // Создаем 3D viewer для каждого скина
            setTimeout(async () => {
                try {
                    // Пробуем загрузить скин через разные прокси
                    const proxies = [
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(item.url)}`,
                        item.url // Пробуем без прокси
                    ];
                    
                    let skinBlobUrl = null;
                    
                    for (const proxyUrl of proxies) {
                        try {
                            const skinResponse = await fetch(proxyUrl);
                            const skinBlob = await skinResponse.blob();
                            skinBlobUrl = URL.createObjectURL(skinBlob);
                            break;
                        } catch (error) {
                            console.log('Прокси не сработал для скина, пробуем следующий...', error);
                        }
                    }
                    
                    if (!skinBlobUrl) {
                        throw new Error('Не удалось загрузить скин');
                    }
                    
                    const viewer = new skinview3d.SkinViewer({
                        canvas: Object.assign(document.createElement("canvas"), { 
                            width: preview.offsetWidth, 
                            height: 300 
                        }),
                        width: preview.offsetWidth,
                        height: 300,
                        skin: skinBlobUrl,
                        background: '#ffffff',
                        lighting: true,
                        ambientLight: 0.5,
                        directionalLight: 0.8
                    });
                    
                    preview.appendChild(viewer.canvas);
                    viewer.controls.enableRotate = true;
                    viewer.controls.enableZoom = true;
                    viewer.controls.enablePan = false;
                    viewer.controls.autoRotate = true;
                    viewer.controls.autoRotateSpeed = 1.0;
                    viewer.animation = new skinview3d.WalkingAnimation();
                    viewer.animation.speed = 0.8;
                    
                    historyViewers.push(viewer);
                } catch (error) {
                    console.error('Ошибка создания viewer:', error);
                    preview.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">Ошибка загрузки</div>';
                }
            }, index * 100);
        });
        
        container.innerHTML = '';
        container.appendChild(grid);
        
    } catch (error) {
        console.error('Ошибка загрузки истории скинов:', error);
        container.innerHTML = '<div class="history-error">Ошибка загрузки истории скинов</div>';
    }
}

async function loadCapesHistory() {
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get('username');
    const playerId = window.currentPlayerId;
    
    const container = document.getElementById('historyContent');
    container.innerHTML = '<div class="history-loading">Загрузка истории плащей...</div>';
    
    // Очищаем предыдущие viewers
    historyViewers.forEach(viewer => {
        if (viewer && viewer.dispose) {
            viewer.dispose();
        }
    });
    historyViewers = [];
    
    try {
        // Пробуем разные прокси
        const apiUrl = `https://vimetop.ru/api/v1/player/${playerId}/history/capes`;
        const proxies = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`,
            apiUrl // Пробуем без прокси
        ];
        
        let data = null;
        let lastError = null;
        
        for (const proxyUrl of proxies) {
            try {
                const response = await fetch(proxyUrl);
                const text = await response.text();
                data = JSON.parse(text);
                break; // Успешно загрузили
            } catch (error) {
                lastError = error;
                console.log('Прокси не сработал, пробуем следующий...', error);
            }
        }
        
        if (!data) {
            throw lastError || new Error('Не удалось загрузить данные');
        }
        
        if (!data || !data.response || !data.response.data || data.response.data.length === 0) {
            container.innerHTML = '<div class="history-empty">История плащей пуста</div>';
            return;
        }
        
        const grid = document.createElement('div');
        grid.className = 'history-grid';
        
        // Получаем текущий скин для отображения с плащом
        const currentSkinUrl = `https://skin.vimeworld.com/raw/skin/${username}.png`;
        
        data.response.data.forEach((item, index) => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.style.animationDelay = `${index * 0.05}s`;
            
            const preview = document.createElement('div');
            preview.className = 'history-item-preview';
            preview.id = `history-cape-${index}`;
            
            const date = document.createElement('div');
            date.className = 'history-item-date';
            date.textContent = new Date(item.created_at).toLocaleString('ru-RU', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'history-item-download';
            downloadBtn.textContent = 'Скачать плащ';
            downloadBtn.onclick = function(e) {
                e.stopPropagation();
                downloadHistoryFile(item.url, `cape_${new Date(item.created_at).getTime()}.png`);
            };
            
            historyItem.appendChild(preview);
            historyItem.appendChild(date);
            historyItem.appendChild(downloadBtn);
            grid.appendChild(historyItem);
            
            // Создаем 3D viewer для каждого плаща
            setTimeout(async () => {
                try {
                    // Пробуем загрузить плащ через разные прокси
                    const proxies = [
                        `https://api.allorigins.win/raw?url=${encodeURIComponent(item.url)}`,
                        item.url // Пробуем без прокси
                    ];
                    
                    let capeBlobUrl = null;
                    
                    for (const proxyUrl of proxies) {
                        try {
                            const capeResponse = await fetch(proxyUrl);
                            const capeBlob = await capeResponse.blob();
                            capeBlobUrl = URL.createObjectURL(capeBlob);
                            break;
                        } catch (error) {
                            console.log('Прокси не сработал для плаща, пробуем следующий...', error);
                        }
                    }
                    
                    if (!capeBlobUrl) {
                        throw new Error('Не удалось загрузить плащ');
                    }
                    
                    const viewer = new skinview3d.SkinViewer({
                        canvas: Object.assign(document.createElement("canvas"), { 
                            width: preview.offsetWidth, 
                            height: 300 
                        }),
                        width: preview.offsetWidth,
                        height: 300,
                        skin: currentSkinUrl,
                        cape: capeBlobUrl,
                        background: '#ffffff',
                        lighting: true,
                        ambientLight: 0.5,
                        directionalLight: 0.8
                    });
                    
                    preview.appendChild(viewer.canvas);
                    viewer.controls.enableRotate = true;
                    viewer.controls.enableZoom = true;
                    viewer.controls.enablePan = false;
                    viewer.controls.autoRotate = true;
                    viewer.controls.autoRotateSpeed = 1.0;
                    viewer.animation = new skinview3d.WalkingAnimation();
                    viewer.animation.speed = 0.8;
                    
                    historyViewers.push(viewer);
                } catch (error) {
                    console.error('Ошибка создания viewer:', error);
                    preview.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">Ошибка загрузки</div>';
                }
            }, index * 100);
        });
        
        container.innerHTML = '';
        container.appendChild(grid);
        
    } catch (error) {
        console.error('Ошибка загрузки истории плащей:', error);
        container.innerHTML = '<div class="history-error">Ошибка загрузки истории плащей</div>';
    }
}

// Добавляем обработчик для кнопки истории
document.addEventListener('DOMContentLoaded', function() {
    const showHistoryBtn = document.getElementById('showHistoryBtn');
    if (showHistoryBtn) {
        showHistoryBtn.addEventListener('click', openHistoryModal);
    }
});

// Функция для парсинга Minecraft цветовых кодов
function parseMinecraftColors(text) {
    if (!text) return '';
    
    const colorMap = {
        '0': '#000000', '1': '#0000AA', '2': '#00AA00', '3': '#00AAAA',
        '4': '#AA0000', '5': '#AA00AA', '6': '#FFAA00', '7': '#AAAAAA',
        '8': '#555555', '9': '#5555FF', 'a': '#55FF55', 'b': '#55FFFF',
        'c': '#FF5555', 'd': '#FF55FF', 'e': '#FFFF55', 'f': '#FFFFFF',
    };
    
    const formatMap = {
        'l': 'font-weight: bold;',
        'm': 'text-decoration: line-through;',
        'n': 'text-decoration: underline;',
        'o': 'font-style: italic;',
    };
    
    let result = '';
    let currentColor = '';
    let currentFormat = '';
    let i = 0;
    
    while (i < text.length) {
        if (text[i] === '&' && i + 1 < text.length) {
            const code = text[i + 1].toLowerCase();
            
            if (colorMap[code]) {
                if (currentColor || currentFormat) result += '</span>';
                currentColor = colorMap[code];
                currentFormat = '';
                result += `<span style="color: ${currentColor};">`;
                i += 2;
                continue;
            } else if (formatMap[code]) {
                if (currentColor || currentFormat) result += '</span>';
                currentFormat += formatMap[code];
                result += `<span style="${currentColor ? 'color: ' + currentColor + '; ' : ''}${currentFormat}">`;
                i += 2;
                continue;
            } else if (code === 'r') {
                if (currentColor || currentFormat) result += '</span>';
                currentColor = '';
                currentFormat = '';
                i += 2;
                continue;
            }
        }
        
        result += text[i];
        i++;
    }
    
    if (currentColor || currentFormat) result += '</span>';
    
    return result;
}

// Функция для загрузки достижений
let achievementsData = null;
let playerAchievements = null;

async function loadAchievements(playerId) {
    try {
        const achievementsGrid = document.querySelector('#achievements .achievements-grid');
        achievementsGrid.innerHTML = '<div class="loading">Загрузка достижений...</div>';

        // Загружаем список всех достижений и достижения игрока параллельно
        const [allAchievementsResponse, playerAchievementsResponse] = await Promise.all([
            fetch('https://api.vimeworld.com/misc/achievements'),
            fetch(`https://api.vimeworld.com/user/${playerId}/achievements`)
        ]);

        achievementsData = await allAchievementsResponse.json();
        const playerAchievementsData = await playerAchievementsResponse.json();
        
        // API возвращает объект с массивом achievements внутри
        playerAchievements = playerAchievementsData.achievements || [];

        displayAchievements();
    } catch (error) {
        console.error('Ошибка при загрузке достижений:', error);
        const achievementsGrid = document.querySelector('#achievements .achievements-grid');
        achievementsGrid.innerHTML = '<div class="error-message">Не удалось загрузить достижения</div>';
    }
}

function displayAchievements() {
    const achievementsGrid = document.querySelector('#achievements .achievements-grid');
    achievementsGrid.innerHTML = '';
    achievementsGrid.style.display = 'flex';
    achievementsGrid.style.flexDirection = 'column';
    achievementsGrid.style.gap = '24px';

    // Добавляем CSS анимации
    if (!document.getElementById('achievements-animations')) {
        const style = document.createElement('style');
        style.id = 'achievements-animations';
        style.textContent = `
            @keyframes fadeInStats {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeInCategory {
                from { opacity: 0; transform: translateY(20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeInAchievement {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
        `;
        document.head.appendChild(style);
    }

    // Получаем список ID достижений игрока
    const playerAchievementIds = new Set(playerAchievements.map(a => a.id));
    
    // Создаем Map для быстрого доступа к времени выполнения достижения
    const playerAchievementTimes = new Map(playerAchievements.map(a => [a.id, a.time]));

    // Подсчитываем общую статистику
    let totalAchievements = 0;
    let completedAchievements = 0;
    let totalReward = 0;
    let earnedReward = 0;

    // Создаем общую статистику
    const statsContainer = document.createElement('div');
    statsContainer.style.cssText = `
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 50%, #d35400 100%);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 12px 40px rgba(243, 156, 18, 0.25);
        color: white;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 24px;
        position: relative;
        overflow: hidden;
        animation: fadeInStats 0.6s ease-out;
    `;

    // Добавляем декоративные элементы
    const decorCircle1 = document.createElement('div');
    decorCircle1.style.cssText = `
        position: absolute;
        width: 200px;
        height: 200px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        top: -100px;
        right: -50px;
        pointer-events: none;
    `;
    statsContainer.appendChild(decorCircle1);

    const decorCircle2 = document.createElement('div');
    decorCircle2.style.cssText = `
        position: absolute;
        width: 150px;
        height: 150px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 50%;
        bottom: -75px;
        left: -30px;
        pointer-events: none;
    `;
    statsContainer.appendChild(decorCircle2);
    
    // Добавляем большую иконку монет справа
    const bigMoneyIcon = document.createElement('img');
    bigMoneyIcon.src = 'assets/images/icons/mnogo_money.png';
    bigMoneyIcon.style.cssText = `
        position: absolute;
        width: 200px;
        height: 200px;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        object-fit: contain;
        filter: drop-shadow(0 8px 16px rgba(0,0,0,0.3));
        opacity: 0.9;
        pointer-events: auto;
        z-index: 2;
        cursor: pointer;
        transition: transform 0.1s ease;
    `;
    
    // Счетчик кликов для дождя из монет
    let clickTimes = [];
    
    bigMoneyIcon.addEventListener('click', (e) => {
        // Эффект дёргания
        bigMoneyIcon.style.transform = 'translateY(-50%) scale(0.9) rotate(-5deg)';
        setTimeout(() => {
            bigMoneyIcon.style.transform = 'translateY(-50%) scale(1.05) rotate(5deg)';
        }, 50);
        setTimeout(() => {
            bigMoneyIcon.style.transform = 'translateY(-50%) scale(1) rotate(0deg)';
        }, 100);
        
        // Отслеживание кликов
        const now = Date.now();
        clickTimes.push(now);
        
        // Удаляем клики старше 3 секунд
        clickTimes = clickTimes.filter(time => now - time < 3000);
        
        // Если 10 кликов за 3 секунды - запускаем дождь из монет
        if (clickTimes.length >= 10) {
            clickTimes = []; // Сбрасываем счетчик
            startMoneyRain();
        }
    });
    
    // Функция дождя из монет
    function startMoneyRain() {
        const duration = 5000; // 5 секунд дождя
        const coinsPerSecond = 30; // 30 монет в секунду
        const totalCoins = (duration / 1000) * coinsPerSecond;
        
        for (let i = 0; i < totalCoins; i++) {
            setTimeout(() => {
                const coin = document.createElement('img');
                coin.src = Math.random() > 0.5 ? 'assets/images/icons/money.png' : 'assets/images/icons/mnogo_money.png';
                
                const startX = Math.random() * window.innerWidth;
                const size = Math.random() * 30 + 30; // 30-60px
                const duration = Math.random() * 2000 + 3000; // 3-5 секунд падения
                const rotation = Math.random() * 720 - 360; // Случайное вращение
                const sway = Math.random() * 100 - 50; // Покачивание влево-вправо
                
                coin.style.cssText = `
                    position: fixed;
                    width: ${size}px;
                    height: ${size}px;
                    left: ${startX}px;
                    top: -100px;
                    pointer-events: none;
                    z-index: 10000;
                    opacity: 1;
                    user-select: none;
                    object-fit: contain;
                `;
                
                document.body.appendChild(coin);
                
                // Анимация падения
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 1) {
                        const y = -100 + (window.innerHeight + 100) * progress;
                        const x = startX + Math.sin(progress * Math.PI * 2) * sway;
                        const rotate = rotation * progress;
                        const opacity = progress > 0.8 ? 1 - (progress - 0.8) * 5 : 1;
                        
                        coin.style.transform = `translate(-50%, 0) rotate(${rotate}deg)`;
                        coin.style.left = `${x}px`;
                        coin.style.top = `${y}px`;
                        coin.style.opacity = opacity;
                        
                        requestAnimationFrame(animate);
                    } else {
                        coin.remove();
                    }
                };
                
                requestAnimationFrame(animate);
            }, (i / coinsPerSecond) * 1000); // Равномерное распределение во времени
        }
    }
    
    statsContainer.appendChild(bigMoneyIcon);

    // Проходим по каждой категории для подсчета статистики
    for (const [categoryName, achievements] of Object.entries(achievementsData)) {
        if (!achievements || achievements.length === 0) continue;
        
        achievements.forEach(achievement => {
            totalAchievements++;
            totalReward += achievement.reward;
            if (playerAchievementIds.has(achievement.id)) {
                completedAchievements++;
                earnedReward += achievement.reward;
            }
        });
    }

    const progressPercent = totalAchievements > 0 ? Math.round((completedAchievements / totalAchievements) * 100) : 0;

    // Статистика: Прогресс
    const progressStat = document.createElement('div');
    progressStat.style.cssText = 'position: relative; z-index: 1;';
    progressStat.innerHTML = `
        <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 12px; font-family: 'VimeArtBold', sans-serif; letter-spacing: 0.5px;">ПРОГРЕСС</div>
        <div style="font-size: 2.5rem; font-family: 'VimeArtBold', sans-serif; margin-bottom: 8px; text-shadow: 0 2px 8px rgba(0,0,0,0.2);">${progressPercent}%</div>
        <div style="font-size: 0.9rem; opacity: 0.9; font-family: 'VimeArtBold', sans-serif;">${completedAchievements} из ${totalAchievements}</div>
        <div style="width: 100%; height: 6px; background: rgba(255,255,255,0.3); border-radius: 3px; margin-top: 12px; overflow: hidden;">
            <div style="width: ${progressPercent}%; height: 100%; background: white; border-radius: 3px; transition: width 1s ease;"></div>
        </div>
    `;
    statsContainer.appendChild(progressStat);

    // Статистика: Заработано Коинов
    const rewardStat = document.createElement('div');
    rewardStat.style.cssText = 'position: relative; z-index: 1;';
    rewardStat.innerHTML = `
        <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 12px; font-family: 'VimeArtBold', sans-serif; letter-spacing: 0.5px;">ЗАРАБОТАНО КОИНОВ</div>
        <div style="font-size: 2.5rem; font-family: 'VimeArtBold', sans-serif; text-shadow: 0 2px 8px rgba(0,0,0,0.2); margin-bottom: 8px;">${earnedReward.toLocaleString()}</div>
        <div style="font-size: 0.9rem; opacity: 0.9; font-family: 'VimeArtBold', sans-serif;">из ${totalReward.toLocaleString()}</div>
    `;
    statsContainer.appendChild(rewardStat);

    // Статистика: Категории
    const categoriesStat = document.createElement('div');
    categoriesStat.style.cssText = 'position: relative; z-index: 1;';
    const totalCategories = Object.keys(achievementsData).length;
    let completedCategories = 0;
    
    for (const [categoryName, achievements] of Object.entries(achievementsData)) {
        if (!achievements || achievements.length === 0) continue;
        const categoryCompleted = achievements.every(a => playerAchievementIds.has(a.id));
        if (categoryCompleted) completedCategories++;
    }
    
    categoriesStat.innerHTML = `
        <div style="font-size: 0.95rem; opacity: 0.95; margin-bottom: 12px; font-family: 'VimeArtBold', sans-serif; letter-spacing: 0.5px;">КАТЕГОРИИ</div>
        <div style="font-size: 2.5rem; font-family: 'VimeArtBold', sans-serif; margin-bottom: 8px; text-shadow: 0 2px 8px rgba(0,0,0,0.2);">${completedCategories}/${totalCategories}</div>
        <div style="font-size: 0.9rem; opacity: 0.9; font-family: 'VimeArtBold', sans-serif;">завершено</div>
    `;
    statsContainer.appendChild(categoriesStat);

    achievementsGrid.appendChild(statsContainer);

    // Создаем массив категорий с их процентами для сортировки
    const categoriesArray = [];
    
    for (const [categoryName, achievements] of Object.entries(achievementsData)) {
        if (!achievements || achievements.length === 0) continue;

        // Подсчитываем прогресс категории
        const categoryCompleted = achievements.filter(a => playerAchievementIds.has(a.id)).length;
        const categoryTotal = achievements.length;
        const categoryPercent = Math.round((categoryCompleted / categoryTotal) * 100);
        
        categoriesArray.push({
            name: categoryName,
            achievements: achievements,
            completed: categoryCompleted,
            total: categoryTotal,
            percent: categoryPercent
        });
    }
    
    // Сортируем категории от 100% до 0%
    categoriesArray.sort((a, b) => b.percent - a.percent);

    // Проходим по отсортированным категориям
    for (const categoryData of categoriesArray) {
        const categoryName = categoryData.name;
        const achievements = categoryData.achievements;
        const categoryCompleted = categoryData.completed;
        const categoryTotal = categoryData.total;
        const categoryPercent = categoryData.percent;

        // Создаем контейнер для категории
        const categoryContainer = document.createElement('div');
        categoryContainer.style.cssText = `
            background: #fff;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 16px ${categoryPercent === 100 ? 'rgba(243, 156, 18, 0.08)' : 'rgba(127, 140, 141, 0.08)'};
        `;

        // Заголовок категории с прогрессом
        const categoryHeader = document.createElement('div');
        categoryHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid ${categoryPercent === 100 ? '#fef5e7' : '#e8e8e8'};
            cursor: pointer;
            user-select: none;
        `;

        const categoryTitle = document.createElement('h3');
        categoryTitle.style.cssText = `
            font-family: 'VimeArtBold', sans-serif;
            color: ${categoryPercent === 100 ? '#f39c12' : '#7f8c8d'};
            font-size: 1.2rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        // Маппинг иконок игр для достижений
        const achievementGameIcons = {
            'Annihilation': 'Annihilation.png',
            'BuildBattle': 'BuildBattle.png',
            'BlockParty': 'BlockParty.png',
            'BedWars': 'bedwars.png',
            'BedWars Hype': 'BedWarsHype.png',
            'BedWars Turbo': 'BedWars Turbo.png',
            'ClashPoint': 'ClashPoint.png',
            'Дуэли': 'Duels.png',
            'GunGame': 'GunGame.png',
            'HungerGames': 'HungerGames.png',
            'KitPvP': 'kitpvp.png',
            'EggWars': 'EggWars.png',
            'MobWars': 'MobWars.png',
            'Prison': 'Prison.png',
            'Prison Lite | Alpha': 'prisonalphabeta.png',
            'SkyWars': 'SkyWars.png',
            'Аркады': 'arcade.png',
            'The Bridge': 'TheBridge.png',
            'Jump League': 'JumpLeague.png',
            'Murder Mystery': 'MurderMystery.png',
            'Speed Builders': 'speedbuilders.png',
            'Fall Guys': 'FallGuys.png',
            'BattleBox': 'battlebox.png',
            'My Farm': 'MyFarm.png',
            'MyLittleFarm': 'MyFarm.png',
            'FireBall Fight': 'firebollfight.png',
            'Fireball Fight': 'firebollfight.png',
            'Прятки': 'hideandseek.png',
            'TNT Tag': 'tnttag.png',
            'TNT Run': 'tntrun.png',
            'Lucky Wars': 'LuckyWars.png',
            'DeathRun': 'money.png',
            'Turf Wars': 'turfwars.png',
            'Sheep Wars': 'rodwars.png'
        };
        
        // Добавляем иконку
        const categoryIcon = document.createElement('img');
        categoryIcon.src = achievementGameIcons[categoryName] ? `assets/images/icons/${achievementGameIcons[categoryName]}` : 'assets/images/icons/404.png';
        categoryIcon.style.cssText = 'width: 40px; height: 40px; flex-shrink: 0;';
        categoryIcon.onerror = function() {
            if (this.src.indexOf('404.png') === -1) {
                this.src = 'assets/images/icons/404.png';
            }
        };
        categoryTitle.appendChild(categoryIcon);
        
        const categoryTitleText = document.createElement('span');
        categoryTitleText.textContent = categoryName;
        categoryTitle.appendChild(categoryTitleText);

        const categoryProgress = document.createElement('div');
        categoryProgress.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
        `;
        categoryProgress.innerHTML = `
            <span style="font-family: 'VimeArtBold', sans-serif; color: #7f8c8d; font-size: 0.9rem;">
                ${categoryCompleted}/${categoryTotal}
            </span>
            <div style="
                width: 100px;
                height: 8px;
                background: ${categoryPercent === 100 ? '#fef5e7' : '#e8e8e8'};
                border-radius: 4px;
                overflow: hidden;
            ">
                <div style="
                    width: ${categoryPercent}%;
                    height: 100%;
                    background: linear-gradient(90deg, ${categoryPercent === 100 ? '#f39c12, #e67e22' : '#95a5a6, #7f8c8d'});
                    border-radius: 4px;
                    transition: width 0.3s ease;
                "></div>
            </div>
            <span style="font-family: 'VimeArtBold', sans-serif; color: ${categoryPercent === 100 ? '#f39c12' : '#7f8c8d'}; font-size: 0.9rem;">
                ${categoryPercent}%
            </span>
            <span class="category-toggle" style="font-family: 'VimeArtBold', sans-serif; color: ${categoryPercent === 100 ? '#f39c12' : '#7f8c8d'}; font-size: 1.2rem; transition: transform 0.3s ease;">▼</span>
        `;

        categoryHeader.appendChild(categoryTitle);
        categoryHeader.appendChild(categoryProgress);
        categoryContainer.appendChild(categoryHeader);

        // Сетка достижений
        const achievementsContainer = document.createElement('div');
        achievementsContainer.style.cssText = `
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.4s ease, opacity 0.3s ease;
        `;

        // Добавляем обработчик клика для сворачивания/разворачивания
        let isExpanded = false;
        categoryHeader.addEventListener('click', function() {
            isExpanded = !isExpanded;
            const toggle = this.querySelector('.category-toggle');
            
            if (isExpanded) {
                achievementsContainer.style.display = 'grid';
                // Небольшая задержка для плавной анимации
                setTimeout(() => {
                    achievementsContainer.style.maxHeight = '10000px';
                    achievementsContainer.style.opacity = '1';
                }, 10);
                toggle.style.transform = 'rotate(180deg)';
            } else {
                achievementsContainer.style.maxHeight = '0';
                achievementsContainer.style.opacity = '0';
                toggle.style.transform = 'rotate(0deg)';
                // Скрываем после завершения анимации
                setTimeout(() => {
                    if (!isExpanded) {
                        achievementsContainer.style.display = 'none';
                    }
                }, 400);
            }
        });

        // Добавляем каждое достижение
        achievements.forEach(achievement => {
            const hasAchievement = playerAchievementIds.has(achievement.id);
            
            const achievementCard = document.createElement('div');
            achievementCard.style.cssText = `
                background: ${hasAchievement ? '#fef9f3' : '#f8f8f8'};
                border-radius: 12px;
                padding: 16px;
                border: 2px solid ${hasAchievement ? '#f39c12' : '#e0e0e0'};
                cursor: ${hasAchievement ? 'pointer' : 'default'};
                position: relative;
                ${!hasAchievement ? 'opacity: 0.6;' : ''}
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            `;

            // Добавляем эффект падающих монет при клике на выполненное достижение
            if (hasAchievement) {
                achievementCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const clickX = e.clientX;
                    const clickY = e.clientY;
                    
                    // Создаем 15-20 монет
                    const coinCount = Math.floor(Math.random() * 6) + 15;
                    
                    for (let i = 0; i < coinCount; i++) {
                        const coin = document.createElement('img');
                        coin.src = Math.random() > 0.5 ? 'assets/images/icons/money.png' : 'assets/images/icons/mnogo_money.png';
                        coin.style.cssText = `
                            position: fixed;
                            width: ${Math.random() * 30 + 40}px;
                            height: ${Math.random() * 30 + 40}px;
                            left: ${clickX}px;
                            top: ${clickY}px;
                            pointer-events: none;
                            z-index: 10000;
                            opacity: 1;
                            transform: translate(-50%, -50%);
                            user-select: none;
                        `;
                        document.body.appendChild(coin);
                        
                        // Случайные параметры для каждой монеты
                        const angle = Math.random() * Math.PI * 2;
                        const velocity = Math.random() * 200 + 100;
                        const vx = Math.cos(angle) * velocity;
                        const vy = Math.sin(angle) * velocity - 200;
                        const rotation = Math.random() * 720 - 360;
                        
                        let posX = clickX;
                        let posY = clickY;
                        let velocityX = vx;
                        let velocityY = vy;
                        const gravity = 800;
                        let opacity = 1;
                        
                        const startTime = Date.now();
                        const duration = 2000;
                        
                        function animate() {
                            const elapsed = Date.now() - startTime;
                            const progress = elapsed / duration;
                            
                            if (progress >= 1) {
                                coin.remove();
                                return;
                            }
                            
                            const dt = 0.016;
                            velocityY += gravity * dt;
                            posX += velocityX * dt;
                            posY += velocityY * dt;
                            
                            opacity = 1 - progress;
                            
                            coin.style.left = posX + 'px';
                            coin.style.top = posY + 'px';
                            coin.style.opacity = opacity;
                            coin.style.transform = `translate(-50%, -50%) rotate(${rotation * progress}deg)`;
                            
                            requestAnimationFrame(animate);
                        }
                        
                        requestAnimationFrame(animate);
                    }
                });
            }

            // Иконка статуса (монетка или money_chb)
            const statusIcon = document.createElement('img');
            statusIcon.src = hasAchievement ? 'assets/images/icons/money.png' : 'assets/images/icons/money_chb.png';
            statusIcon.style.cssText = `
                position: absolute;
                top: 6px;
                right: 6px;
                width: 48px;
                height: 48px;
                object-fit: contain;
            `;
            achievementCard.appendChild(statusIcon);

            // Название достижения
            const title = document.createElement('div');
            title.innerHTML = parseMinecraftColors(achievement.title);
            title.style.cssText = `
                font-family: 'VimeArtBold', sans-serif;
                font-size: 1rem;
                margin-bottom: 8px;
                padding-right: 32px;
            `;
            // Если нет цветовых кодов, применяем базовый цвет
            if (!achievement.title.includes('&')) {
                title.style.color = hasAchievement ? '#2c3e50' : '#7f8c8d';
            }
            achievementCard.appendChild(title);

            // Описание достижения
            const description = document.createElement('div');
            description.innerHTML = parseMinecraftColors(achievement.description.join(' '));
            description.style.cssText = `
                font-family: 'VimeArtBold', sans-serif;
                font-size: 0.85rem;
                margin-bottom: 12px;
                line-height: 1.4;
            `;
            // Если нет цветовых кодов, применяем базовый цвет
            if (!achievement.description.join(' ').includes('&')) {
                description.style.color = '#7f8c8d';
            }
            achievementCard.appendChild(description);

            // Награда
            const reward = document.createElement('div');
            reward.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
                font-family: 'VimeArtBold', sans-serif;
                font-size: 0.95rem;
                color: ${hasAchievement ? '#f39c12' : '#95a5a6'};
                padding-right: 120px;
            `;
            reward.innerHTML = `
                <span>${achievement.reward.toLocaleString()} Коинов</span>
            `;
            achievementCard.appendChild(reward);
            
            // Время выполнения достижения (если выполнено)
            if (hasAchievement && playerAchievementTimes.has(achievement.id)) {
                const timestamp = playerAchievementTimes.get(achievement.id);
                const date = new Date(timestamp * 1000);
                
                // Форматируем дату
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                
                const timeElement = document.createElement('div');
                timeElement.style.cssText = `
                    position: absolute;
                    bottom: 12px;
                    right: 12px;
                    font-family: 'VimeArtBold', sans-serif;
                    font-size: 0.7rem;
                    color: #95a5a6;
                    opacity: 0.8;
                `;
                timeElement.textContent = `${day}.${month}.${year} ${hours}:${minutes}`;
                achievementCard.appendChild(timeElement);
            }

            achievementsContainer.appendChild(achievementCard);
        });

        categoryContainer.appendChild(achievementsContainer);
        achievementsGrid.appendChild(categoryContainer);
    }
}

// Добавляем обработчик для вкладки достижений
document.addEventListener('DOMContentLoaded', function() {
    const achievementsTab = document.getElementById('achievements-tab');
    if (achievementsTab) {
        achievementsTab.addEventListener('shown.bs.tab', function() {
            // Загружаем достижения только при первом открытии вкладки
            if (!achievementsData && window.currentPlayerId) {
                loadAchievements(window.currentPlayerId);
            }
        });
    }
    
    // Добавляем обработчик для вкладки матчей
    const matchesTab = document.getElementById('matches-tab');
    if (matchesTab) {
        matchesTab.addEventListener('shown.bs.tab', function() {
            // Загружаем матчи только при первом открытии вкладки
            if (!window.matchesLoaded && window.currentPlayerId) {
                loadMatches(window.currentPlayerId);
            }
        });
    }
    
    // Обработчик для кнопки повтора загрузки матчей
    const retryMatchesBtn = document.getElementById('retry-matches-btn');
    if (retryMatchesBtn) {
        retryMatchesBtn.addEventListener('click', function() {
            if (window.currentPlayerId) {
                loadMatches(window.currentPlayerId);
            }
        });
    }
});

// Функция для загрузки матчей
let matchesData = null;
let filteredMatches = null;

async function loadMatches(playerId) {
    try {
        const matchesLoading = document.getElementById('matches-loading');
        const matchesError = document.getElementById('matches-error');
        const matchesList = document.getElementById('matches-list');
        const matchesFilters = document.getElementById('matches-filters');
        
        matchesLoading.style.display = 'block';
        matchesError.style.display = 'none';
        matchesList.style.display = 'none';
        matchesFilters.style.display = 'none';
        
        const response = await fetch(`https://api.vimeworld.com/user/${playerId}/matches?count=250`);
        
        if (!response.ok) {
            throw new Error('Ошибка загрузки матчей');
        }
        
        matchesData = await response.json();
        filteredMatches = matchesData.matches || [];
        window.matchesLoaded = true;
        
        // Заполняем фильтр игр
        populateGameFilter();
        
        displayMatches();
        
        matchesLoading.style.display = 'none';
        matchesList.style.display = 'grid';
        matchesFilters.style.display = 'block';
        
    } catch (error) {
        console.error('Ошибка при загрузке матчей:', error);
        const matchesLoading = document.getElementById('matches-loading');
        const matchesError = document.getElementById('matches-error');
        
        matchesLoading.style.display = 'none';
        matchesError.style.display = 'block';
    }
}

// Заполняем фильтр игр уникальными играми
function populateGameFilter() {
    const gameFilter = document.getElementById('matches-game-filter');
    const games = new Set();
    
    if (matchesData && matchesData.matches) {
        matchesData.matches.forEach(match => {
            if (match.game) {
                games.add(match.game);
            }
        });
    }
    
    // Очищаем и добавляем опции
    gameFilter.innerHTML = '<option value="all">Все игры</option>';
    
    Array.from(games).sort().forEach(game => {
        const gameInfo = gameIcons[game] || { name: game };
        const option = document.createElement('option');
        option.value = game;
        option.textContent = gameInfo.name;
        gameFilter.appendChild(option);
    });
    
    // Добавляем обработчики фильтров
    gameFilter.addEventListener('change', applyFilters);
    document.getElementById('matches-result-filter').addEventListener('change', applyFilters);
}

// Применяем фильтры
function applyFilters() {
    const gameFilter = document.getElementById('matches-game-filter').value;
    const resultFilter = document.getElementById('matches-result-filter').value;
    
    filteredMatches = matchesData.matches.filter(match => {
        // Фильтр по игре
        if (gameFilter !== 'all' && match.game !== gameFilter) {
            return false;
        }
        
        // Фильтр по результату
        if (resultFilter !== 'all') {
            if (resultFilter === 'win' && match.win !== true) return false;
            if (resultFilter === 'lose' && match.win !== false) return false;
            if (resultFilter === 'draw' && match.win !== undefined) return false;
        }
        
        return true;
    });
    
    displayMatches();
}

// Маппинг игр на иконки и названия (из вкладки статистики)
const gameIcons = {
    'ANN': { name: 'Annihilation', icon: 'Annihilation.png' },
    'BB': { name: 'BuildBattle', icon: 'BuildBattle.png' },
    'BP': { name: 'BlockParty', icon: 'BlockParty.png' },
    'BW': { name: 'BedWars', icon: 'bedwars.png' },
    'BWHYPE': { name: 'BedWars Hype', icon: 'BedWarsHype.png' },
    'BWT': { name: 'BedWars Turbo', icon: 'BedWars Turbo.png' },
    'CP': { name: 'ClashPoint', icon: 'ClashPoint.png' },
    'DUELS': { name: 'Дуэли', icon: 'Duels.png' },
    'GG': { name: 'GunGame', icon: 'GunGame.png' },
    'HG': { name: 'HungerGames', icon: 'HungerGames.png' },
    'KPVP': { name: 'KitPvP', icon: 'kitpvp.png' },
    'EGGWARS': { name: 'EggWars', icon: 'EggWars.png' },
    'MW': { name: 'MobWars', icon: 'MobWars.png' },
    'PRISON': { name: 'Prison', icon: 'Prison.png' },
    'PRISON_LITE': { name: 'Prison Lite | Alpha', icon: 'prisonalphabeta.png' },
    'SW': { name: 'SkyWars', icon: 'SkyWars.png' },
    'ARC': { name: 'Аркады', icon: 'arcade.png' },
    'BRIDGE': { name: 'The Bridge', icon: 'TheBridge.png' },
    'JUMPLEAGUE': { name: 'Jump League', icon: 'JumpLeague.png' },
    'MURDER': { name: 'Murder Mystery', icon: 'MurderMystery.png' },
    'SHEEP': { name: 'Sheep Wars', icon: 'rodwars.png' },
    'TURFWARS': { name: 'Turf Wars', icon: 'turfwars.png' },
    'TNTTAG': { name: 'TNT Tag', icon: 'tnttag.png' },
    'TNTRUN': { name: 'TNT Run', icon: 'tntrun.png' },
    'LUCKYWARS': { name: 'Lucky Wars', icon: 'LuckyWars.png' },
    'WHITECOLD': { name: 'Белый Холод', icon: '404.png' },
    'HIDE': { name: 'Прятки', icon: 'hideandseek.png' },
    'SPEEDBUILDERS': { name: 'Speed Builders', icon: 'speedbuilders.png' },
    'FALLGUYS': { name: 'Fall Guys', icon: 'FallGuys.png' },
    'TEAMFORTRESS': { name: 'Team Fortess', icon: '404.png' },
    'BATTLEBOX': { name: 'Battle Box', icon: 'battlebox.png' },
    'FARM': { name: 'My Farm', icon: 'MyFarm.png' },
    'FIREBALLFIGHT': { name: 'Fireball Fight', icon: 'firebollfight.png' },
    'DEATHRUN': { name: 'Death Run', icon: 'money.png' }
};

function displayMatches() {
    const matchesList = document.getElementById('matches-list');
    matchesList.innerHTML = '';
    
    if (!filteredMatches || filteredMatches.length === 0) {
        matchesList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 50px; color: #7f8c8d; font-family: \'VimeArtBold\', sans-serif;">Матчи не найдены</div>';
        return;
    }
    
    // Считаем статистику: учитываем фильтр по игре, но не по результату
    const gameFilter = document.getElementById('matches-game-filter').value;
    const matchesForStats = gameFilter === 'all' 
        ? matchesData.matches 
        : matchesData.matches.filter(m => m.game === gameFilter);
    
    const stats = {
        total: matchesForStats.length,
        wins: matchesForStats.filter(m => m.win === true).length,
        losses: matchesForStats.filter(m => m.win === false).length,
        draws: matchesForStats.filter(m => m.win === undefined).length,
        totalKills: matchesForStats.reduce((sum, m) => sum + (m.kills || 0), 0),
        totalDeaths: matchesForStats.reduce((sum, m) => sum + (m.deaths || 0), 0)
    };
    
    const winRate = stats.total > 0 ? ((stats.wins / stats.total) * 100).toFixed(1) : 0;
    const kd = stats.totalDeaths > 0 ? (stats.totalKills / stats.totalDeaths).toFixed(2) : stats.totalKills.toFixed(2);
    
    // Создаем блок статистики
    const statsBlock = document.createElement('div');
    statsBlock.style.cssText = `
        grid-column: 1/-1;
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
        color: white;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
    `;
    
    statsBlock.innerHTML = `
        <div style="text-align: center;">
            <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 8px; font-family: 'VimeArtBold', sans-serif;">ВСЕГО МАТЧЕЙ</div>
            <div style="font-size: 2rem; font-family: 'VimeArtBold', sans-serif;">${stats.total}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 8px; font-family: 'VimeArtBold', sans-serif;">ПОБЕД</div>
            <div style="font-size: 2rem; font-family: 'VimeArtBold', sans-serif; color: #2ecc71;">${stats.wins}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 8px; font-family: 'VimeArtBold', sans-serif;">ПОРАЖЕНИЙ</div>
            <div style="font-size: 2rem; font-family: 'VimeArtBold', sans-serif; color: #e74c3c;">${stats.losses}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 8px; font-family: 'VimeArtBold', sans-serif;">ВИНРЕЙТ</div>
            <div style="font-size: 2rem; font-family: 'VimeArtBold', sans-serif;">${winRate}%</div>
        </div>
    `;
    
    matchesList.appendChild(statsBlock);
    
    filteredMatches.forEach((match, index) => {
        const matchCard = document.createElement('div');
        matchCard.className = 'match-card';
        matchCard.style.animationDelay = `${index * 0.05}s`;
        
        // Определяем игру
        const gameInfo = gameIcons[match.game] || { name: match.game, icon: '404.png' };
        const gameIconPath = `assets/images/icons/${gameInfo.icon}`;
        
        // Определяем результат
        let resultClass = 'draw';
        let resultText = 'Ничья';
        
        if (match.win !== undefined) {
            if (match.win === true) {
                resultClass = 'win';
                resultText = 'Победа';
            } else if (match.win === false) {
                resultClass = 'lose';
                resultText = 'Поражение';
            }
        }
        
        // Форматируем дату
        const matchDate = new Date(match.date * 1000);
        const formattedDate = matchDate.toLocaleString('ru-RU', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        // Создаем HTML карточки
        let matchHTML = `
            <div class="match-header">
                <div class="match-game">
                    <img src="${gameIconPath}" alt="${gameInfo.name}" class="match-game-icon" onerror="this.src='assets/images/icons/404.png'">
                    <span>${gameInfo.name}</span>
                </div>
                <div class="match-result ${resultClass}">${resultText}</div>
            </div>
            <div class="match-info">
        `;
        
        // Добавляем информацию о матче
        if (match.map) {
            matchHTML += `<div class="match-map">Карта: ${match.map.name}</div>`;
        }
        
        // Добавляем статистику в зависимости от игры
        if (match.kills !== undefined) {
            matchHTML += `
                <div class="match-info-row">
                    <span class="match-info-label">Убийств:</span>
                    <span class="match-info-value">${match.kills}</span>
                </div>
            `;
        }
        
        if (match.deaths !== undefined) {
            matchHTML += `
                <div class="match-info-row">
                    <span class="match-info-label">Смертей:</span>
                    <span class="match-info-value">${match.deaths}</span>
                </div>
            `;
        }
        
        if (match.kills !== undefined && match.deaths !== undefined) {
            const kd = match.deaths > 0 ? (match.kills / match.deaths).toFixed(2) : match.kills.toFixed(2);
            matchHTML += `
                <div class="match-info-row">
                    <span class="match-info-label">K/D:</span>
                    <span class="match-info-value">${kd}</span>
                </div>
            `;
        }
        
        if (match.score !== undefined) {
            matchHTML += `
                <div class="match-info-row">
                    <span class="match-info-label">Очки:</span>
                    <span class="match-info-value">${match.score}</span>
                </div>
            `;
        }
        
        if (match.duration !== undefined) {
            const minutes = Math.floor(match.duration / 60);
            const seconds = match.duration % 60;
            matchHTML += `
                <div class="match-info-row">
                    <span class="match-info-label">Длительность:</span>
                    <span class="match-info-value">${minutes}:${seconds.toString().padStart(2, '0')}</span>
                </div>
            `;
        }
        
        // Добавляем дополнительные поля если они есть
        const excludeFields = ['game', 'map', 'date', 'win', 'kills', 'deaths', 'score', 'duration', 'id', 'state'];
        for (const [key, value] of Object.entries(match)) {
            if (!excludeFields.includes(key) && typeof value !== 'object') {
                const label = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
                matchHTML += `
                    <div class="match-info-row">
                        <span class="match-info-label">${label}:</span>
                        <span class="match-info-value">${value}</span>
                    </div>
                `;
            }
        }
        
        matchHTML += `
            </div>
            <div class="match-date">
                ${formattedDate}
                ${match.id ? `<div style="font-size: 0.7rem; color: #bdc3c7; margin-top: 4px;">ID: ${match.id}</div>` : ''}
            </div>
        `;
        
        matchCard.innerHTML = matchHTML;
        matchesList.appendChild(matchCard);
    });
}

    </script>
    <script src="js/auth.js"></script>

    <!-- Модальное окно истории скинов и плащей -->
    <div id="historyModal" class="history-modal">
        <div class="history-modal-content">
            <div class="history-modal-header">
                <h2 class="history-modal-title">История скинов и плащей</h2>
                <button class="history-modal-close" onclick="closeHistoryModal()">×</button>
            </div>
            <div class="history-tabs">
                <button id="historySkinsBtn" class="history-tab-btn active" onclick="switchHistoryTab('skins')">Скины</button>
                <button id="historyCapesBtn" class="history-tab-btn" onclick="switchHistoryTab('capes')">Плащи</button>
            </div>
            <div id="historyContent">
                <div class="history-loading">Загрузка...</div>
            </div>
        </div>
    </div>
</body>
</html> 