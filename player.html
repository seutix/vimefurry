<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профиль | VimeStats</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="settings.css">
    <style>
        @font-face {
            font-family: 'VimeArtBold';
            src: url('https://mc.vimeworld.com/assets/vimestats/vimeartbold.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background: linear-gradient(135deg, #ffffff 0%, #e6f3ff 100%);
            min-height: 100vh;
            color: #2c3e50;
            margin: 0;
            padding: 0;
            scrollbar-width: thin;
            scrollbar-color: #3498db transparent; /* Цвет ползунка и трека */
        }
        .player-container {
            max-width: 1200px;
            margin: 80px auto 0;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        /* Добавляем медиа-запросы для мобильных устройств */
        @media (max-width: 768px) {
            .player-container {
                margin: 60px auto 0;
                padding: 10px;
            }
            .player-header {
                flex-direction: column;
                text-align: center;
                padding: 16px;
            }
            .player-avatar {
                width: 100px;
                height: 100px;
                margin: 0 auto;
            }
            .player-name {
                font-size: 1.4rem;
                justify-content: center;
            }
            .player-status {
                justify-content: center;
            }
            .stats-grid {
                display: flex !important;
                flex-direction: column !important;
            }
            .stats-row {
                display: flex !important;
                flex-direction: column !important;
                grid-template-columns: none !important;
            }
            .stat-card {
                width: 100% !important;
                max-width: 100% !important;
            }
            .friends-list {
                grid-template-columns: 1fr !important;
            }
            .achievements-grid,
            [class*="achievements-grid"] {
                grid-template-columns: 1fr !important;
            }
            .matches-list,
            [class*="matches-list"] {
                grid-template-columns: 1fr !important;
            }
            .nav-tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 8px;
            }
            .nav-tabs .nav-link {
                white-space: nowrap;
                padding: 8px 16px;
                font-size: 0.9rem;
            }
            #skin-preview-section {
                flex-direction: column;
            }
            #skin3d-container {
                width: 100%;
                height: 500px;
            }
            #skin3d-controls {
                min-width: 100%;
            }
            .navbar .container-fluid {
                padding: 0 10px;
            }
            .navbar-brand {
                font-size: 1rem;
                padding-left: 10px;
            }
            .navbar .container-fluid > div {
                display: none;
            }
            .navbar .container-fluid > div:first-child {
                display: block;
            }
            #quick-search {
                border: none;
                background: none;
                outline: none;
                width: 260px; /* Увеличиваем ширину поля поиска */
                font-family: 'VimeArtBold', sans-serif;
                font-size: 0.9rem;
                color: #3498db;
            }
        }
        @media (max-width: 480px) {
            .stats-grid {
                display: flex !important;
                flex-direction: column !important;
            }
            .stats-row {
                display: flex !important;
                flex-direction: column !important;
                grid-template-columns: none !important;
            }
            .stat-card {
                width: 100% !important;
                max-width: 100% !important;
            }
            .friends-list {
                grid-template-columns: 1fr !important;
            }
            .achievements-grid,
            [class*="achievements-grid"] {
                grid-template-columns: 1fr !important;
            }
            .matches-list,
            [class*="matches-list"] {
                grid-template-columns: 1fr !important;
            }
            .player-name {
                font-size: 1.2rem;
            }
            .status-item {
                font-size: 0.8rem;
            }
        }
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: #fff;
            box-shadow: 0 0 12px rgba(52, 152, 219, 0.1);
        }
        .player-header {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            margin-bottom: 24px;
            display: flex;
            gap: 24px;
            align-items: center;
        }
        .player-avatar {
            width: 120px;
            height: 120px;
            border-radius: 0;
            background: #e6f3ff;
            position: relative;
        }
        .player-avatar-base {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .player-avatar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform: scale(1.1);
            transform-origin: center center;
        }
        .player-avatar img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .player-info {
            flex: 1;
        }
        .player-name {
            font-family: 'VimeArtBold', sans-serif;
            font-size: 1.8rem;
            color: #2c3e50; /* Черный цвет по умолчанию */
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-name #player-name {
            cursor: pointer;
            display: inline-block;
            transition: transform 0.2s ease;
        }
        
        .player-name #player-name:hover {
            transform: scale(1.05);
        }
        .player-privileges { /* Новый класс для контейнера привилегий */
            display: flex;
            align-items: center;
            gap: 6px; /* Отступ между отдельными привилегиями */
            position: relative; /* Для возможности смещения */
            top: 1px; /* Смещаем на 2px вниз */
        }
        .rank-badge {
            padding: 4px 8px; /* Отступы внутри блока */
            border-radius: 4px; /* Скругление углов */
            display: inline-block; /* Блок занимает только необходимую ширину */
            vertical-align: middle; /* Выравнивание по центру с текстом имени */
            font-size: 0.9rem; /* Устанавливаем размер шрифта как у дополнительных рангов */
            /* position: relative; */ /* Переносим позиционирование в .player-privileges */
            /* top: 3px; */ /* Переносим позиционирование в .player-privileges */
        }
        .prime-badge {
            background: rgba(52, 152, 219, 0.2); /* Голубой фон с прозрачностью */
            padding: 4px 10px; /* Увеличенный padding */
            border-radius: 4px; /* Скругление как у рангов */
            font-size: 0.7rem; /* Увеличенный размер шрифта */
            color: #3498db; /* Голубой текст */
            position: relative; /* Для позиционирования tooltip */
        }
        
        .prime-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            color: #2c3e50;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            margin-bottom: 8px;
            z-index: 1000;
        }
        
        .prime-badge:hover .prime-tooltip {
            opacity: 1;
        }
        .player-status {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .status-item {
            position: relative; /* Добавляем для правильного позиционирования тултипа */
            display: flex;
            align-items: center;
            gap: 8px;
            color: #7f8c8d;
        }
        .status-item.online {
            color: #2ecc71;
        }
        .status-item.offline {
            color: #e74c3c;
        }
        .experience-bar {
            width: 100%;
            height: 14px;
            background: #e6f3ff;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
            position: relative;
        }
        .experience-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .experience-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #2c3e50;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 2;
            user-select: none;
        }
        /* Удален неиспользуемый класс experience-percent */
        .experience-remain {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            color: #2c3e50;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.75rem;
            z-index: 2;
            user-select: none;
            margin-left: 10px;
            transition: color 0.3s ease;
        }
        .nav-tabs {
            border: none;
            margin-bottom: 24px;
            gap: 8px;
        }
        .nav-tabs .nav-link {
            border: none;
            color: #7f8c8d;
            padding: 12px 24px;
            border-radius: 12px;
            font-family: 'VimeArtBold', sans-serif;
            transition: all 0.3s ease;
        }
        
        /* Стили для тултипа истории ников */
        #nick-history-tooltip {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10000;
            font-family: 'VimeArtBold', sans-serif;
            animation: fadeInTooltip 0.2s ease-out;
        }
        
        @keyframes fadeInTooltip {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        #nick-history-tooltip::-webkit-scrollbar {
            width: 6px;
        }
        
        #nick-history-tooltip::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        #nick-history-tooltip::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            #nick-history-tooltip {
                min-width: 280px;
                max-width: calc(100vw - 40px);
                left: 20px !important;
                right: 20px;
            }
        }
        .nav-tabs .nav-link:hover {
            background: #e6f3ff;
            color: #3498db;
        }
        .nav-tabs .nav-link.active {
            background: #3498db;
            color: #fff;
        }
        .stats-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
        }
        .stat-card {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            position: relative;
            max-height: 300px;
            overflow: hidden;
            cursor: default;
        }
        .stat-card.dragging {
            opacity: 0.6;
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 12px 32px rgba(52, 152, 219, 0.25);
            z-index: 1000;
        }
        .stat-card.drag-over {
            transform: scale(0.95);
            border: 2px dashed #3498db;
            background: #f0f8ff;
        }
        
        .drag-ghost {
            opacity: 0.95 !important;
            box-shadow: 0 20px 60px rgba(52, 152, 219, 0.3) !important;
            transform-style: preserve-3d;
            perspective: 1000px;
            animation: none !important;
        }
        
        .drag-ghost .drag-handle {
            display: none !important;
        }
        
        .drag-handle {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 3px;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s ease, transform 0.2s ease;
            z-index: 10;
        }
        
        .drag-handle:hover {
            background: rgba(52, 152, 219, 0.1);
            transform: scale(1.1);
        }
        
        .drag-handle:active {
            cursor: grabbing;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .drag-handle-dot {
            width: 3px;
            height: 3px;
            background: #3498db;
            border-radius: 50%;
            transition: background 0.2s ease;
        }
        
        .drag-handle-row {
            display: flex;
            gap: 3px;
        }
        
        .drag-handle:hover .drag-handle-dot {
            background: #2980b9;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .stat-card {
            animation: slideIn 0.3s ease-out;
        }
        .stat-card.expanded {
            max-height: none;
        }
        .stat-card.expanded .stat-values {
            max-height: none;
        }
        .stat-values {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
            transition: scrollbar-color 0.2s ease;
            padding-right: 4px;
        }
        .stat-values:hover {
            scrollbar-color: rgba(52, 152, 219, 0.5) transparent;
        }
        .stat-values::-webkit-scrollbar {
            width: 6px;
            background: transparent;
        }
        .stat-values::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 10px;
            margin: 4px 0;
        }
        .stat-values::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: padding-box;
            transition: background 0.2s ease;
        }
        .stat-values:hover::-webkit-scrollbar-track {
            background: rgba(230, 243, 255, 0.3);
        }
        .stat-values:hover::-webkit-scrollbar-thumb {
            background: #3498db;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        .stat-values:hover::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }
        /* Удаляем специфические стили для кнопок прокрутки в .stat-values */
/*
        .stat-values::-webkit-scrollbar-button {
            display: block;
            height: 12px;
            background-color: #3498db;
            border-radius: 3px;
        }
        .stat-values::-webkit-scrollbar-button:vertical:start {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
         .stat-values::-webkit-scrollbar-button:vertical:end {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
*/

        .expand-button {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            padding: 20px 0 0 0;
            text-align: center;
            cursor: pointer;
            color: transparent;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            display: block;
        }
        .stat-card.expanded .expand-button {
            background: transparent;
            padding: 10px 0;
        }
        .stat-title {
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e6f3ff;
        }
        .stat-values {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem; /* Уменьшаем размер шрифта для всей строки */
            padding: 6px 8px; /* Увеличиваем вертикальный padding и добавляем горизонтальный */
            background: #f8fbff; /* Светлый фон */
            border-radius: 4px; /* Слегка скругляем углы */
            margin: 2px 0; /* Небольшой отступ между строками */
        }
        .stat-name {
            color: #7f8c8d;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.7rem; /* Уменьшаем размер шрифта имени */
            font-weight: normal; /* Уменьшаем жирность */
        }
        .stat-value {
            font-family: 'VimeArtBold', sans-serif;
            color: #2c3e50;
            background: #f8fbff;
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 60px;
            text-align: right;
            font-size: 0.7rem; /* Уменьшаем размер шрифта значения */
        }
        .friends-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 24px;
        }
        .friend-card {
            background: #fff;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 3px 12px rgba(52, 152, 219, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .friend-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(52, 152, 219, 0.15);
        }
        .friend-card-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .friend-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: #e6f3ff;
            position: relative;
            overflow: hidden;
        }
        .friend-avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .friend-avatar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .friend-info {
            flex: 1;
            overflow: hidden;
        }
        .friend-name {
            font-size: 0.85rem;
            font-family: 'VimeArtBold', sans-serif;
            color: #2c3e50;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .friend-rank {
            font-size: 0.65rem;
            padding: 2px 4px;
            border-radius: 3px;
            margin-right: 4px;
            white-space: nowrap;
        }
        .friend-status {
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 3px;
        }
        .friend-status.online {
            color: #2ecc71;
        }
        .friend-status.offline {
            color: #e74c3c;
        }
        .friend-level {
            font-size: 0.8rem;
            color: #7f8c8d;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .friend-level-bar {
            flex: 1;
            height: 5px;
            background: #e6f3ff;
            border-radius: 3px;
            overflow: hidden;
        }
        .friend-level-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 3px;
        }
        .friends-loading {
            text-align: center;
            padding: 50px;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friends-error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friend-prime {
            font-size: 0.7rem;
            background: rgba(52, 152, 219, 0.2);
            padding: 2px 5px;
            border-radius: 4px;
            color: #3498db;
        }
        .friend-guild {
            margin-top: 3px;
            font-size: 0.7rem;
            color: #7f8c8d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'VimeArtBold', sans-serif;
        }
        .friend-guild-tag {
            font-weight: bold;
            margin-right: 3px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
        }
        .error-message {
            text-align: center;
            padding: 40px;
            font-family: 'VimeArtBold', sans-serif;
            color: #e74c3c;
        }
        .skin3d-ctrl-btn {
            display: inline-block;
            width: 100%;
            margin: 0 0 6px 0;
            padding: 8px 12px;
            background: #e6f3ff;
            color: #3498db;
            border: none;
            border-radius: 8px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.08);
        }
        .skin3d-ctrl-btn:hover {
            background: #d1e7ff;
            transform: translateY(-1px);
        }
        .skin3d-ctrl-btn.active {
            background: #3498db;
            color: #fff;
        }
        .skin3d-ctrl-btn:active {
            transform: translateY(1px);
        }
        .skin3d-ctrl-btn i {
            margin-right: 6px;
        }
        .skin3d-ctrl-btn.rotate-left i {
            transform: scaleX(-1);
        }
        .skin3d-ctrl-btn.rotate-right i {
            transform: scaleX(1);
        }
        .skin3d-ctrl-btn.zoom-in i {
            transform: scale(1.2);
        }
        .skin3d-ctrl-btn.zoom-out i {
            transform: scale(0.8);
        }
        .skin3d-ctrl-btn.reset i {
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }
        .skin3d-ctrl-btn.reset:hover i {
            transform: rotate(180deg);
        }
        .button.download-btn {
            min-width: 140px;
            padding: 10px 0;
            height: 40px;
            display: inline-block;
            background: #3498db;
            color: white;
            border-radius: 12px;
            text-decoration: none;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            margin-right: 8px;
            transition: all 0.3s ease;
            border: none;
            box-sizing: border-box;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.15);
        }
        .button.download-btn:last-child {
            margin-right: 0;
        }
        .button.download-btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }
        .button.download-btn:active {
            transform: translateY(1px);
        }
        #skin-preview-section {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            display: flex;
            gap: 24px;
        }
        #skin3d-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 240px;
        }
        .control-group {
            background: #f8fbff;
            border-radius: 10px;
            padding: 12px;
            text-align: left;
        }
        .control-group-title {
            font-family: 'VimeArtBold', sans-serif;
            color: #3498db;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        .control-label {
            flex: 1;
            font-size: 12px;
            color: #2c3e50;
        }
        .control-value {
            font-size: 12px;
            color: #7f8c8d;
            min-width: 35px;
            text-align: right;
            margin-left: 6px;
        }
        .download-buttons {
            display: flex;
            gap: 24px;
            margin-top: 8px;
            padding: 0 12px;
        }
        .skin3d-ctrl-btn {
            width: 100%;
            margin: 0 0 8px 0;
        }
        #skin3d-container {
            width: 480px;
            height: 700px;
            margin: 0 auto 60px auto;
        }
        /* Добавляем стили для выпадающего списка недавних ников в навигации */
        .recent-nicks {
            position: absolute;
            left: 0px;
            top: 100%;
            margin-top: 5px;
            z-index: 10;
            background: #fff;
            border: 1px solid #3498db;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(52,152,219,0.10);
            padding: 0;
            display: block;
            width: 310px;
            box-sizing: border-box;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s;
        }
        .recent-nicks.active {
            padding: 8px 0;
            max-height: 300px;
            opacity: 1;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .recent-nicks.active::-webkit-scrollbar {
            width: 0;
            display: none;
        }
        .recent-nicks-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .recent-nicks-list li {
            padding: 8px 12px;
            color: #3498db;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            transition: background 0.2s;
        }
        .recent-nicks-list li:hover {
            background: #e6f3ff;
        }

        .status-icon-square {
            width: 10px; /* Уменьшенный размер квадратика */
            height: 10px;
            border-radius: 2px;
            display: inline-block;
            margin-left: 0px;
            margin-right: 1px;
            vertical-align: middle;
            position: relative;
            top: 2px;
        }
        .player-avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .additional-ranks {
            display: flex;
            gap: 6px; 
        }
        .additional-rank-badge {
            background: linear-gradient(to right, #3498db, #ffffff);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'VimeArtBold', sans-serif;
            font-size: 0.9rem;
            display: inline-block;
            vertical-align: middle;
        }

        .playtime-trigger {
            display: flex;
            align-items: center;
            gap: 4px;
            position: relative;
        }

        .playtime-label {
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            margin-right: 4px;
            line-height: 1;
        }

        #player-playtime-header {
            line-height: 1;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            position: relative;
        }

        .full-playtime-tooltip {
            position: absolute;
            left: 80px;
            top: -8px;
            transform: none;
            background: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            z-index: 10;
            font-family: 'VimeArtBold', sans-serif;
            font-weight: normal;
            font-size: 0.8rem;
            margin-left: 4px;
            color: #7f8c8d;
        }

        .playtime-trigger:hover .full-playtime-tooltip {
            opacity: 1;
        }

        .navbar-brand {
            font-family:'VimeArtBold',sans-serif;
            font-size:1.2rem;
            color:#3498db;
            letter-spacing:1px;
            padding-left:24px;
            z-index:2;
            position: relative;
            overflow: hidden;
        }

        .navbar-brand::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.4),
                transparent
            );
            animation: shimmer 24s infinite;
        }

        html {
            scrollbar-width: thin;
            scrollbar-color: rgba(52, 152, 219, 0.7) transparent;
        }

        body {
            scrollbar-width: thin;
            scrollbar-color: rgba(52, 152, 219, 0.7) transparent;
        }
        .mini-head {
            width: 25px;
            height: 25px;
            border-radius: 0;
            object-fit: cover;
            position: relative;
            margin-right: 4px;
            transition: transform 0.3s ease;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .mini-head-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transform: scale(1.1);
            transform-origin: center center;
        }
        .recent-nicks-list li .player-rank {
            font-size: 0.7rem; /* Уменьшаем размер шрифта ранга */
            padding: 2px 6px; /* Уменьшаем padding */
            border-radius: 3px; /* Уменьшаем скругление */
            margin-left: 4px;
            display: inline-block;
            vertical-align: middle;
        }
        .recent-nicks-list li .additional-rank-badge {
            font-size: 0.7rem; /* Уменьшаем размер шрифта дополнительного ранга */
            padding: 2px 6px; /* Уменьшаем padding */
            border-radius: 3px; /* Уменьшаем скругление */
            margin-left: 4px;
            display: inline-block;
            vertical-align: middle;
        }
        .online-status {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            margin-left: 4px;
            margin-right: 4px;
            transition: all 0.3s ease;
            align-self: center;
        }
        .online-status.online {
            background-color: #2ecc71;
            box-shadow: 0 0 12px #2ecc71;
            -webkit-animation: blink 2s ease-in-out infinite;
            -moz-animation: blink 2s ease-in-out infinite;
            -o-animation: blink 2s ease-in-out infinite;
            animation: blink 2s ease-in-out infinite;
        }
        .online-status.offline {
            background-color: #e74c3c;
            box-shadow: 0 0 4px #e74c3c;
            animation: none;
        }
        .online-status.unknown {
            background-color: #95a5a6;
            box-shadow: none;
            animation: none;
        }

        @-webkit-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @-moz-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @-o-keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        @keyframes blink {
            0% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
            50% { opacity: 0.4; box-shadow: 0 0 10px #2ecc71; }
            100% { opacity: 1; box-shadow: 0 0 6px #2ecc71; }
        }

        #player-status.online .status-icon-square {
            background-color: #2ecc71;
            box-shadow: 0 0 6px #2ecc71;
            -webkit-animation: blink 2s ease-in-out infinite;
            -moz-animation: blink 2s ease-in-out infinite;
            -o-animation: blink 2s ease-in-out infinite;
            animation: blink 2s ease-in-out infinite;
        }

        #player-status.offline .status-icon-square {
            background-color: #e74c3c;
            box-shadow: 0 0 3px #e74c3c;
            animation: none;
        }

        /* Класс для отключения кастомного шрифта */
        body.no-custom-font * {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        }

        /* Стили для баннера профиля */
        .profile-banner {
            width: 100%;
            height: 200px;
            background: #fff;
            border-radius: 16px;
            margin-bottom: 24px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.10);
            overflow: hidden;
            position: relative;
        }
        
        .profile-banner img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        @media (max-width: 768px) {
            .profile-banner {
                height: 150px;
                margin-bottom: 16px;
            }
        }

        @media (max-width: 480px) {
            .profile-banner {
                height: 120px;
            }
        }
    </style>
</head>
<body>
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm" style="position:fixed;top:0;left:0;width:100%;z-index:1000;">
        <div class="container-fluid" style="padding-left:0;padding-right:0;position:relative;min-height:56px;display:flex;align-items:center;">
            <a class="navbar-brand" href="index.html" style="font-family:'VimeArtBold',sans-serif;font-size:1.2rem;color:#3498db;letter-spacing:1px;padding-left:24px;z-index:2;">VimeStats</a>
            <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:24px;z-index:1;">
                <a href="tops.html" style="font-family:'VimeArtBold',sans-serif;font-size:1.1rem;color:#3498db;text-decoration:none;transition:color 0.2s;display:flex;align-items:center;gap:6px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" style="vertical-align:middle;display:inline-block;margin-bottom:-3px;"><path d="M8 21h8M12 17v4M19 5V3H5v2M19 5v2a7 7 0 0 1-14 0V5m14 0h2a2 2 0 0 1 2 2v1a7 7 0 0 1-6 6.93M5 5H3a2 2 0 0 0-2 2v1a7 7 0 0 0 6 6.93" stroke="#3498db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    Топы
                </a>
                <a href="moders.html" style="font-family:'VimeArtBold',sans-serif;font-size:1.1rem;color:#3498db;text-decoration:none;transition:color 0.2s;display:flex;align-items:center;gap:6px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" style="vertical-align:middle;display:inline-block;margin-bottom:-3px;"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10Z" stroke="#3498db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    Модеры
                </a>
            </div>
            <div style="position:absolute;right:80px;top:50%;transform:translateY(-50%);display:flex;align-items:center;gap:8px;background:#e6f3ff;border-radius:10px;padding:0 12px;height:40px;box-shadow:0 2px 8px rgba(52,152,219,0.08);">
                <input type="text" id="quick-search" placeholder="Поиск" style="border:none;background:none;outline:none;width:260px;font-family:'VimeArtBold',sans-serif;font-size:0.9rem;color:#3498db;" autocomplete="off">
                <div id="quick-search-btn" style="display:flex;align-items:center;justify-content:center;cursor:pointer;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#3498db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                </div>
                <div class="recent-nicks" id="quickRecentNicks">
                    <ul class="recent-nicks-list"></ul>
                </div>
            </div>
            <div id="auth-key-btn" style="position:absolute;right:24px;top:50%;transform:translateY(-50%);width:40px;height:40px;display:flex;align-items:center;justify-content:center;background:#e6f3ff;border-radius:10px;cursor:pointer;box-shadow:0 2px 8px rgba(52,152,219,0.08);">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 16 16" fill="none">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16 5.5C16 8.53757 13.5376 11 10.5 11H7V13H5V15L4 16H0V12L5.16351 6.83649C5.0567 6.40863 5 5.96094 5 5.5C5 2.46243 7.46243 0 10.5 0C13.5376 0 16 2.46243 16 5.5ZM13 4C13 4.55228 12.5523 5 12 5C11.4477 5 11 4.55228 11 4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="#3498db"/>
                </svg>
            </div>
        </div>
    </nav>

    <!-- Кнопка настроек -->
    <div id="settings-btn">
        <div class="gear">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="gear-inner"></div>
        </div>
    </div>

    <!-- Меню настроек -->
    <div id="settings-menu">
        <div class="settings-item">
            <span class="settings-label">Отключить кастомный шрифт</span>
            <div class="settings-toggle" id="font-toggle"></div>
        </div>
    </div>

    <div class="player-container">
        <div id="loading" class="loading">
            Загрузка статистики...
        </div>
        <div id="error" class="error-message" style="display: none;">
            Игрок не найден
        </div>
        <div id="player-content" style="display: none;">
            <div class="player-header">
                <div class="player-avatar" id="player-avatar"></div>
                <div class="player-info">
                    <h1 class="player-name">
                        <span id="player-name" style="display: inline-block; vertical-align: middle;"></span>
                        <div class="player-privileges"> <!-- Новый контейнер для привилегий -->
                            <span class="rank-badge">
                                <span class="player-rank" id="player-rank"></span>
                            </span>
                            <div class="additional-ranks"></div>
                            <span class="prime-badge" id="prime-badge" style="display: none;">Prime</span>
                        </div>
                    </h1>
                    <div class="player-meta" style="font-size: 0.9rem; color: #7f8c8d; margin-bottom: 12px;">
                        <span id="player-id" style="font-size: 0.7rem; font-family: 'VimeArtBold', sans-serif;"></span>
                    </div>
                    <span id="player-level-meta" style="font-size: 0.9rem; color: #2c3e50; font-weight: bold; font-family: 'VimeArtBold', sans-serif;"></span>
                    <div class="experience-bar">
                        <div class="experience-progress" id="experience-progress" style="width: 0%"></div>
                        <div class="experience-text" id="experience-text">0% - 0 / 8000 XP</div>
                        <div class="experience-remain" id="experience-remain">8000 XP</div>
                    </div>
                    <div class="player-status">
                        <div class="status-item" id="player-status">
                            <span>Оффлайн</span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                            <span id="friends-count-link" style="cursor: pointer; display: flex; align-items: center;">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 2px; line-height: 1;">Друзей:</span>
                                <span id="player-friends" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">0</span>
                            </span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                            </svg>
                            <span id="player-guild" style="font-family: 'VimeArtBold', sans-serif;">Нет гильдии</span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            <span class="playtime-trigger">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Наиграно:</span> <span id="player-playtime-header"></span>
                            </span>
                        </div>
                        <div class="status-item">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            <span class="playtime-trigger" style="display: flex; align-items: center; gap: 4px;">
                                <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Последний вход:</span>
                                <span id="player-last-seen" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">${formatUnixTimestamp(player.lastSeen)}</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <ul class="nav nav-tabs" id="playerTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab" style="display: flex; flex-direction: column; align-items: center; gap: 2px; padding: 8px 16px;">
                        <span>Статистика</span>
                        <span id="stats-mode-label" style="font-size: 0.8rem; opacity: 0.8;">Общая</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="friends-tab" data-bs-toggle="tab" data-bs-target="#friends" type="button" role="tab">Друзья</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="skin-tab" data-bs-toggle="tab" data-bs-target="#skin" type="button" role="tab">Скин</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="achievements-tab" data-bs-toggle="tab" data-bs-target="#achievements" type="button" role="tab">Достижения</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="matches-tab" data-bs-toggle="tab" data-bs-target="#matches" type="button" role="tab">Матчи</button>
                </li>
            </ul>

            <div class="tab-content" id="playerTabContent">
                <div class="tab-pane fade show active" id="stats" role="tabpanel">
                    <div class="stats-grid">
                        <!-- Статистика будет добавлена динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="friends" role="tabpanel">
                    <div class="friends-loading" id="friends-loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Загрузка...</span>
                        </div>
                        <div style="margin-top: 10px;">Загрузка списка друзей...</div>
                    </div>
                    <div class="friends-error" id="friends-error" style="display: none;">
                        <div>Не удалось загрузить список друзей</div>
                        <button class="btn btn-primary mt-3" id="retry-friends-btn">Повторить</button>
                    </div>
                    <!-- Добавляем селектор сортировки -->
                    <div id="friends-sort-container" style="display: none; margin-bottom: 15px;">
                        <div class="d-flex align-items-center">
                            <label for="friends-sort" style="margin-right: 10px; font-family: 'VimeArtBold', sans-serif; font-size: 0.9rem; color: #3498db;">Сортировка:</label>
                            <select id="friends-sort" class="form-select" style="width: auto; max-width: 200px; font-family: 'VimeArtBold', sans-serif; font-size: 0.9rem; color: #2c3e50; background-color: #f8fbff; border-color: #e6f3ff;">
                                <option value="online">Онлайн</option>
                                <option value="last_seen">Вход</option>
                                <option value="rank">Ранг</option>
                                <option value="name">Имя</option>
                            </select>
                        </div>
                    </div>
                    <div class="friends-list" id="friends-list" style="display: none;">
                        <!-- Друзья будут добавлены динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="skin" role="tabpanel">
                    <div id="skin-preview-section">
                        <div id="skin3d-controls">
                            <div class="control-group">
                                <div class="control-group-title">Анимация</div>
                                <button id="toggleWalkAnimBtn" class="skin3d-ctrl-btn active">Анимация ходьбы</button>
                                <button id="toggleRunAnimBtn" class="skin3d-ctrl-btn">Анимация бега</button>
                            </div>
                            <div class="control-group">
                                <div class="control-group-title">Камера</div>
                                <button id="toggleAutoRotateBtn" class="skin3d-ctrl-btn">Автовращение</button>
                            </div>
                            <div class="control-group">
                                <div class="control-group-title">Отображение</div>
                                <button id="toggleCapeBtn" class="skin3d-ctrl-btn active">Скрыть плащ</button>
                            </div>
                            <div class="download-buttons">
                                <a id="downloadSkinBtn" class="button download-btn">Скачать скин</a>
                                <a id="downloadCapeBtn" class="button download-btn" style="display:none;">Скачать плащ</a>
                            </div>
                        </div>
                        <div id="skin3d-container"></div>
                    </div>
                </div>

                <div class="tab-pane fade" id="achievements" role="tabpanel">
                    <div class="achievements-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                        <!-- Достижения будут добавлены динамически -->
                    </div>
                </div>

                <div class="tab-pane fade" id="matches" role="tabpanel">
                    <div class="matches-list" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                        <!-- Матчи будут добавлены динамически -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/skinview3d@latest/bundles/skinview3d.bundle.js"></script>
    <script src="settings.js"></script>
    <script>
        // Данные о рангах
        const ranksData = {
            "PLAYER": { name: "Игрок", colors: [] },
            "VIP": { name: "VIP", colors: ["3dff80"] },
            "PREMIUM": { name: "Premium", colors: ["3decff"] },
            "HOLY": { name: "Holy", colors: ["fff8a9", "ffa317"] },
            "IMMORTAL": { name: "Immortal", colors: ["ff70d1", "ff5d6d"] },
            "DIVINE": { name: "Divine", colors: ["b451ff", "84b5ff"] },
            "THANE": { name: "Thane", colors: ["30ff87", "1cffe4", "3594ff"] },
            "ELITE": { name: "Elite", colors: ["ffa51e", "ff5619", "ff314a"] },
            "ETERNAL": { name: "Eternal", colors: ["2688ed", "8b00d7", "ff4161"] },
            "VIME": { name: "Vime", colors: ["2599d4", "1d7cab"] },
            "JRBUILDER": { name: "Мл. Билдер", colors: ["bdecb6", "67ff54"] },
            "BUILDER": { name: "Билдер", colors: ["67ff54", "57c22d"] },
            "SRBUILDER": { name: "Ст. Билдер", colors: ["57c22d", "55961a"] },
            "MAPLEAD": { name: "Гл. Билдер", colors: ["55961a", "3f6e13"] },
            "YOUTUBE": { name: "Media", colors: ["bf2dff", "f33fd7"] },
            "DEV": { name: "Разработчик", colors: ["d61753"] },
            "ORGANIZER": { name: "Организатор", colors: ["0d83ae", "00c0eb"] },
            "HELPER": { name: "Хелпер", colors: ["76a6ff"] },
            "MODER": { name: "Модератор", colors: ["4e62eb"] },
            "WARDEN": { name: "Пр. Модератор", colors: ["3c36de"] },
            "CHIEF": { name: "Админ", colors: ["ff5e43", "db2100"] },
            "ADMIN": { name: "Гл. Админ", colors: ["ff2030", "d40048", "c1006b"] },
            "ABSOLUTE": { name: "Absolute", colors: ["f200ff", "972a6e", "632f59", "dd57bc"] },
            "IMPERIAL": { name: "Imperial", colors: ["fdbd05", "ffa630", "fffabd", "fdbd05"] },
            "CELESTIAL": { name: "Celestial", colors: ["e0f3ff", "bfdfff", "96c6ff", "6895d6"] },
            "ULTIMATE": { name: "Ultimate", colors: ["4f4f4f", "737272", "fbf7ff", "3a3a3a"] }
        };

            document.getElementById('auth-key-btn').onclick = function() {
            window.location.href = 'auth.html';
        };


        /* Добавляем функционал недавних ников в навигации */
        const MAX_RECENT_NICKS_NAV = 5;
        const quickSearchInput = document.getElementById('quick-search');
        const quickRecentNicks = document.getElementById('quickRecentNicks');
        const quickRecentNicksList = quickRecentNicks.querySelector('.recent-nicks-list');

        // Загрузка недавних никнеймов из localStorage для навигации
        function loadQuickRecentNicks() {
            const nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
            updateQuickRecentNicksList(nicks);
        }

        // Сохранение никнейма в localStorage для навигации
function saveQuickNick(nick) {
    // Получаем оригинальный никнейм из API
    fetch(`https://api.vimeworld.com/user/name/${nick}`)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const originalUsername = data[0].username;
                let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                // Удаляем все совпадения по нижнему регистру
                nicks = nicks.filter(n => n.toLowerCase() !== originalUsername.toLowerCase());
                nicks.unshift(originalUsername); // Добавляем оригинальный ник из API
                nicks = nicks.slice(0, MAX_RECENT_NICKS_NAV);
                localStorage.setItem('recentNicks', JSON.stringify(nicks));
                updateQuickRecentNicksList(nicks);
            }
        })
        .catch(error => {
            console.error('Ошибка при получении оригинального никнейма:', error);
            // Если не удалось получить оригинальный никнейм, сохраняем введенный
            let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
            nicks = nicks.filter(n => n.toLowerCase() !== nick.toLowerCase());
            nicks.unshift(nick);
            nicks = nicks.slice(0, MAX_RECENT_NICKS_NAV);
            localStorage.setItem('recentNicks', JSON.stringify(nicks));
            updateQuickRecentNicksList(nicks);
        });
}

        // Обновление списка недавних никнеймов для навигации
        function updateQuickRecentNicksList(nicks) {
            quickRecentNicksList.innerHTML = '';
            nicks.forEach(nick => {
                const li = document.createElement('li');
                
                // Создаем контейнер для головы
                const headContainer = document.createElement('div');
                headContainer.style.position = 'relative';
                headContainer.style.width = '25px';
                headContainer.style.height = '25px';
                
                // Добавляем базовую голову
                const head = document.createElement('img');
                head.src = `https://skin.vimeworld.com/head/${nick}.png`;
                head.className = 'mini-head';
                head.alt = '';
                headContainer.appendChild(head);
                
                // Добавляем оверлей головы
                const skinFullUrl = `https://skin.vimeworld.com/raw/skin/${nick}.png`;
                const skinFullImg = new Image();
                skinFullImg.crossOrigin = "Anonymous";
                skinFullImg.src = skinFullUrl;
                
                skinFullImg.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Определяем размер скина и рассчитываем масштабирование
                    const skinResolution = skinFullImg.width;
                    const scale = skinResolution / 64;
                    
                    // Координаты и размер оверлея головы
                    const baseOverlayX = 40;
                    const baseOverlayY = 8;
                    const baseOverlaySize = 8;
                    
                    // Масштабируем координаты и размер
                    const scaledOverlayX = baseOverlayX * scale;
                    const scaledOverlayY = baseOverlayY * scale;
                    const scaledOverlaySize = baseOverlaySize * scale;
                    
                    canvas.width = scaledOverlaySize;
                    canvas.height = scaledOverlaySize;
                    
                    // Вырезаем оверлей головы
                    ctx.drawImage(skinFullImg, scaledOverlayX, scaledOverlayY, scaledOverlaySize, scaledOverlaySize, 0, 0, scaledOverlaySize, scaledOverlaySize);
                    
                    // Создаем изображение из canvas и добавляем на страницу
                    const overlayImg = document.createElement('img');
                    overlayImg.src = canvas.toDataURL();
                    overlayImg.alt = `${nick} head overlay`;
                    overlayImg.className = 'mini-head-overlay';
                    headContainer.appendChild(overlayImg);
                };
                
                // Создаем контейнер для ника и статуса
                const nickContainer = document.createElement('div');
                nickContainer.style.display = 'flex';
                nickContainer.style.alignItems = 'center';
                nickContainer.style.gap = '4px';
                
                // Ник
                const nickSpan = document.createElement('span');
                nickSpan.textContent = nick;
                nickSpan.style.color = '#2c3e50';
                nickContainer.appendChild(nickSpan);
                
                // Добавляем индикатор онлайн-статуса
                const onlineStatus = document.createElement('div');
                onlineStatus.className = 'online-status unknown';
                nickContainer.appendChild(onlineStatus);
                
                li.appendChild(headContainer);
                li.appendChild(nickContainer);
                
                // Проверяем кеш перед запросом к API
                const cachedData = getPlayerData(nick);
                if (cachedData) {
                    // Применяем кешированные данные
                    if (cachedData.customColors && cachedData.customColors.length > 0) {
                        if (cachedData.customColors.length === 1) {
                            nickSpan.style.color = `#${cachedData.customColors[0]}`;
                        } else {
                            const gradient = `linear-gradient(to right, ${cachedData.customColors.map(color => `#${color}`).join(', ')})`;
                            nickSpan.style.background = gradient;
                            nickSpan.style.webkitBackgroundClip = 'text';
                            nickSpan.style.webkitTextFillColor = 'transparent';
                        }
                    }
                    
                    // Добавляем ранг из кеша
                    const mainRank = cachedData.rank || "PLAYER";
                    const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                    if (mainRank !== "PLAYER") {
                        const rank = document.createElement('span');
                        rank.className = 'player-rank';
                        rank.textContent = rankInfo.name;
                        
                        if (rankInfo.colors && rankInfo.colors.length > 0) {
                            if (rankInfo.colors.length === 1) {
                                rank.style.background = `#${rankInfo.colors[0]}`;
                                rank.style.color = '#fff';
                            } else {
                                const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                                rank.style.background = gradient;
                                rank.style.color = '#fff';
                            }
                        }
                        
                        li.appendChild(rank);
                    }
                }
                
                // Получаем актуальные данные с API
                fetch(`https://api.vimeworld.com/user/name/${nick}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            const player = data[0];
                            // Сохраняем данные в кеш
                            savePlayerData(nick, {
                                rank: player.rank || "PLAYER",
                                customColors: player.customColors || [],
                                username: player.username
                            });
                            
                            // Применяем кастомные цвета к никнейму
                            if (player.customColors && player.customColors.length > 0) {
                                if (player.customColors.length === 1) {
                                    nickSpan.style.color = `#${player.customColors[0]}`;
                                } else {
                                    const gradient = `linear-gradient(to right, ${player.customColors.map(color => `#${color}`).join(', ')})`;
                                    nickSpan.style.background = gradient;
                                    nickSpan.style.webkitBackgroundClip = 'text';
                                    nickSpan.style.webkitTextFillColor = 'transparent';
                                }
                            }
                            
                            // Добавляем ранг после статуса только если его еще нет
                            const mainRank = player.rank || "PLAYER";
                            const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                            if (mainRank !== "PLAYER" && !li.querySelector('.player-rank')) {
                                const rank = document.createElement('span');
                                rank.className = 'player-rank';
                                rank.textContent = rankInfo.name;
                                
                                if (rankInfo.colors && rankInfo.colors.length > 0) {
                                    if (rankInfo.colors.length === 1) {
                                        rank.style.background = `#${rankInfo.colors[0]}`;
                                        rank.style.color = '#fff';
                                    } else {
                                        const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                                        rank.style.background = gradient;
                                        rank.style.color = '#fff';
                                    }
                                }
                                
                                li.appendChild(rank);
                            }
                            
                            // Проверяем онлайн-статус
                            fetch(`https://api.vimeworld.com/user/name/${nick}/session`)
                                .then(response => {
                                    if (!response.ok) {
                                        throw new Error('Network response was not ok');
                                    }
                                    return response.json();
                                })
                                .then(sessionData => {
                                    if (sessionData && sessionData.online) {
                                        onlineStatus.className = 'online-status ' + (sessionData.online.value ? 'online' : 'offline');
                                    } else {
                                        onlineStatus.className = 'online-status unknown';
                                    }
                                })
                                .catch(error => {
                                    console.error('Ошибка при получении онлайн-статуса:', error);
                                    onlineStatus.className = 'online-status unknown';
                                });
                        }
                    })
                    .catch(error => {
                        console.error('Ошибка при получении данных игрока:', error);
                        if (!cachedData) {
                            nickSpan.style.color = '#2c3e50';
                        }
                    });
                
                li.addEventListener('click', () => {
                    quickSearchInput.value = nick;
                    quickRecentNicks.classList.remove('active');
                    getOriginalNameAndRedirect(nick);
                });
                quickRecentNicksList.appendChild(li);
            });
        }

        // Показ/скрытие выпадающего окна для недавних ников в навигации
        quickSearchInput.addEventListener('focus', () => {
            if (quickRecentNicksList.children.length > 0) {
                quickRecentNicks.classList.add('active');
            }
        });
        quickSearchInput.addEventListener('input', () => {
             if (quickRecentNicksList.children.length > 0 && quickSearchInput.value.trim() === '') {
                quickRecentNicks.classList.add('active');
            } else {
                quickRecentNicks.classList.remove('active');
            }
        });
        quickSearchInput.addEventListener('blur', () => {
            setTimeout(() => quickRecentNicks.classList.remove('active'), 150);
        });

        // Функция для получения оригинального никнейма и перехода на страницу игрока
function getOriginalNameAndRedirect(inputName) {
    if (!inputName.trim()) return;
    
    // Показываем индикатор загрузки
    quickSearchInput.disabled = true;
    
    // Проверяем, является ли запрос поиском по ID
    const lowerInputName = inputName.toLowerCase();
    if (lowerInputName.startsWith('id:')) {
        const playerId = inputName.slice(3).trim();
        
        // Проверяем, что после "id:" есть только цифры
        if (!/^\d+$/.test(playerId)) {
            alert('После "id:" должны быть только цифры');
            quickSearchInput.disabled = false;
            return;
        }
        
        // Получаем данные игрока по ID
        fetch(`https://api.vimeworld.com/user/${playerId}`)
            .then(response => response.json())
            .then(data => {
                if (data && data.length > 0) {
                    const player = data[0];
                    const originalUsername = player.username;
                    
                    // Сохраняем в историю
                    let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                    nicks = nicks.filter(n => n.toLowerCase() !== originalUsername.toLowerCase());
                    nicks.unshift(originalUsername);
                    nicks = nicks.slice(0, MAX_RECENT_NICKS_NAV);
                    localStorage.setItem('recentNicks', JSON.stringify(nicks));
                    updateQuickRecentNicksList(nicks);
                    
                    // Перенаправляем на страницу игрока
                    window.location.href = `player.html?username=${encodeURIComponent(originalUsername)}`;
                } else {
                    alert('Игрок с таким ID не найден');
                }
            })
            .catch(error => {
                console.error('Ошибка при получении данных игрока по ID:', error);
                alert('Произошла ошибка при поиске игрока по ID');
            })
            .finally(() => {
                quickSearchInput.disabled = false;
            });
    } else {
        // Обычный поиск по никнейму
        fetch(`https://api.vimeworld.com/user/name/${inputName}`)
            .then(response => response.json())
            .then(data => {
                if (data && data.length > 0) {
                    const originalUsername = data[0].username;
                    let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                    nicks = nicks.filter(n => n.toLowerCase() !== originalUsername.toLowerCase());
                    nicks.unshift(originalUsername);
                    nicks = nicks.slice(0, MAX_RECENT_NICKS_NAV);
                    localStorage.setItem('recentNicks', JSON.stringify(nicks));
                    updateQuickRecentNicksList(nicks);
                    
                    // Перенаправляем на страницу с оригинальным никнеймом
                    window.location.href = `player.html?username=${encodeURIComponent(originalUsername)}`;
                } else {
                    // Если игрок не найден, не показываем alert, чтобы избежать двойных сообщений
                    console.log('Игрок не найден');
                }
            })
            .catch(error => {
                console.error('Ошибка при получении оригинального никнейма:', error);
                // В случае ошибки показываем сообщение
                alert('Произошла ошибка при поиске игрока');
            })
            .finally(() => {
                quickSearchInput.disabled = false;
            });
    }
}

// Обновляем обработчик Enter для сохранения ника
quickSearchInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        const username = this.value.trim();
        if (username) {
            getOriginalNameAndRedirect(username);
        }
    }
});

// Обновляем обработчик клика по лупе для сохранения ника
document.getElementById('quick-search-btn').onclick = function() {
    const username = quickSearchInput.value.trim();
    if (username) {
        getOriginalNameAndRedirect(username);
    }
};

        // Загружаем недавние никнеймы для навигации при загрузке страницы
        loadQuickRecentNicks();

        // Получаем никнейм из URL
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username');
        
        if (!username) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = 'Никнейм не указан';
        } else {
            // Функция для форматирования времени игры
            function formatPlaytime(seconds, full = false) {
                const days = Math.floor(seconds / (3600 * 24));
                const hours = Math.floor((seconds % (3600 * 24)) / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;

                // Функция для получения правильного окончания
                function getEnding(number, endings) {
                    if (number === 0) return endings[2];
                    const lastDigit = number % 10;
                    const lastTwoDigits = number % 100;
                    
                    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
                        return endings[2];
                    }
                    
                    if (lastDigit === 1) {
                        return endings[0];
                    }
                    
                    if (lastDigit >= 2 && lastDigit <= 4) {
                        return endings[1];
                    }
                    
                    return endings[2];
                }

                if (!full) {
                    if (days > 0) return `${days} ${getEnding(days, ['день', 'дня', 'дней'])}`;
                    if (hours > 0) return `${hours} ${getEnding(hours, ['час', 'часа', 'часов'])}`;
                    if (minutes > 0) return `${minutes} ${getEnding(minutes, ['минута', 'минуты', 'минут'])}`;
                    return `${remainingSeconds} ${getEnding(remainingSeconds, ['секунда', 'секунды', 'секунд'])}`;
                }

                let result = '';
                if (days > 0) result += `${days} ${getEnding(days, ['день', 'дня', 'дней'])} `;
                if (hours > 0 || days > 0) result += `${hours} ${getEnding(hours, ['час', 'часа', 'часов'])} `;
                if (minutes > 0 || hours > 0 || days > 0) result += `${minutes} ${getEnding(minutes, ['минута', 'минуты', 'минут'])} `;
                result += `${remainingSeconds} ${getEnding(remainingSeconds, ['секунда', 'секунды', 'секунд'])}`;

                return result.trim();
            }

            // Функция для форматирования Unix timestamp
            function formatUnixTimestamp(timestamp) {
                if (!timestamp || timestamp === -1) return 'неизвестно';
                
                const date = new Date(timestamp * 1000); // Конвертируем в миллисекунды
                
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                
                return `${day}.${month}.${year} ${hours}:${minutes}:${seconds}`;
            }

            // Функция для конвертации цветовых кодов Minecraft в HTML цвета
            function convertMinecraftColors(text) {
                const colorMap = {
                    '&0': '#000000', // Черный
                    '&1': '#0000AA', // Темно-синий
                    '&2': '#00AA00', // Темно-зеленый
                    '&3': '#00AAAA', // Темно-бирюзовый
                    '&4': '#AA0000', // Темно-красный
                    '&5': '#AA00AA', // Темно-пурпурный
                    '&6': '#FFAA00', // Золотой
                    '&7': '#AAAAAA', // Серый
                    '&8': '#555555', // Темно-серый
                    '&9': '#5555FF', // Синий
                    '&a': '#55FF55', // Зеленый
                    '&b': '#55FFFF', // Бирюзовый
                    '&c': '#FF5555', // Красный
                    '&d': '#FF55FF', // Пурпурный
                    '&e': '#FFFF55', // Желтый
                    '&f': '#FFFFFF', // Белый
                    '&l': 'font-weight: bold;', // Жирный
                    '&n': 'text-decoration: underline;', // Подчеркнутый
                    '&o': 'font-style: italic;', // Курсив
                    '&k': 'text-decoration: line-through;', // Зачеркнутый
                    '&r': 'color: inherit; font-weight: normal; text-decoration: none; font-style: normal;' // Сброс форматирования
                };

                let result = text;
                for (const [code, style] of Object.entries(colorMap)) {
                    const regex = new RegExp(code, 'g');
                    if (style.startsWith('#')) {
                        // Добавляем тень для белого цвета (&f)
                        if (code === '&f') {
                            result = result.replace(regex, `<span style="color: ${style}; text-shadow: 0px 0px 2px rgba(0,0,0,0.3);">`);
                        } else {
                            result = result.replace(regex, `<span style="color: ${style}">`);
                        }
                    } else {
                        result = result.replace(regex, `<span style="${style}">`);
                    }
                }
                return result;
            }

            // Добавляем функции для работы с кешем
            function savePlayerData(nick, data) {
                const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
                playerCache[nick] = {
                    ...data,
                    timestamp: Date.now()
                };
                localStorage.setItem('playerCache', JSON.stringify(playerCache));
            }

            function getPlayerData(nick) {
                const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
                return playerCache[nick];
            }

            // Функция для обновления статуса игрока из данных сессии
            function updatePlayerStatusFromData(sessionData) {
                const playerStatus = document.getElementById('player-status');
                
                // Очищаем содержимое перед обновлением
                playerStatus.innerHTML = '';
                
                if (sessionData.online && sessionData.online.value) {
                    playerStatus.classList.add('online');
                    playerStatus.classList.remove('offline');
                    const statusTextSpan = document.createElement('span');
                    const message = sessionData.online.message || 'Онлайн';
                    statusTextSpan.textContent = message.replace(/^(Играет|Находится) (в|на) /, '');
                    statusTextSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    statusTextSpan.style.fontWeight = 'normal';
                    statusTextSpan.style.fontSize = '0.8rem';
                    playerStatus.appendChild(statusTextSpan);
                    
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'status-icon-square';
                    playerStatus.appendChild(statusIndicator);
                } else {
                    playerStatus.classList.add('offline');
                    playerStatus.classList.remove('online');
                    const statusTextSpan = document.createElement('span');
                    statusTextSpan.textContent = 'Оффлайн';
                    statusTextSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    statusTextSpan.style.fontWeight = 'normal';
                    statusTextSpan.style.fontSize = '0.8rem';
                    playerStatus.appendChild(statusTextSpan);
                    
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'status-icon-square';
                    playerStatus.appendChild(statusIndicator);
                }
            }
            
            // Функция для обновления статуса игрока через новый запрос
            async function updatePlayerStatus() {
                try {
                    const sessionResponse = await fetch(`https://api.vimeworld.com/user/name/${username}/session`);
                    const sessionData = await sessionResponse.json();
                    updatePlayerStatusFromData(sessionData);
                } catch (error) {
                    console.error('Ошибка при обновлении статуса:', error);
                }
            }

            // Загрузка всех данных игрока параллельно
            async function loadPlayerData() {
                try {
                    // Делаем запросы к API параллельно
                    const [playerResponse, sessionResponse, statsResponse] = await Promise.all([
                        fetch(`https://api.vimeworld.com/user/name/${username}`),
                        fetch(`https://api.vimeworld.com/user/name/${username}/session`),
                        fetch(`https://api.vimeworld.com/user/name/${username}/stats`)
                    ]);
                    
                    // Запрос к friends делаем только при переключении на вкладку
                    
                    // Обрабатываем ответы параллельно
                    const [playerData, sessionData, statsData] = await Promise.all([
                        playerResponse.json(),
                        sessionResponse.json(),
                        statsResponse.json()
                    ]);

                    if (playerData.length === 0) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').style.display = 'block';
                        return;
                    }

                    const player = playerData[0];
                    const playerRankElement = document.getElementById('player-rank');
                    const rankBadgeElement = playerRankElement.closest('.rank-badge');
                    const primeBadgeElement = document.getElementById('prime-badge');
                    const additionalRanksContainer = document.querySelector('.additional-ranks');
                    additionalRanksContainer.innerHTML = '';

                    // Обновляем статус игрока на основе полученных данных сессии
                    updatePlayerStatusFromData(sessionData);

                    // Запускаем периодическое обновление статуса
                    setInterval(updatePlayerStatus, 10000); // Обновляем каждые 10 секунд

                    // Обновляем информацию о ранге
                    const mainRank = player.rank || "PLAYER";
                    const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                    playerRankElement.textContent = rankInfo.name;

                    // Устанавливаем цвет текста основного ранга в белый и фон обертки
                    playerRankElement.style.color = '#fff';
                    playerRankElement.style['-webkit-background-clip'] = '';
                    playerRankElement.style['-webkit-text-fill-color'] = '';

                    if (rankInfo.colors.length > 0) {
                        if (rankInfo.colors.length === 1) {
                            rankBadgeElement.style.background = `#${rankInfo.colors[0]}`;
                        } else {
                            const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                            rankBadgeElement.style.background = gradient;
                        }
                         rankBadgeElement.style.display = 'inline-block';
                    } else {
                         rankBadgeElement.style.display = 'none';
                    }

                    // Отображаем Prime статус
                    if (player.prime) {
                        primeBadgeElement.style.display = 'inline-block';
                        
                        // Добавляем tooltip с датой приобретения Prime
                        if (player.primeStart) {
                            // Удаляем старый tooltip если есть
                            const oldTooltip = primeBadgeElement.querySelector('.prime-tooltip');
                            if (oldTooltip) {
                                oldTooltip.remove();
                            }
                            
                            // Создаем новый tooltip
                            const tooltip = document.createElement('span');
                            tooltip.classList.add('prime-tooltip');
                            
                            // Конвертируем Unix timestamp в дату
                            const primeDate = new Date(player.primeStart * 1000);
                            const day = String(primeDate.getDate()).padStart(2, '0');
                            const month = String(primeDate.getMonth() + 1).padStart(2, '0');
                            const year = primeDate.getFullYear();
                            const hours = String(primeDate.getHours()).padStart(2, '0');
                            const minutes = String(primeDate.getMinutes()).padStart(2, '0');
                            const seconds = String(primeDate.getSeconds()).padStart(2, '0');
                            
                            tooltip.textContent = `Подписка действует с ${day}.${month}.${year} ${hours}:${minutes}:${seconds}`;
                            primeBadgeElement.appendChild(tooltip);
                        }
                    } else {
                        primeBadgeElement.style.display = 'none';
                    }

                    // Добавляем дополнительные ранги
                    if (player.ranks && player.ranks.length > 0) {
                        player.ranks.forEach(rank => {
                            // Проверяем, не является ли это основным рангом
                            if (rank !== mainRank) {
                                const additionalRankBadge = document.createElement('span');
                                additionalRankBadge.classList.add('additional-rank-badge');
                                // Используем полное название ранга из ranksData, если доступно
                                const additionalRankInfo = ranksData[rank] || { name: rank, colors: [] }; // Получаем информацию о дополнительном ранге, включая цвета
                                additionalRankBadge.textContent = additionalRankInfo.name;

                                // Применяем цвета из ranksData к фону
                                if (additionalRankInfo.colors && additionalRankInfo.colors.length > 0) {
                                    if (additionalRankInfo.colors.length === 1) {
                                        // Один цвет
                                        additionalRankBadge.style.background = `#${additionalRankInfo.colors[0]}`;
                                    } else {
                                        // Несколько цветов - создаем градиент
                                        const gradient = `linear-gradient(to right, ${additionalRankInfo.colors.map(color => `#${color}`).join(', ')})`;
                                        additionalRankBadge.style.background = gradient;
                                    }
                                } else {
                                    // Если цветов нет, можно использовать дефолтный фон или скрыть
                                    // В данном случае оставим дефолтный фон из CSS (сине-белый градиент)
                                }

                                // Текст дополнительных рангов всегда белый
                                additionalRankBadge.style.color = '#fff';

                                additionalRanksContainer.appendChild(additionalRankBadge);
                            }
                        });
                    }

                    // Обновляем остальную информацию на странице
                    const playerNameElement = document.getElementById('player-name');
                    
                    // Добавляем префикс, если он есть
                    if (player.prefix) {
                        const prefixSpan = document.createElement('span');
                        prefixSpan.textContent = `[${player.prefix}]`;
                        prefixSpan.style.marginRight = '0';
                        // Устанавливаем цвет префикса в соответствии с первым цветом ранга
                        const mainRank = player.rank || "PLAYER";
                        const rankInfo = ranksData[mainRank] || ranksData["PLAYER"];
                        if (rankInfo.colors && rankInfo.colors.length > 0) {
                            prefixSpan.style.color = `#${rankInfo.colors[0]}`;
                        } else {
                            prefixSpan.style.color = '#7f8c8d'; // Дефолтный серый цвет, если у ранга нет цветов
                        }
                        prefixSpan.style.fontSize = '1.8rem';
                        playerNameElement.parentNode.insertBefore(prefixSpan, playerNameElement);
                    }
                    
                    playerNameElement.textContent = player.username;
                    
                    // Делаем никнейм кликабельным для открытия истории ников
                    playerNameElement.style.cursor = 'pointer';
                    playerNameElement.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                    playerNameElement.title = 'Нажмите, чтобы посмотреть историю ников';
                    
                    playerNameElement.onclick = function(e) {
                        e.stopPropagation();
                        showNickHistoryTooltip(player.id, this);
                    };
                    
                    // Добавляем primeIcon после никнейма, если он есть
                    if (player.primeIcon) {
                        const primeIconSpan = document.createElement('span');
                        primeIconSpan.innerHTML = convertMinecraftColors(player.primeIcon);
                        primeIconSpan.style.marginLeft = '4px';
                        primeIconSpan.style.fontSize = '1.4rem'; // Немного меньше чем никнейм
                        // Вставляем после элемента с именем, а не внутрь него
                        playerNameElement.parentNode.insertBefore(primeIconSpan, playerNameElement.nextSibling);
                    }
                    
                    // Применяем кастомные цвета к никнейму, если они есть
                    if (player.customColors && player.customColors.length > 0) {
                        if (player.customColors.length === 1) {
                            playerNameElement.style.color = `#${player.customColors[0]}`;
                        } else {
                            const gradient = `linear-gradient(to right, ${player.customColors.map(color => `#${color}`).join(', ')})`;
                            playerNameElement.style.background = gradient;
                            playerNameElement.style.webkitBackgroundClip = 'text';
                            playerNameElement.style.webkitTextFillColor = 'transparent';
                        }
                    } else {
                        // Сбрасываем стили к дефолтным, если кастомных цветов нет
                        playerNameElement.style.color = '#2c3e50'; /* Черный цвет по умолчанию */
                        playerNameElement.style.background = '';
                        playerNameElement.style.webkitBackgroundClip = '';
                        playerNameElement.style.webkitTextFillColor = '';
                    }

                    document.getElementById('player-id').textContent = `id: ${player.id}`;
                    
                    // Обновляем информацию об уровне (без процента)
                    document.getElementById('player-level-meta').textContent = `Уровень: ${player.level}`;
                    
                    // Функция для расчета опыта для уровня
                    function calculateXPForLevel(level) {
                        if (level <= 1) return 8000;
                        if (level === 2) return 10000;
                        if (level === 3) return 12000;
                        return 8000 + (level - 1) * 2000;
                    }
                    
                    // Рассчитываем необходимый опыт для текущего уровня
                    const requiredXP = calculateXPForLevel(player.level);
                    const currentXP = Math.floor(player.levelPercentage * requiredXP);
                    const progressPercent = Math.floor(player.levelPercentage * 100);
                    
                    // Обновляем текст опыт-бара
                    const experienceText = document.getElementById('experience-text');
                    if (experienceText) {
                        experienceText.textContent = `${progressPercent}% - ${currentXP} / ${requiredXP} XP`;
                    }
                    
                    // Обновляем информацию о оставшемся опыте справа
                    const experienceRemain = document.getElementById('experience-remain');
                    if (experienceRemain) {
                        const remainXP = requiredXP - currentXP;
                        experienceRemain.textContent = `${remainXP} XP`;
                    }
                    
                    // Обновляем полосу прогресса опыта
                    const experienceProgress = document.getElementById('experience-progress');
                    if (experienceProgress && player.levelPercentage !== undefined) {
                        experienceProgress.style.width = `${progressPercent}%`;
                    }

                    const playtimeHeaderSpan = document.getElementById('player-playtime-header');
                    const playtimeContainer = playtimeHeaderSpan.parentElement; // Получаем родительский div.status-item

                    playtimeHeaderSpan.textContent = formatPlaytime(player.playedSeconds);

                    // Создаем и добавляем элемент для отображения полного времени при наведении
                    const fullPlaytimeSpan = document.createElement('span');
                    fullPlaytimeSpan.classList.add('full-playtime-tooltip');
                    // Стили для fullPlaytimeSpan определены в CSS классе .full-playtime-tooltip
                    fullPlaytimeSpan.style.fontFamily = 'VimeArtBold, sans-serif';
                    fullPlaytimeSpan.style.fontSize = '0.8rem';
                    fullPlaytimeSpan.style.color = '#7f8c8d';
                    fullPlaytimeSpan.style.fontWeight = 'normal'; // Убираем жирность

                    playtimeContainer.appendChild(fullPlaytimeSpan);

                    // Получаем кликабельный элемент для "Наиграно" (уточняем селектор)
                    const playtimeTriggerSpan = document.querySelector('.status-item:has(#player-playtime-header) .playtime-trigger');

                    // Добавляем обработчик клика, если элемент найден
                    if (playtimeTriggerSpan) {
                        // Находим всплывающее окно внутри того же контейнера status-item
                        const fullPlaytimeSpan = playtimeTriggerSpan.closest('.status-item').querySelector('.full-playtime-tooltip');
                        // Удаляем зависимость от lastSeenContainer

                        if (fullPlaytimeSpan) {
                            // Скрываем полное время по умолчанию
                            fullPlaytimeSpan.style.opacity = '0';

                            // Добавляем обработчик клика
                            playtimeTriggerSpan.style.cursor = 'pointer'; // Добавляем курсор-указатель
                            playtimeTriggerSpan.addEventListener('click', () => {
                                const isHidden = fullPlaytimeSpan.style.opacity === '0' || fullPlaytimeSpan.style.display === 'none';
                                // Находим блок с последним входом
                                const lastSeenContainer = document.querySelector('.status-item:has(#player-last-seen)');
                                
                                if (isHidden) {
                                    // Обеспечиваем корректное отображение перед показом
                                    fullPlaytimeSpan.style.display = '';
                                    // Скрываем блок с последним входом
                                    if (lastSeenContainer) {
                                        lastSeenContainer.style.display = 'none';
                                    }
                                    // Используем setTimeout, чтобы изменение display применилось перед установкой opacity
                                    setTimeout(() => {
                                        fullPlaytimeSpan.textContent = formatPlaytime(player.playedSeconds, true);
                                        fullPlaytimeSpan.style.opacity = '1';
                                    }, 10);
                                } else {
                                    // Полностью скрываем информацию используя функцию hideFullPlaytime
                                    hideFullPlaytime();
                                    // Показываем блок с последним входом обратно
                                    if (lastSeenContainer) {
                                        lastSeenContainer.style.display = '';
                                    }
                                }
                            });

                            // Функция полного сброса и скрытия всплывающего окна
                            const hideFullPlaytime = () => {
                                fullPlaytimeSpan.style.opacity = '0';
                                fullPlaytimeSpan.textContent = ''; // Очищаем содержимое
                                fullPlaytimeSpan.style.display = 'none'; // Полностью скрываем элемент
                                
                                // Показываем блок с последним входом
                                const lastSeenContainer = document.querySelector('.status-item:has(#player-last-seen)');
                                if (lastSeenContainer) {
                                    lastSeenContainer.style.display = '';
                                }
                                
                                // Через небольшую задержку возвращаем display для будущих показов
                                setTimeout(() => {
                                    fullPlaytimeSpan.style.display = ''; // Восстанавливаем display
                                }, 200);
                            };

                            // Создаем уникальный идентификатор для обработчика
                            const clickHandlerId = 'playtime_click_handler_' + Date.now();
                            
                            // Добавляем обработчик на document для скрытия при клике вне блока
                            const documentClickHandler = function(event) {
                                if (!playtimeTriggerSpan.contains(event.target) && !fullPlaytimeSpan.contains(event.target)) {
                                    hideFullPlaytime();
                                    // После срабатывания удаляем обработчик, чтобы он больше не влиял на страницу
                                    document.removeEventListener('click', documentClickHandler);
                                }
                            };
                            
                            // Устанавливаем обработчик только когда открывается всплывающее окно
                            playtimeTriggerSpan.addEventListener('click', function() {
                                // Добавляем обработчик с задержкой, чтобы он не сработал сразу же на текущем клике
                                setTimeout(() => {
                                    if (fullPlaytimeSpan.style.opacity === '1') {
                                        document.addEventListener('click', documentClickHandler);
                                    }
                                }, 50);
                            });

                            // Обработчик нажатия клавиши ESC для скрытия
                            const escKeyHandler = function(event) {
                                if (event.key === 'Escape') {
                                    hideFullPlaytime();
                                    // Удаляем обработчик после срабатывания
                                    document.removeEventListener('keydown', escKeyHandler);
                                }
                            };
                            
                            // Устанавливаем обработчик ESC только когда открывается всплывающее окно
                            playtimeTriggerSpan.addEventListener('click', function() {
                                // Добавляем обработчик с задержкой
                                setTimeout(() => {
                                    if (fullPlaytimeSpan.style.opacity === '1') {
                                        document.addEventListener('keydown', escKeyHandler);
                                    }
                                }, 50);
                            });
                        }
                    }

                    document.getElementById('player-friends').textContent = '0';
                    
                    // Обновляем информацию о гильдии
                    const playerGuildElement = document.getElementById('player-guild');
                    if (player.guild) {
                        // Создаем элемент для отображения гильдии
                        let guildText = '';
                        
                        // Добавляем тег гильдии, если он есть
                        if (player.guild.tag && player.guild.tag.trim() !== '') {
                            // Добавляем серые скобки и тег с нужным цветом
                            guildText += '<span style="color: #AAAAAA">&lt;</span>';
                            
                            // Определяем цвет тега
                            let tagColor = '#7f8c8d'; // Цвет по умолчанию
                            if (player.guild.color && player.guild.color.startsWith('&')) {
                                const colorCode = player.guild.color;
                                const colorMap = {
                                    '&0': '#000000', // Черный
                                    '&1': '#0000AA', // Темно-синий
                                    '&2': '#00AA00', // Темно-зеленый
                                    '&3': '#00AAAA', // Темно-бирюзовый
                                    '&4': '#AA0000', // Темно-красный
                                    '&5': '#AA00AA', // Темно-пурпурный
                                    '&6': '#FFAA00', // Золотой
                                    '&7': '#AAAAAA', // Серый
                                    '&8': '#555555', // Темно-серый
                                    '&9': '#5555FF', // Синий
                                    '&a': '#55FF55', // Зеленый
                                    '&b': '#55FFFF', // Бирюзовый
                                    '&c': '#FF5555', // Красный
                                    '&d': '#FF55FF', // Пурпурный
                                    '&e': '#FFFF55', // Желтый
                                    '&f': '#FFFFFF'  // Белый
                                };
                                if (colorMap[colorCode]) {
                                    tagColor = colorMap[colorCode];
                                    // Добавляем тень для белого цвета (&f)
                                    if (colorCode === '&f') {
                                        guildText += `<span style="color: ${tagColor}; text-shadow: 0px 0px 2px rgba(0,0,0,0.3); font-weight: bold;">${player.guild.tag}</span>`;
                                    } else {
                                        guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                                    }
                                } else {
                                    guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                                }
                            } else {
                                guildText += `<span style="color: ${tagColor}; font-weight: bold;">${player.guild.tag}</span>`;
                            }
                            
                            guildText += '<span style="color: #AAAAAA">&gt;</span> ';
                        }
                        
                        // Обрабатываем название гильдии с учетом форматирования Minecraft
                        let guildName = player.guild.name;
                        guildText += convertMinecraftColors(guildName);
                        
                        playerGuildElement.innerHTML = guildText;
                    } else {
                        playerGuildElement.textContent = 'Нет гильдии';
                    }
                    
                    document.getElementById('player-playtime-header').textContent = formatPlaytime(player.playedSeconds);
                    const lastSeenElement = document.getElementById('player-last-seen');
                    const lastSeenContainer = lastSeenElement.closest('.status-item');
                    lastSeenContainer.innerHTML = `
                        <span style="display: flex; align-items: center; gap: 4px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            <span class="playtime-label" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; margin-right: 4px; line-height: 1;">Последний вход:</span>
                            <span id="player-last-seen" style="font-family: 'VimeArtBold', sans-serif; font-weight: normal; font-size: 0.8rem; line-height: 1;">${formatUnixTimestamp(player.lastSeen)}</span>
                        </span>
                    `;

                    // Добавляем голову игрока
                    const playerAvatarDiv = document.getElementById('player-avatar');
                    playerAvatarDiv.innerHTML = ''; // Очищаем placeholder

                    // Добавляем обработчик клика для переключения на вкладку "Скин"
                    playerAvatarDiv.style.cursor = 'pointer';
                    playerAvatarDiv.addEventListener('click', () => {
                        const skinTab = document.getElementById('skin-tab');
                        const skinTabInstance = new bootstrap.Tab(skinTab);
                        skinTabInstance.show();
                    });

                    // Добавляем базовую голову
                    const playerHeadImg = document.createElement('img');
                    playerHeadImg.src = `https://skin.vimeworld.com/head/${player.username}.png`;
                    playerHeadImg.alt = `${player.username} head`;
                    playerHeadImg.classList.add('player-avatar-base');
                    playerAvatarDiv.appendChild(playerHeadImg);

                    // Добавляем оверлей головы из полного скина
                    const skinFullUrl = `https://skin.vimeworld.com/raw/skin/${player.username}.png`;
                    const skinFullImg = new Image();
                    skinFullImg.crossOrigin = "Anonymous"; // Важно для работы с canvas
                    skinFullImg.src = skinFullUrl;

                    skinFullImg.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Определяем размер скина и рассчитываем масштабирование
                        const skinResolution = skinFullImg.width; // Предполагаем квадратный скин
                        const scale = skinResolution / 64;

                        // Координаты и размер оверлея головы на стандартном скине (64x64)
                        const baseOverlayX = 40;
                        const baseOverlayY = 8;
                        const baseOverlaySize = 8;

                        // Масштабируем координаты и размер под текущее разрешение скина
                        const scaledOverlayX = baseOverlayX * scale;
                        const scaledOverlayY = baseOverlayY * scale;
                        const scaledOverlaySize = baseOverlaySize * scale;

                        canvas.width = scaledOverlaySize; // Размер оверлея головы
                        canvas.height = scaledOverlaySize;

                        // Вырезаем оверлей головы из масштабированного скина
                        ctx.drawImage(skinFullImg, scaledOverlayX, scaledOverlayY, scaledOverlaySize, scaledOverlaySize, 0, 0, scaledOverlaySize, scaledOverlaySize);

                        // Создаем изображение из canvas и добавляем на страницу
                        const overlayImg = document.createElement('img');
                        overlayImg.src = canvas.toDataURL();
                        overlayImg.alt = `${player.username} head overlay`;
                        // Применяем стили для оверлея
                        overlayImg.classList.add('player-avatar-overlay');
                         playerAvatarDiv.appendChild(overlayImg);
                    };

                    // Инициализация SkinViewer
                    const skinUrl = `https://skin.vimeworld.com/raw/skin/${player.username}.png`;
                    const capeUrl = `https://skin.vimeworld.com/raw/cape/${player.username}.png`;

                    const skinContainer = document.getElementById('skin3d-container');
                    skinContainer.innerHTML = ""; // очищаем
                    const viewer = new skinview3d.SkinViewer({
                        canvas: Object.assign(document.createElement("canvas"), { width: 480, height: 700 }),
                        width: 480,
                        height: 700,
                        skin: skinUrl,
                        cape: capeUrl,
                        background: '#ffffff',
                        lighting: true,
                        ambientLight: 0.5,
                        directionalLight: 0.8
                    });
                    skinContainer.appendChild(viewer.canvas);
                    viewer.controls.enableRotate = true;
                    viewer.controls.enableZoom = true;
                    viewer.controls.enablePan = false;
                    viewer.controls.autoRotate = false;
                    viewer.controls.autoRotateSpeed = 1.0;

                    // Инициализация анимации ходьбы
                    viewer.animation = new skinview3d.WalkingAnimation();
                    viewer.animation.speed = 1.2;

                    // Анимации
                    const walkAnimBtn = document.getElementById('toggleWalkAnimBtn');
                    const runAnimBtn = document.getElementById('toggleRunAnimBtn');

                    function resetAnimationButtons() {
                        [walkAnimBtn, runAnimBtn].forEach(btn => {
                            btn.classList.remove('active');
                        });
                    }

                    walkAnimBtn.onclick = function () {
                        if (walkAnimBtn.classList.toggle('active')) {
                            resetAnimationButtons();
                            walkAnimBtn.classList.add('active');
                            viewer.animation = new skinview3d.WalkingAnimation();
                            viewer.animation.speed = 1.2;
                        } else {
                            viewer.animation = null;
                        }
                    };

                    runAnimBtn.onclick = function () {
                        if (runAnimBtn.classList.toggle('active')) {
                            resetAnimationButtons();
                            runAnimBtn.classList.add('active');
                            viewer.animation = new skinview3d.RunningAnimation();
                            viewer.animation.speed = 0.8;
                        } else {
                            viewer.animation = null;
                        }
                    };

                    // Кнопки скачивания
                    document.getElementById('downloadSkinBtn').onclick = function (e) {
                        e.preventDefault();
                        downloadFile(skinUrl, `${player.username}.png`);
                    };
                    // Проверяем наличие плаща перед отображением кнопки скачивания плаща
                    fetch(capeUrl, { method: 'HEAD' })
                        .then(res => {
                            const capeBtn = document.getElementById('downloadCapeBtn');
                            if (res.ok) {
                                capeBtn.style.display = '';
                                capeBtn.onclick = function (e) {
                                    e.preventDefault();
                                    downloadFile(capeUrl, `${player.username}_cape.png`);
                                };
                            } else {
                                capeBtn.style.display = 'none';
                            }
                        });

                    // Управление камерой
                    const autoRotateBtn = document.getElementById('toggleAutoRotateBtn');

                    autoRotateBtn.onclick = function () {
                        const isActive = autoRotateBtn.classList.toggle('active');
                        viewer.controls.autoRotate = isActive;
                    };

                    // Управление отображением
                    const capeBtn = document.getElementById('toggleCapeBtn');

                    capeBtn.onclick = function () {
                        if (capeBtn.classList.toggle('active')) {
                            fetch(capeUrl, { method: 'HEAD' })
                                .then(res => { if (res.ok) viewer.loadCape(capeUrl); });
                        } else {
                            viewer.loadCape(null);
                        }
                    };

                    // Показываем контент
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('player-content').style.display = 'block';

                    // Сохраняем статистику в кэш окна для переключения режимов
                    window.cachedStatsData = statsData;
                    
                    // Загружаем статистику из уже полученных данных
                    processPlayerStats(statsData, false);

                } catch (error) {
                    console.error('Ошибка при загрузке данных:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                }
            }

            // Добавляем обработчик клика для переключения между общей и сезонной статистикой
            document.getElementById('stats-tab').addEventListener('click', function(e) {
                // Проверяем, активна ли вкладка "Статистика"
                const statsTab = document.getElementById('stats');
                const isStatsActive = statsTab.classList.contains('show') && statsTab.classList.contains('active');
                
                if (isStatsActive) {
                    e.preventDefault();
                    const statsModeLabel = document.getElementById('stats-mode-label');
                    const isCurrentlySeasonal = statsModeLabel.textContent.includes('Сезонная');
                    
                    // Переключаем режим, используя кэшированные данные, если они есть
                    if (window.cachedStatsData) {
                        if (isCurrentlySeasonal) {
                            statsModeLabel.textContent = 'Общая';
                            processPlayerStats(window.cachedStatsData, false);
                        } else {
                            statsModeLabel.textContent = 'Сезонная';
                            processPlayerStats(window.cachedStatsData, true);
                        }
                    } else {
                        // Если данные не кэшированы, загружаем заново
                        if (isCurrentlySeasonal) {
                            statsModeLabel.textContent = 'Общая';
                            loadPlayerStats(username, false);
                        } else {
                            statsModeLabel.textContent = 'Сезонная';
                            loadPlayerStats(username, true);
                        }
                    }

                    // Предотвращаем стандартное поведение вкладки Bootstrap
                    e.stopPropagation();
                }
            });

            // Загружаем данные при загрузке страницы
            loadPlayerData();
        }

        async function loadPlayerStats(username, isSeasonal = false) {
            try {
                const response = await fetch(`https://api.vimeworld.com/user/name/${username}/stats`);
                const data = await response.json();
                processPlayerStats(data, isSeasonal);
            } catch (error) {
                console.error('Ошибка при загрузке статистики:', error);
            }
        }
        
        function processPlayerStats(data, isSeasonal = false) {
            const statsGrid = document.querySelector('.stats-grid');
            statsGrid.innerHTML = ''; // Очищаем текущую статистику

            // Получаем сохраненный порядок из localStorage
            const savedOrder = JSON.parse(localStorage.getItem('statsBlocksOrder') || '[]');
            
            // Собираем все игры с данными
            const gamesWithStats = [];
            for (const [gameCode, gameConfig] of Object.entries(GAMES_CONFIG)) {
                const gameStats = isSeasonal ? 
                    (data.stats[gameCode]?.season?.monthly || {}) : 
                    (data.stats[gameCode]?.global || {});

                if (Object.keys(gameStats).length > 0) {
                    gamesWithStats.push({
                        gameCode,
                        gameConfig,
                        gameStats
                    });
                }
            }
            
            // Сортируем игры согласно сохраненному порядку
            if (savedOrder.length > 0) {
                gamesWithStats.sort((a, b) => {
                    const indexA = savedOrder.indexOf(a.gameCode);
                    const indexB = savedOrder.indexOf(b.gameCode);
                    if (indexA === -1 && indexB === -1) return 0;
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
            }

            // Счетчик для отслеживания количества блоков в ряду
            let blocksInRow = 0;
            let currentRow = document.createElement('div');
            currentRow.className = 'stats-row';
            statsGrid.appendChild(currentRow);

            // Создаем блоки в отсортированном порядке
            gamesWithStats.forEach(({ gameCode, gameConfig, gameStats }) => {
                const gameData = {
                    ...gameConfig,
                    global: gameStats
                };
                
                const statsBlock = createStatsBlock(gameCode, gameData);
                
                // Если в текущем ряду уже 4 блока, создаем новый ряд
                if (blocksInRow === 4) {
                    currentRow = document.createElement('div');
                    currentRow.className = 'stats-row';
                    statsGrid.appendChild(currentRow);
                    blocksInRow = 0;
                }

                currentRow.appendChild(statsBlock);
                blocksInRow++;
            });
        }

        // Переменная для хранения перетаскиваемого элемента
        let draggedElement = null;
        let autoScrollInterval = null;
        let currentMouseY = 0;
        let currentMouseX = 0;
        let isDragging = false;
        let dragGhost = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let velocityX = 0;
        let velocityY = 0;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function handleDragStart(e) {
            draggedElement = this;
            isDragging = true;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            
            // Вычисляем смещение от точки клика до верхнего левого угла элемента
            const rect = this.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Создаем визуальную копию элемента
            dragGhost = this.cloneNode(true);
            dragGhost.style.position = 'fixed';
            dragGhost.style.pointerEvents = 'none';
            dragGhost.style.zIndex = '10000';
            dragGhost.style.width = this.offsetWidth + 'px';
            dragGhost.style.height = this.offsetHeight + 'px';
            dragGhost.style.transition = 'transform 0.1s ease-out';
            dragGhost.classList.remove('dragging');
            dragGhost.classList.add('drag-ghost');
            document.body.appendChild(dragGhost);
            
            // Скрываем оригинальный элемент
            this.style.opacity = '0.3';
            
            // Инициализируем позицию
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateGhostPosition(e.clientX, e.clientY);
            
            // Запускаем автоскролл
            startAutoScroll();
            
            // Разрешаем ручной скролл во время перетаскивания
            enableManualScroll();
        }

        function handleDragEnd(e) {
            this.style.opacity = '';
            this.classList.remove('dragging');
            isDragging = false;
            
            // Удаляем ghost элемент
            if (dragGhost) {
                dragGhost.remove();
                dragGhost = null;
            }
            
            // Убираем класс drag-over со всех элементов с анимацией
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            // Останавливаем автоскролл
            stopAutoScroll();
            
            // Отключаем ручной скролл
            disableManualScroll();
            
            // Сохраняем новый порядок
            saveStatsOrder();
            
            draggedElement = null;
            currentMouseY = 0;
            currentMouseX = 0;
            velocityX = 0;
            velocityY = 0;
            dragOffsetX = 0;
            dragOffsetY = 0;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            // Сохраняем текущую позицию мыши
            currentMouseY = e.clientY;
            currentMouseX = e.clientX;
            
            // Обновляем позицию ghost элемента
            if (dragGhost) {
                updateGhostPosition(e.clientX, e.clientY);
            }
            
            return false;
        }
        
        function updateGhostPosition(mouseX, mouseY) {
            if (!dragGhost) return;
            
            // Вычисляем скорость движения
            velocityX = mouseX - lastMouseX;
            velocityY = mouseY - lastMouseY;
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Ограничиваем угол наклона
            const maxRotation = 8;
            const rotationX = Math.max(-maxRotation, Math.min(maxRotation, velocityY * 0.5));
            const rotationZ = Math.max(-maxRotation, Math.min(maxRotation, velocityX * 0.3));
            
            // Позиционируем ghost элемент относительно точки клика (где находятся точки)
            const x = mouseX - dragOffsetX;
            const y = mouseY - dragOffsetY;
            
            // Применяем трансформации
            dragGhost.style.left = x + 'px';
            dragGhost.style.top = y + 'px';
            dragGhost.style.transform = `
                rotateX(${-rotationX}deg) 
                rotateZ(${rotationZ}deg) 
                scale(1.05)
            `;
            dragGhost.style.boxShadow = '0 20px 60px rgba(52, 152, 219, 0.3)';
        }

        // Обработчик ручного скролла колесиком мыши
        function handleManualScroll(e) {
            if (isDragging) {
                // Предотвращаем стандартное поведение и скроллим вручную
                e.preventDefault();
                
                // Скроллим страницу на величину deltaY
                window.scrollBy(0, e.deltaY);
                
                return false;
            }
        }

        function enableManualScroll() {
            // Добавляем обработчик для колесика мыши с passive: false чтобы можно было preventDefault
            document.addEventListener('wheel', handleManualScroll, { passive: false });
        }

        function disableManualScroll() {
            // Удаляем обработчик
            document.removeEventListener('wheel', handleManualScroll);
        }

        function startAutoScroll() {
            if (autoScrollInterval) return;
            
            autoScrollInterval = setInterval(() => {
                if (!draggedElement) {
                    stopAutoScroll();
                    return;
                }
                
                // Выполняем автоскролл на основе текущей позиции мыши
                performAutoScroll();
            }, 16); // ~60fps
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
        }

        function performAutoScroll() {
            if (!currentMouseY) return;
            
            const scrollThreshold = 150; // Зона в пикселях от края экрана
            const scrollSpeed = 25; // Скорость скролла
            const viewportHeight = window.innerHeight;
            
            // Скролл вверх
            if (currentMouseY < scrollThreshold) {
                const intensity = 1 - (currentMouseY / scrollThreshold);
                window.scrollBy(0, -scrollSpeed * intensity);
            }
            // Скролл вниз
            else if (currentMouseY > viewportHeight - scrollThreshold) {
                const intensity = (currentMouseY - (viewportHeight - scrollThreshold)) / scrollThreshold;
                window.scrollBy(0, scrollSpeed * intensity);
            }
        }

        function handleDragEnter(e) {
            if (this !== draggedElement) {
                this.classList.add('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedElement !== this) {
                // Получаем родительские ряды
                const draggedRow = draggedElement.parentNode;
                const targetRow = this.parentNode;
                
                // Добавляем анимацию перед перемещением
                const draggedRect = draggedElement.getBoundingClientRect();
                const targetRect = this.getBoundingClientRect();
                
                // Если элементы в одном ряду
                if (draggedRow === targetRow) {
                    // Определяем позицию для вставки
                    const allCards = Array.from(targetRow.children);
                    const draggedIndex = allCards.indexOf(draggedElement);
                    const targetIndex = allCards.indexOf(this);
                    
                    if (draggedIndex < targetIndex) {
                        targetRow.insertBefore(draggedElement, this.nextSibling);
                    } else {
                        targetRow.insertBefore(draggedElement, this);
                    }
                } else {
                    // Элементы в разных рядах - меняем местами
                    const draggedNext = draggedElement.nextSibling;
                    const targetNext = this.nextSibling;
                    
                    targetRow.insertBefore(draggedElement, this);
                    draggedRow.insertBefore(this, draggedNext);
                }
                
                // Добавляем анимацию появления
                draggedElement.style.animation = 'none';
                setTimeout(() => {
                    draggedElement.style.animation = '';
                }, 10);
            }
            
            this.classList.remove('drag-over');
            return false;
        }

        function handleDragLeave(e) {
            // Проверяем, действительно ли мы покинули элемент
            if (e.target === this) {
                this.classList.remove('drag-over');
            }
        }

        function saveStatsOrder() {
            const statsGrid = document.querySelector('.stats-grid');
            const allCards = statsGrid.querySelectorAll('.stat-card');
            const order = Array.from(allCards).map(card => card.getAttribute('data-game-code'));
            localStorage.setItem('statsBlocksOrder', JSON.stringify(order));
        }


        function formatLargeNumber(num) {
            // Если число меньше 1000, возвращаем его как есть
            if (num < 1000) {
                return num.toString();
            }

            const units = [
                '', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc',
                'UDc', 'DDc', 'TDc', 'QaDc', 'QiDc', 'SxDc', 'SpDc', 'OcDc', 'NoDc', 'Vg',
                'UVg', 'DVg', 'TVg', 'QaVg', 'QiVg', 'SxVg', 'SpVg', 'OcVg', 'NoVg', 'Tg',
                'UTg', 'DTg', 'TTg', 'QaTg', 'QiTg', 'SxTg', 'SpTg', 'OcTg', 'NoTg', 'Qd',
                'UQd', 'DQd', 'TQd', 'QaQd', 'QiQd', 'SxQd', 'SpQd', 'OcQd', 'NoQd', 'Qq',
                'UQq', 'DQq', 'TQq', 'QaQq', 'QiQq', 'SxQq', 'SpQq', 'OcQq', 'NoQq', 'Sg',
                'USg', 'DSg', 'TSg', 'QaSg', 'QiSg', 'SxSg', 'SpSg', 'OcSg', 'NoSg', 'St',
                'USt', 'DSt', 'TSt', 'QaSt', 'QiSt', 'SxSt', 'SpSt', 'OcSt', 'NoSt', 'Og',
                'UOg', 'DOg', 'TOg', 'QaOg', 'QiOg', 'SxOg', 'SpOg', 'OcOg', 'NoOg', 'Ng',
                'UNg', 'DNg', 'TNg', 'QaNg', 'QiNg', 'SxNg', 'SpNg', 'OcNg', 'NoNg', 'Ce'
            ];
            
            const k = 1000;
            const magnitude = Math.floor(Math.log(num) / Math.log(k));
            
            const value = num / Math.pow(k, magnitude);
            const formattedValue = value.toFixed(2).replace(/\.?0+$/, '');
            return formattedValue + ' ' + units[magnitude];
        }

        function createStatsBlock(gameCode, gameData) {
            const block = document.createElement('div');
            block.className = 'stat-card';
            block.setAttribute('data-game-code', gameCode);
            
            // Создаем drag handle (ручку для перетаскивания)
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle';
            dragHandle.setAttribute('draggable', 'true');
            
            // Создаем 3 ряда по 2 точки (6 точек всего)
            for (let i = 0; i < 3; i++) {
                const row = document.createElement('div');
                row.className = 'drag-handle-row';
                for (let j = 0; j < 2; j++) {
                    const dot = document.createElement('div');
                    dot.className = 'drag-handle-dot';
                    row.appendChild(dot);
                }
                dragHandle.appendChild(row);
            }
            
            // Добавляем обработчики drag-and-drop только к handle
            dragHandle.addEventListener('dragstart', function(e) {
                handleDragStart.call(block, e);
            });
            block.addEventListener('dragend', handleDragEnd);
            block.addEventListener('dragover', handleDragOver);
            block.addEventListener('dragenter', handleDragEnter);
            block.addEventListener('drop', handleDrop);
            block.addEventListener('dragleave', handleDragLeave);
            
            block.appendChild(dragHandle);
            
            // Заголовок блока
            const title = document.createElement('div');
            title.className = 'stat-title';
            title.textContent = gameData.name;
            block.appendChild(title);

            // Контейнер для статистики
            const statsContainer = document.createElement('div');
            statsContainer.className = 'stat-values';

            // Выбираем набор статистик в зависимости от режима
            const statsToShow = gameData.seasonalStats || gameData.stats;

            // Добавляем статистику из конфига
            statsToShow.forEach(stat => {
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                
                let value = gameData.global[stat.key] || 0;
                
                // Форматируем большие числа для My Farm и Prison Lite
                if ((gameCode === 'FARM' && (stat.key === 'dollars' || stat.key === 'farm_cost')) ||
                    (gameCode === 'PRISON_LITE' && stat.key === 'earned_money')) {
                    value = formatLargeNumber(value);
                }
                
                statItem.innerHTML = `
                    <span class="stat-name">${stat.label}:</span>
                    <span class="stat-value">${value}</span>
                `;
                statsContainer.appendChild(statItem);
            });

            block.appendChild(statsContainer);

            // Добавляем кнопку разворачивания, если статистики больше 5 строк
            if (statsToShow.length > 5) {
                const expandButton = document.createElement('div');
                expandButton.className = 'expand-button';
                expandButton.onclick = function() {
                    block.classList.toggle('expanded');
                };
                block.appendChild(expandButton);
            }

            return block;
        }

        const GAMES_CONFIG = {
            'ANN': {
                name: 'Annihilation',
                stats: [
                    { label: 'Ударов по базе', key: 'nexus' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Убийств с лука', key: 'bowkills' },
                    { label: 'Добыто дуба', key: 'wood' },
                    { label: 'Добыто руды', key: 'ores' },
                    { label: 'Добыто земли', key: 'digged' }
                ],
                seasonalStats: [
                    { label: 'Ударов по базе', key: 'nexus' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Убийств с лука', key: 'bowkills' },
                    { label: 'Добыто дуба', key: 'wood' },
                    { label: 'Добыто руды', key: 'ores' },
                    { label: 'Добыто земли', key: 'digged' }
                ]
            },
            'BB': {
                name: 'BuildBattle',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                    ],
                seasonalStats: [
                { label: 'Игр', key: 'games' },
                { label: 'Побед', key: 'wins' }
                ]
            },
            'BP': {
                name: 'BlockParty',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Пройдено волн', key: 'rounds' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Пройдено волн', key: 'rounds' }
                ]
            },
            'BW': {
                name: 'BedWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' }
                ]
            },
            'BWHYPE': {
                name: 'BedWars Hype',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'BWT': {
                name: 'BedWars Turbo',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Заработано монет', key: 'spent_coins' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кроватей', key: 'bedBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Финальных убийств', key: 'final_kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Заработано монет', key: 'spent_coins' }
                ]
            },
            'CP': {
                name: 'ClashPoint',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кристаллов', key: 'resourcePointsBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Разрушено кристаллов', key: 'resourcePointsBreaked' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'DUELS': {
                name: 'Дуэли',
                stats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр в одиночку', key: 'solo_games' },
                    { label: 'Побед в одиночку', key: 'solo_wins' },
                    { label: 'Игр в команде', key: 'team_games' },
                    { label: 'Побед в команде', key: 'team_wins' },
                    { label: 'Рейтинговых игр', key: 'ranked_games' },
                    { label: 'Рейтинговых побед', key: 'ranked_wins' },
                    { label: 'Максимальная серия побед', key: 'maxstrike' },
                    { label: 'Побед "Classic"', key: 'wins_classic' },
                    { label: 'Побед "На луках"', key: 'wins_bow' },
                    { label: 'Побед "OP"', key: 'wins_op' },
                    { label: 'Побед "На зельях"', key: 'wins_potion' },
                    { label: 'Побед "UHC"', key: 'wins_uhc' },
                    { label: 'Побед "BWH"', key: 'wins_bwh' }
                ],
                seasonalStats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр в одиночку', key: 'solo_games' },
                    { label: 'Побед в одиночку', key: 'solo_wins' },
                    { label: 'Игр в команде', key: 'team_games' },
                    { label: 'Побед в команде', key: 'team_wins' },
                    { label: 'Рейтинговых игр', key: 'ranked_games' },
                    { label: 'Рейтинговых побед', key: 'ranked_wins' },
                    { label: 'Максимальная серия побед', key: 'maxstrike' },
                    { label: 'Побед "Classic"', key: 'wins_classic' },
                    { label: 'Побед "На луках"', key: 'wins_bow' },
                    { label: 'Побед "OP"', key: 'wins_op' },
                    { label: 'Побед "На зельях"', key: 'wins_potion' },
                    { label: 'Побед "UHC"', key: 'wins_uhc' },
                    { label: 'Побед "BWH"', key: 'wins_bwh' }
                ]
            },
            'GG': {
                name: 'GunGame',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Получено уровней', key: 'levels' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Получено уровней', key: 'levels' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'HG': {
                name: 'HungerGames',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'KPVP': {
                name: 'KitPvP',
                stats: [
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Очков', key: 'points' }
                    ],
                seasonalStats: [
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Очков', key: 'points' }
                ]
            },
            'EGGWARS': {
                name: 'EggWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено яиц', key: 'eggs' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Разрушено яиц', key: 'eggs' }
                ]
            },
            'MW': {
                name: 'MobWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'mobsKilled' },
                    { label: 'Отправлено мобов', key: 'mobsSended' },
                    { label: 'Максимальный доход', key: 'mobsSended' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'mobsKilled' },
                    { label: 'Отправлено мобов', key: 'mobsSended' },
                    { label: 'Максимальный доход', key: 'mobsSended' }
                ]
            },
            'PRISON': {
                name: 'Prison',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'PRISON_LITE': {
                name: 'Prison Lite | Alpha',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'SW': {
                name: 'SkyWars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Потрачено стрел', key: 'arrowsFired' },
                    { label: 'Блоков сломано', key: 'blocksBroken' },
                    { label: 'Блоков размещено', key: 'blocksPlaced' },
                    { label: 'Текущая серия побед', key: 'currentWinStreak' },
                    { label: 'Максимальная серия побед', key: 'winStreak' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Поражений', key: 'loses' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Потрачено стрел', key: 'arrowsFired' },
                    { label: 'Блоков сломано', key: 'blocksBroken' },
                    { label: 'Блоков размещено', key: 'blocksPlaced' },
                    { label: 'Текущая серия побед', key: 'currentWinStreak' },
                    { label: 'Максимальная серия побед', key: 'winStreak' }
                ]
            },
            'ARC': {
                name: 'Аркады',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'BRIDGE': {
                name: 'The Bridge',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'points' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'points' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'JUMPLEAGUE': {
                name: 'Jump League',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Чекпоинтов', key: 'checkpoints' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Чекпоинтов', key: 'checkpoints' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'MURDER': {
                name: 'Murder Mystery',
                stats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед за невинного ', key: 'wins_as_innocent' },
                    { label: 'Побед за маньяка', key: 'wins_as_maniac' },
                    { label: 'Побед за детектива', key: 'wins_as_detective' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'total_games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед за невинного ', key: 'wins_as_innocent' },
                    { label: 'Побед за маньяка', key: 'wins_as_maniac' },
                    { label: 'Побед за детектива', key: 'wins_as_detective' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'SHEEP': {
                name: 'Sheep Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'TURFWARS': {
                name: 'Turf Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'TNTTAG': {
                name: 'TNT Tag',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'TNTRUN': {
                name: 'TNT Run',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано блоков', key: 'broken_blocks' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано блоков', key: 'broken_blocks' }
                ]
            },
            'LUCKYWARS': {
                name: 'Lucky Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано Лаки-Блоков', key: 'lucky_blocks' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано Лаки-Блоков', key: 'lucky_blocks' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'WHITECOLD': {
                name: 'Белый Холод',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'kills' },
                    { label: 'Собрано подарков', key: 'gifts' },
                    { label: 'Собрано сундуков', key: 'chests' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убито мобов', key: 'kills' },
                    { label: 'Собрано подарков', key: 'gifts' },
                    { label: 'Собрано сундуков', key: 'chests' }
                ]
            },
            'HIDE': {
                name: 'Прятки',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Побед за охотника', key: 'wins_as_seeker' },
                    { label: 'Побед за прячущего', key: 'wins_as_hider' },
                    { label: 'Убийств', key: 'kills' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'total_wins' },
                    { label: 'Побед за охотника', key: 'wins_as_seeker' },
                    { label: 'Побед за прячущего', key: 'wins_as_hider' },
                    { label: 'Убийств', key: 'kills' }
                ]
            },
            'SPEEDBUILDERS': {
                name: 'Speed Builders',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' }
                ]
            },
            'FALLGUYS': {
                name: 'Fall Guys',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                ]
            },
            'TEAMFORTRESS': {
                name: 'Team Fortess',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'EGGWARS': {
                name: 'Egg Wars',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Помощей', key: 'assists' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Подобрано рун', key: 'runes' },
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Помощей', key: 'assists' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Подобрано рун', key: 'runes' },
                ]
            },
            'BATTLEBOX': {
                name: 'BattleBox',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'score' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Очков', key: 'score' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'DEATHRUN': {
                name: 'DeathRun',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Максимальный рекорд', key: 'max_score' },
                    { label: 'Бонусов собрано', key: 'bonuses_collect' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Максимальный рекорд', key: 'max_score' },
                    { label: 'Бонусов собрано', key: 'bonuses_collect' }
                ]
            },
            'FARM': {
                name: 'My Farm',
                stats: [
                    { label: 'Денег', key: 'dollars' },
                    { label: 'Стоимость фермы', key: 'farm_cost' }
                    ],
                seasonalStats: [
                    { label: 'Денег', key: 'dollars' },
                    { label: 'Стоимость фермы', key: 'farm_cost' }
                ]
            },
            'FIREBALLFIGHT': {
                name: 'FireBall Fight',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Сломано кроватей', key: 'destroyed_beds' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' }
                ]
            },
            'CSS': {
                name: 'Custom Steve Survival',
                stats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сыграно дуэлей', key: 'duel_games' },
                    { label: 'Побед в дуэлях', key: 'duel_wins' },
                    { label: 'Пройдено волн', key: 'passed_waves' },
                    { label: 'Максимальная волна', key: 'max_passed_waves_per_game' },
                    { label: 'Монет заработано', key: 'money_earned' }
                    ],
                seasonalStats: [
                    { label: 'Добыто блоков', key: 'total_blocks' },
                    { label: 'Заработано монет', key: 'earned_money' },
                    { label: 'Убито мобов', key: 'mobs' },
                    { label: 'Убийств', key: 'kills' },
                    { label: 'Смертей', key: 'deaths' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сыграно дуэлей', key: 'duel_games' },
                    { label: 'Побед в дуэлях', key: 'duel_wins' },
                    { label: 'Пройдено волн', key: 'passed_waves' },
                    { label: 'Максимальная волна', key: 'max_passed_waves_per_game' },
                    { label: 'Монет заработано', key: 'money_earned' }
                ]
            },
            'COR': {
                name: 'Chaos Of Reign',
                stats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Время в игре', key: 'played_time' },
                    { label: 'Монет заработано', key: 'money_earned' },
                    { label: 'Убийств', key: 'player_kills' },
                    { label: 'Сломано башен', key: 'towers_destroyed' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сфер подобрано', key: 'pickup_spheres' }
                    ],
                seasonalStats: [
                    { label: 'Игр', key: 'games' },
                    { label: 'Побед', key: 'wins' },
                    { label: 'Время в игре', key: 'played_time' },
                    { label: 'Монет заработано', key: 'money_earned' },
                    { label: 'Убийств', key: 'player_kills' },
                    { label: 'Сломано башен', key: 'towers_destroyed' },
                    { label: 'Убито мобов', key: 'monsters' },
                    { label: 'Сфер подобрано', key: 'pickup_spheres' }
                ]
            },
        };

        // Добавляем функции для работы с кешем
        function savePlayerData(nick, data) {
            const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
            playerCache[nick] = {
                ...data,
                timestamp: Date.now()
            };
            localStorage.setItem('playerCache', JSON.stringify(playerCache));
        }

        function getPlayerData(nick) {
            const playerCache = JSON.parse(localStorage.getItem('playerCache') || '{}');
            return playerCache[nick];
        }

        // Функция для сохранения никнейма в localStorage
        function saveNick(nick) {
            // Получаем оригинальный никнейм из API
            fetch(`https://api.vimeworld.com/user/name/${nick}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const originalUsername = data[0].username;
                        let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                        nicks = nicks.filter(n => n !== originalUsername);
                        nicks.unshift(originalUsername);
                        nicks = nicks.slice(0, 5); // Максимум 5 никнеймов
                        localStorage.setItem('recentNicks', JSON.stringify(nicks));
                    }
                })
                .catch(error => {
                    console.error('Ошибка при получении оригинального никнейма:', error);
                    // Если не удалось получить оригинальный никнейм, сохраняем введенный
                    let nicks = JSON.parse(localStorage.getItem('recentNicks') || '[]');
                    nicks = nicks.filter(n => n !== nick);
                    nicks.unshift(nick);
                    nicks = nicks.slice(0, 5);
                    localStorage.setItem('recentNicks', JSON.stringify(nicks));
                });
        }

        // Обработчик отправки формы поиска
        document.addEventListener('DOMContentLoaded', function() {
            // Находим элементы поиска и добавляем обработчики
            const quickSearchInput = document.getElementById('quick-search');
            const quickSearchBtn = document.getElementById('quick-search-btn');
            
            if (quickSearchBtn && quickSearchInput) {
                // Обработчик клика по кнопке поиска
                quickSearchBtn.addEventListener('click', function() {
                    const username = quickSearchInput.value.trim();
                    if (!username) return;
                    
                    getOriginalNameAndRedirect(username);
                });
                
                // Обработчик нажатия Enter в поле поиска
                quickSearchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        const username = quickSearchInput.value.trim();
                        if (username) {
                            getOriginalNameAndRedirect(username);
                        }
                    }
                });
            }
        });

        // Функция для отображения тултипа с историей ников
        async function showNickHistoryTooltip(playerId, buttonElement) {
            // Проверяем, что playerId передан
            if (!playerId) {
                console.error('Player ID не передан');
                return;
            }
            // Удаляем существующий тултип, если он есть
            const existingTooltip = document.getElementById('nick-history-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
                return;
            }
            
            // Создаем контейнер для тултипа
            const tooltip = document.createElement('div');
            tooltip.id = 'nick-history-tooltip';
            tooltip.style.cssText = `
                position: absolute;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
                padding: 20px;
                min-width: 300px;
                max-width: 400px;
                max-height: 500px;
                overflow-y: auto;
                z-index: 10000;
                font-family: 'VimeArtBold', sans-serif;
            `;
            
            // Позиционируем тултип относительно кнопки
            const buttonRect = buttonElement.getBoundingClientRect();
            const tooltipWidth = 350; // Примерная ширина тултипа
            const tooltipHeight = 400; // Примерная высота тултипа
            
            let left = buttonRect.left - tooltipWidth / 2 + buttonRect.width / 2;
            let top = buttonRect.bottom + 10;
            
            // Проверяем, не выходит ли тултип за правый край экрана
            if (left + tooltipWidth > window.innerWidth) {
                left = window.innerWidth - tooltipWidth - 10;
            }
            
            // Проверяем, не выходит ли тултип за левый край экрана
            if (left < 10) {
                left = 10;
            }
            
            // Проверяем, не выходит ли тултип за нижний край экрана
            if (top + tooltipHeight > window.innerHeight) {
                top = buttonRect.top - tooltipHeight - 10;
            }
            
            tooltip.style.top = top + 'px';
            tooltip.style.left = left + 'px';
            
            // Добавляем заголовок
            const title = document.createElement('div');
            title.textContent = 'История ников';
            title.style.cssText = `
                font-size: 1.2rem;
                font-weight: bold;
                color: #2c3e50;
                margin-bottom: 16px;
                padding-bottom: 12px;
                border-bottom: 2px solid #e6f3ff;
            `;
            tooltip.appendChild(title);
            
            // Добавляем индикатор загрузки
            const loadingDiv = document.createElement('div');
            loadingDiv.textContent = 'Загрузка...';
            loadingDiv.style.cssText = 'text-align: center; padding: 20px; color: #7f8c8d;';
            tooltip.appendChild(loadingDiv);
            
            document.body.appendChild(tooltip);
            
            try {
                // Загружаем историю ников по ID через vimetop.ru API
                // Используем CORS proxy для обхода ограничений CORS
                const targetUrl = `https://vimetop.ru/api/v1/player/${playerId}/history/usernames`;
                // Пробуем несколько CORS proxy сервисов
                const corsProxies = [
                    `https://api.allorigins.win/get?url=${encodeURIComponent(targetUrl)}`,
                    `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
                    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(targetUrl)}`
                ];
                
                console.log('Запрос истории ников для ID:', playerId);
                console.log('Целевой URL:', targetUrl);
                
                // Функция для fetch с таймаутом
                const fetchWithTimeout = (url, timeout = 3000) => {
                    return Promise.race([
                        fetch(url),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Таймаут запроса')), timeout)
                        )
                    ]);
                };
                
                let historyResponse;
                let historyData;
                let lastError;
                
                // Пробуем каждый прокси по очереди с таймаутом 3 секунды
                for (let i = 0; i < corsProxies.length; i++) {
                    try {
                        console.log(`Пробуем прокси ${i + 1}:`, corsProxies[i]);
                        historyResponse = await fetchWithTimeout(corsProxies[i], 3000);
                        
                        if (historyResponse.ok) {
                            const proxyData = await historyResponse.json();
                            historyData = proxyData['response']['data']['history']
                            
                            console.log('Успешно получены данные через прокси', i + 1);
                            break;
                        }
                    } catch (error) {
                        console.log(`Прокси ${i + 1} не сработал:`, error.message);
                        lastError = error;
                        continue;
                    }
                }
                
                // Если все прокси не сработали, пробуем прямой запрос
                if (!historyData) {
                    console.log('Пробуем прямой запрос...');
                    try {
                        historyResponse = await fetch(targetUrl, {
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        if (!historyResponse.ok) {
                            throw new Error(`HTTP ${historyResponse.status}: ${historyResponse.statusText}`);
                        }
                        
                        historyData = await historyResponse.json();
                    } catch (directError) {
                        console.error('Прямой запрос также не сработал:', directError);
                        throw new Error('Не удалось загрузить историю ников. Возможно, требуется использовать VPN или расширение для обхода CORS.');
                    }
                }
                
                console.log('Статус ответа:', historyResponse.status, historyResponse.statusText);
                
                if (!historyResponse.ok) {
                    // Пробуем получить текст ошибки
                    let errorText = 'Не удалось загрузить историю ников';
                    try {
                        const errorData = await historyResponse.json();
                        console.log('Данные ошибки:', errorData);
                        if (errorData && errorData.error) {
                            errorText = errorData.error;
                        } else if (errorData && errorData.message) {
                            errorText = errorData.message;
                        }
                    } catch (e) {
                        const responseText = await historyResponse.text();
                        console.log('Текст ответа:', responseText);
                        errorText = `Ошибка ${historyResponse.status}: ${historyResponse.statusText}`;
                    }
                    throw new Error(errorText);
                }
                
                console.log('Полученные данные истории:', historyData);
                
                // Удаляем индикатор загрузки
                loadingDiv.remove();
                
                // Проверяем, что данные в правильном формате
                if (!historyData) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'История ников пуста';
                    emptyMessage.style.cssText = 'text-align: center; padding: 40px; color: #7f8c8d;';
                    tooltip.appendChild(emptyMessage);
                    return;
                }
                
                // Обрабатываем разные форматы ответа от API
                let actualHistoryData = historyData;
                
                // Если это массив - используем его напрямую
                if (Array.isArray(historyData)) {
                    actualHistoryData = historyData;
                }
                // Если это объект, ищем массив в разных полях
                else if (typeof historyData === 'object') {
                    if (historyData.data && Array.isArray(historyData.data)) {
                        actualHistoryData = historyData.data;
                    } else if (historyData.names && Array.isArray(historyData.names)) {
                        actualHistoryData = historyData.names;
                    } else if (historyData.history && Array.isArray(historyData.history)) {
                        actualHistoryData = historyData.history;
                    } else if (historyData.usernames && Array.isArray(historyData.usernames)) {
                        actualHistoryData = historyData.usernames;
                    }
                }
                
                // Проверяем, что у нас есть массив данных
                if (!Array.isArray(actualHistoryData) || actualHistoryData.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.textContent = 'История ников пуста';
                    emptyMessage.style.cssText = 'text-align: center; padding: 40px; color: #7f8c8d;';
                    tooltip.appendChild(emptyMessage);
                    return;
                }
                
                // Создаем список истории ников
                const historyList = document.createElement('div');
                historyList.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
                
                // Сортируем по дате (от новых к старым)
                // Поддерживаем разные форматы полей даты
                const sortedHistory = actualHistoryData.sort((a, b) => {
                    const dateA = a.changedToAt ? new Date(a.changedToAt) : 
                                  (a.changed_at ? new Date(a.changed_at) : 
                                  (a.date ? new Date(a.date) : 
                                  (a.timestamp ? new Date(a.timestamp) : 
                                  (a.changedAt ? new Date(a.changedAt) : new Date(0)))));
                    const dateB = b.changedToAt ? new Date(b.changedToAt) : 
                                  (b.changed_at ? new Date(b.changed_at) : 
                                  (b.date ? new Date(b.date) : 
                                  (b.timestamp ? new Date(b.timestamp) : 
                                  (b.changedAt ? new Date(b.changedAt) : new Date(0)))));
                    return dateB - dateA;
                });
                
                sortedHistory.forEach((item) => {
                    const historyItem = document.createElement('div');
                    historyItem.style.cssText = `
                        background: #f8fbff;
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        transition: background 0.2s ease;
                    `;
                    
                    historyItem.onmouseover = function() {
                        this.style.background = '#e6f3ff';
                    };
                    
                    historyItem.onmouseout = function() {
                        this.style.background = '#f8fbff';
                    };
                    
                    // Создаем контейнер для имен
                    const namesContainer = document.createElement('div');
                    namesContainer.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        flex-wrap: wrap;
                    `;
                    
                    // Если есть old_name и new_name, показываем оба
                    if (item.old_name && item.new_name) {
                        const oldNameSpan = document.createElement('span');
                        oldNameSpan.style.cssText = `
                            font-size: 1rem;
                            color: #7f8c8d;
                            font-weight: 500;
                            text-decoration: line-through;
                        `;
                        oldNameSpan.textContent = item.old_name;
                        namesContainer.appendChild(oldNameSpan);
                        
                        const arrow = document.createElement('span');
                        arrow.textContent = '→';
                        arrow.style.cssText = `
                            font-size: 1rem;
                            color: #3498db;
                            font-weight: bold;
                        `;
                        namesContainer.appendChild(arrow);
                        
                        const newNameSpan = document.createElement('span');
                        newNameSpan.style.cssText = `
                            font-size: 1rem;
                            color: #2c3e50;
                            font-weight: 500;
                        `;
                        newNameSpan.textContent = item.new_name;
                        namesContainer.appendChild(newNameSpan);
                    } else {
                        // Используем старый формат для обратной совместимости
                        const nickName = document.createElement('span');
                        nickName.style.cssText = `
                            font-size: 1rem;
                            color: #2c3e50;
                            font-weight: 500;
                        `;
                        nickName.textContent = item.username || item.name || item.nickname || item.value || item.new_name || item.old_name || String(item) || 'Неизвестно';
                        namesContainer.appendChild(nickName);
                    }
                    
                    historyItem.appendChild(namesContainer);
                    
                    const dateInfo = document.createElement('div');
                    dateInfo.style.cssText = `
                        font-size: 0.8rem;
                        color: #7f8c8d;
                        text-align: left;
                    `;
                    
                    // Поддерживаем разные форматы полей даты
                    const changeDate = item.created_at;
                    if (changeDate) {
                        const date = new Date(changeDate);
                        if (!isNaN(date.getTime())) {
                            const now = new Date();
                            const diffMs = now - date;
                            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                            
                            if (diffDays === 0) {
                                dateInfo.textContent = 'Сегодня';
                            } else if (diffDays === 1) {
                                dateInfo.textContent = 'Вчера';
                            } else if (diffDays < 30) {
                                dateInfo.textContent = `${diffDays} дн. назад`;
                            } else {
                                dateInfo.textContent = date.toLocaleDateString('ru-RU', {
                                    year: 'numeric',
                                    month: 'short',
                                    day: 'numeric'
                                });
                            }
                        } else {
                            dateInfo.textContent = 'Дата неизвестна';
                        }
                    } else {
                        dateInfo.textContent = 'Дата неизвестна';
                    }
                    
                    historyItem.appendChild(dateInfo);
                    historyList.appendChild(historyItem);
                });
                
                tooltip.appendChild(historyList);
                
            } catch (error) {
                console.error('Ошибка при загрузке истории ников:', error);
                console.error('Player ID:', playerId);
                
                // Удаляем индикатор загрузки
                loadingDiv.remove();
                
                // Показываем сообщение об ошибке
                const errorMessage = document.createElement('div');
                errorMessage.textContent = error.message || 'Не удалось загрузить историю ников';
                errorMessage.style.cssText = 'text-align: center; padding: 40px; color: #e74c3c;';
                tooltip.appendChild(errorMessage);
            }
            
            // Закрытие тултипа при клике вне его
            const closeTooltipHandler = function(e) {
                if (!tooltip.contains(e.target) && e.target !== buttonElement && !buttonElement.contains(e.target)) {
                    tooltip.remove();
                    document.removeEventListener('click', closeTooltipHandler);
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            
            // Закрытие при нажатии Escape
            const escapeHandler = function(e) {
                if (e.key === 'Escape') {
                    tooltip.remove();
                    document.removeEventListener('keydown', escapeHandler);
                    document.removeEventListener('click', closeTooltipHandler);
                }
            };
            
            // Добавляем обработчики с небольшой задержкой, чтобы не закрыть сразу после открытия
            setTimeout(() => {
                document.addEventListener('click', closeTooltipHandler);
                document.addEventListener('keydown', escapeHandler);
            }, 100);
        }

        // Функция для загрузки списка друзей без статусов (быстрая загрузка)
async function loadFriendsBasicInfo(username) {
    try {
        const response = await fetch(`https://api.vimeworld.com/user/name/${username}/friends`);
        
        if (!response.ok) {
            throw new Error('Не удалось загрузить список друзей');
        }
        
        const data = await response.json();
        
        // Проверяем, есть ли массив друзей в ответе
        if (!data.friends || !Array.isArray(data.friends)) {
            console.error('Неверный формат данных:', data);
            return;
        }
        
        // Сохраняем список друзей в глобальную переменную
        window.friendsData = data.friends.map(friend => ({
            ...friend,
            online: false,
            friendStatus: null
        }));
        
        // Обновляем счетчик друзей на странице
        const friendsCount = data.friends.length;
        document.getElementById('player-friends').textContent = friendsCount;
        
        return data.friends;
    } catch (error) {
        console.error('Ошибка при загрузке списка друзей:', error);
        return [];
    }
}

// Функция для полной загрузки друзей со статусами (вызывается при открытии вкладки)
async function loadFriendsList(username) {
    const friendsLoading = document.getElementById('friends-loading');
    const friendsError = document.getElementById('friends-error');
    const friendsList = document.getElementById('friends-list');
    const friendsSortContainer = document.getElementById('friends-sort-container');
    
    // Показываем загрузку, скрываем ошибку и список
    friendsLoading.style.display = 'block';
    friendsError.style.display = 'none';
    friendsList.style.display = 'none';
    friendsSortContainer.style.display = 'none';
    
    // Устанавливаем стиль сетки для списка друзей заранее
    friendsList.style.gridTemplateColumns = 'repeat(3, 1fr)';
    friendsList.style.gap = '20px';
    
    try {
        let friends = window.friendsData;
        
        // Если данные ещё не загружены, загружаем их
        if (!friends || !friends.length) {
            const response = await fetch(`https://api.vimeworld.com/user/name/${username}/friends`);
            
            if (!response.ok) {
                throw new Error('Не удалось загрузить список друзей');
            }
            
            const data = await response.json();
            
            // Проверяем, есть ли массив друзей в ответе
            if (!data.friends || !Array.isArray(data.friends)) {
                console.error('Неверный формат данных:', data);
                throw new Error('Неверный формат данных от API');
            }
            
            friends = data.friends;
            
            // Сохраняем список друзей без статусов
            window.friendsData = friends.map(friend => ({
                ...friend,
                online: false,
                friendStatus: null
            }));
        }
        
        // Обновляем счетчик друзей на странице
        const friendsCount = friends.length;
        document.getElementById('player-friends').textContent = friendsCount;
        
        // Проверяем, есть ли друзья
        if (friends.length === 0) {
            friendsList.innerHTML = '<div class="text-center w-100 py-5">У игрока нет друзей</div>';
            friendsLoading.style.display = 'none';
            friendsSortContainer.style.display = 'none';
            friendsList.style.display = 'flex'; // Используем flex для центрирования сообщения
            friendsList.style.justifyContent = 'center';
            friendsList.style.alignItems = 'center';
            return;
        }
        
        // Загружаем статусы и отображаем список
        await loadFriendsStatuses(friends);
        
    } catch (error) {
        console.error('Ошибка при загрузке списка друзей:', error);
        
        // Показываем ошибку, скрываем загрузку и список
        friendsLoading.style.display = 'none';
        friendsError.style.display = 'block';
        friendsSortContainer.style.display = 'none';
        friendsList.style.display = 'none';
    }
}

// Функция для загрузки статусов друзей
async function loadFriendsStatuses(friends) {
    const friendsLoading = document.getElementById('friends-loading');
    const friendsList = document.getElementById('friends-list');
    
    try {
        // Подготавливаем массив никнеймов для получения онлайн-статусов
        const friendUsernames = friends.map(friend => friend.username);
        
        // Получаем онлайн-статусы для всех друзей
        const onlineStatuses = {};
        
        // Для каждого друга создаем отдельный запрос в цикле
        const statusPromises = friendUsernames.map(async (username) => {
            try {
                // Индивидуальный запрос для каждого друга
                const response = await fetch(`https://api.vimeworld.com/user/name/${username}/session`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${username}`);
                }
                
                const sessionData = await response.json();
                
                // Сохраняем данные о статусе в общий объект
                onlineStatuses[username.toLowerCase()] = sessionData.online;
            } catch (error) {
                console.error(`Ошибка при получении статуса для ${username}:`, error);
                // При ошибке для этого друга статус останется undefined
            }
        });
        
        // Ждем завершения всех запросов
        await Promise.all(statusPromises);
        
        // Обновляем friendsData с полученными статусами
        window.friendsData = friends.map(friend => {
            const friendStatus = onlineStatuses[friend.username.toLowerCase()];
            const isOnline = friendStatus && friendStatus.value;
            return {
                ...friend,
                online: isOnline,
                friendStatus: friendStatus
            };
        });
        
        // Добавляем обработчик изменения сортировки
        const sortSelect = document.getElementById('friends-sort');
        sortSelect.addEventListener('change', function() {
            renderFriendsList(window.friendsData, onlineStatuses, this.value);
        });
        
        // Отрисовываем список с сортировкой по умолчанию
        renderFriendsList(window.friendsData, onlineStatuses, sortSelect.value);
        
        // Показываем список, контейнер сортировки и скрываем индикатор загрузки
        friendsLoading.style.display = 'none';
        friendsList.style.display = 'grid';
        document.getElementById('friends-sort-container').style.display = 'block';
    } catch (error) {
        console.error('Ошибка при загрузке статусов друзей:', error);
        friendsLoading.style.display = 'none';
    }
}



// Функция для отрисовки списка друзей с указанной сортировкой
function renderFriendsList(friends, onlineStatuses, sortType = 'online') {
    const friendsList = document.getElementById('friends-list');
    friendsList.innerHTML = '';
    
    // Копируем массив друзей для сортировки
    const sortedFriends = [...friends];
    
    // Сортируем друзей в зависимости от выбранного типа сортировки
    switch (sortType) {
        case 'online':
            // Сначала онлайн, потом по времени последнего входа
            sortedFriends.sort((a, b) => {
                if (a.online && !b.online) return -1;
                if (!a.online && b.online) return 1;
                return b.lastSeen - a.lastSeen; // По убыванию времени последнего входа
            });
            break;
        case 'last_seen':
            // По времени последнего входа
            sortedFriends.sort((a, b) => b.lastSeen - a.lastSeen);
            break;
        case 'rank':
            // По значимости ранга
            const rankOrder = {
                "ADMIN": 1, "CHIEF": 2, "WARDEN": 3, "MODER": 4, "HELPER": 5, "ORGANIZER": 6, 
                "DEV": 7, "YOUTUBE": 8, "MAPLEAD": 9, "SRBUILDER": 10, "BUILDER": 11, "JRBUILDER": 12, 
                "VIME": 13, "ULTIMATE": 14, "IMPERIUM": 15, "IMPERIAL": 15, "ABSOLUTE": 16, "CELESTIAL": 17, 
                "ETERNAL": 18, "ELITE": 19, "THANE": 20, "DIVINE": 21, "IMMORTAL": 22, 
                "HOLY": 23, "PREMIUM": 24, "VIP": 25, "PLAYER": 26
            };
            
            sortedFriends.sort((a, b) => {
                const rankA = a.rank || "PLAYER";
                const rankB = b.rank || "PLAYER";
                return (rankOrder[rankA] || 999) - (rankOrder[rankB] || 999);
            });
            break;
        case 'name':
            // По имени в алфавитном порядке
            sortedFriends.sort((a, b) => a.username.localeCompare(b.username));
            break;
    }
    
    // Отрисовываем отсортированный список
    sortedFriends.forEach(friend => {
        const friendElement = createFriendElement(friend, onlineStatuses);
        friendsList.appendChild(friendElement);
    });
    
    // Устанавливаем стиль сетки для списка друзей
    friendsList.style.display = 'grid';
    friendsList.style.gridTemplateColumns = 'repeat(3, 1fr)';
    friendsList.style.gap = '20px';
}

// Функция для создания элемента друга
function createFriendElement(friend, onlineStatuses) {
    // Создаем элемент для друга
    const friendElement = document.createElement('div');
    friendElement.className = 'friend-card';
    
    // Формируем уровень с процентами
    const levelProgress = friend.levelPercentage * 100;
    
    // Определяем цвет ранга (первый ранг из списка рангов)
    let rankColor = '#7f8c8d'; // Цвет по умолчанию
    let rankName = 'Игрок';
    
    const friendRank = friend.rank || "PLAYER";
    if (ranksData[friendRank]) {
        rankName = ranksData[friendRank].name;
        
        // Берем первый цвет из массива цветов ранга
        if (ranksData[friendRank].colors && ranksData[friendRank].colors.length > 0) {
            rankColor = `#${ranksData[friendRank].colors[0]}`;
        }
    }
    
    // Проверяем онлайн-статус из полученных данных
    const friendStatus = onlineStatuses[friend.username.toLowerCase()];
    // Если статус не определен (undefined) из-за ошибки, это будет обработано ниже
    const isOnline = friendStatus && friendStatus.value;
    
    // Создаем контейнер для головы 3D
    const avatarContainer = document.createElement('div');
    avatarContainer.className = 'friend-avatar';
    avatarContainer.style.background = 'transparent';
    avatarContainer.style.width = '64px';
    avatarContainer.style.height = '64px';
    avatarContainer.style.display = 'flex';
    avatarContainer.style.justifyContent = 'center';
    avatarContainer.style.alignItems = 'center';
    
    // Добавляем 3D голову
    const headImg = document.createElement('img');
    headImg.src = `https://skin.vimeworld.com/helm/3d/${friend.username}.png`;
    headImg.alt = `${friend.username}`;
    headImg.className = 'friend-avatar-img';
    headImg.style.fontFamily = 'VimeArtBold, sans-serif';
    headImg.style.background = 'transparent';
    headImg.style.imageRendering = 'pixelated';
    headImg.style.width = '64px';
    headImg.style.height = '64px';
    avatarContainer.appendChild(headImg);
    
    // Формируем HTML-содержимое для карточки друга
    const friendContent = document.createElement('div');
    friendContent.className = 'friend-card-content';
    
    // Добавляем аватар
    friendContent.appendChild(avatarContainer);
    
    // Создаем блок с информацией
    const infoDiv = document.createElement('div');
    infoDiv.className = 'friend-info';
    
    // 1. Создаем элемент с именем и рангом
    const nameDiv = document.createElement('div');
    nameDiv.className = 'friend-name';
    nameDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    
    // Создаем ранг только если это не PLAYER (не обычный игрок)
    let rankSpan;
    const rankInfo = ranksData[friendRank] || ranksData["PLAYER"];
    
    if (friendRank !== "PLAYER") {
        rankSpan = document.createElement('span');
        rankSpan.className = 'friend-rank';
        rankSpan.textContent = rankName;
        rankSpan.style.marginLeft = '3px';
        rankSpan.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Применяем градиент для рангов с несколькими цветами
        if (rankInfo.colors && rankInfo.colors.length > 0) {
            if (rankInfo.colors.length === 1) {
                // Один цвет
                rankSpan.style.background = `#${rankInfo.colors[0]}`;
                rankSpan.style.color = '#fff'; // Белый текст на цветном фоне
            } else {
                // Градиент для нескольких цветов
                const gradient = `linear-gradient(to right, ${rankInfo.colors.map(color => `#${color}`).join(', ')})`;
                rankSpan.style.background = gradient;
                rankSpan.style.color = '#fff'; // Белый текст на градиентном фоне
            }
        }
    }
    
    // Создаем ссылку для имени
    const nameLink = document.createElement('a');
    nameLink.href = `player.html?username=${friend.username}`;
    nameLink.textContent = friend.username;
    nameLink.style.textDecoration = 'none';
    nameLink.style.cursor = 'pointer';
    
    // Применяем custom colors к имени игрока, если они есть
    if (friend.customColors && friend.customColors.length > 0) {
        if (friend.customColors.length === 1) {
            nameLink.style.color = `#${friend.customColors[0]}`;
        } else {
            const gradient = `linear-gradient(to right, ${friend.customColors.map(color => `#${color}`).join(', ')})`;
            nameLink.style.background = gradient;
            nameLink.style.webkitBackgroundClip = 'text';
            nameLink.style.webkitTextFillColor = 'transparent';
        }
    } else {
        nameLink.style.color = 'inherit';
    }
    
    nameDiv.appendChild(nameLink);
    
    // Добавляем Prime иконку, если есть
    if (friend.prime && friend.primeIcon) {
        const primeIconSpan = document.createElement('span');
        primeIconSpan.style.marginLeft = '3px';
        primeIconSpan.style.fontSize = '0.75rem';
        
        // Преобразуем Minecraft-формат (&c\u273e) в HTML
        let primeIcon = friend.primeIcon;
        
        // Заменяем &c, &4, &f и т.д. на соответствующие цвета
        const colorMap = {
            '&0': '#000000', // Черный
            '&1': '#0000AA', // Темно-синий
            '&2': '#00AA00', // Темно-зеленый
            '&3': '#00AAAA', // Темно-бирюзовый
            '&4': '#AA0000', // Темно-красный
            '&5': '#AA00AA', // Темно-пурпурный
            '&6': '#FFAA00', // Золотой
            '&7': '#AAAAAA', // Серый
            '&8': '#555555', // Темно-серый
            '&9': '#5555FF', // Синий
            '&a': '#55FF55', // Зеленый
            '&b': '#55FFFF', // Бирюзовый
            '&c': '#FF5555', // Красный
            '&d': '#FF55FF', // Пурпурный
            '&e': '#FFFF55', // Желтый
            '&f': '#FFFFFF'  // Белый
        };
        
        // Извлекаем код форматирования и символ
        const formatMatch = primeIcon.match(/^&([0-9a-fklmnor])(.+)$/);
        if (formatMatch) {
            const formatCode = '&' + formatMatch[1];
            const symbol = formatMatch[2];
            
            // Проверяем, это цветовой код или форматирующий
            if (colorMap[formatCode]) {
                // Цветовой код
                const color = colorMap[formatCode];
                primeIconSpan.style.color = color;
                // Добавляем тень для белого цвета (&f)
                if (formatCode === '&f') {
                    primeIconSpan.style.textShadow = '0px 0px 2px rgba(0,0,0,0.3)';
                }
                primeIconSpan.textContent = symbol;
            } else {
                // Форматирующий код (&k, &l, &m, &n, &o, &r)
                primeIconSpan.textContent = symbol;
                
                // Применяем соответствующее форматирование
                switch (formatCode) {
                    case '&k': // Случайные символы (обфускация)
                        // Для &k просто отображаем символ как есть
                        // В браузере сложно реализовать анимацию случайных символов
                        break;
                    case '&l': // Жирный
                        primeIconSpan.style.fontWeight = 'bold';
                        break;
                    case '&m': // Зачеркнутый
                        primeIconSpan.style.textDecoration = 'line-through';
                        break;
                    case '&n': // Подчеркнутый
                        primeIconSpan.style.textDecoration = 'underline';
                        break;
                    case '&o': // Курсив
                        primeIconSpan.style.fontStyle = 'italic';
                        break;
                    case '&r': // Сброс форматирования
                        // Просто отображаем символ без дополнительного форматирования
                        break;
                }
            }
        } else {
            // Если формат не соответствует ожидаемому
            primeIconSpan.textContent = 'Prime';
            primeIconSpan.className = 'friend-prime';
        }
        
        nameDiv.appendChild(primeIconSpan);
    }
    
    // Добавляем ранг после прайм-иконки (только если не PLAYER)
    if (friendRank !== "PLAYER" && rankSpan) {
        nameDiv.appendChild(rankSpan);
    }
    
    infoDiv.appendChild(nameDiv);
    
    // 2. Добавляем гильдию, если есть
    if (friend.guild) {
        const guildDiv = document.createElement('div');
        guildDiv.className = 'friend-guild';
        guildDiv.style.marginTop = '2px';
        guildDiv.style.marginBottom = '2px';
        guildDiv.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Добавляем тег гильдии только если он есть
        if (friend.guild.tag && friend.guild.tag.trim() !== '') {
            // Создаем контейнер для тега гильдии
            const guildTagContainer = document.createElement('span');
            guildTagContainer.style.fontFamily = 'VimeArtBold, sans-serif';
            
            // Добавляем открывающую скобку серого цвета (&7)
            const openBracket = document.createElement('span');
            openBracket.style.color = '#AAAAAA'; // Цвет &7
            openBracket.textContent = '<';
            guildTagContainer.appendChild(openBracket);
            
            // Сам тег гильдии с цветом из API
            const guildTagSpan = document.createElement('span');
            guildTagSpan.className = 'friend-guild-tag';
            // Преобразуем код цвета Minecraft в CSS
            let tagColor = '#7f8c8d'; // Цвет по умолчанию
            if (friend.guild.color && friend.guild.color.startsWith('&')) {
                const colorCode = friend.guild.color;
                const colorMap = {
                    '&0': '#000000', // Черный
                    '&1': '#0000AA', // Темно-синий
                    '&2': '#00AA00', // Темно-зеленый
                    '&3': '#00AAAA', // Темно-бирюзовый
                    '&4': '#AA0000', // Темно-красный
                    '&5': '#AA00AA', // Темно-пурпурный
                    '&6': '#FFAA00', // Золотой
                    '&7': '#AAAAAA', // Серый
                    '&8': '#555555', // Темно-серый
                    '&9': '#5555FF', // Синий
                    '&a': '#55FF55', // Зеленый
                    '&b': '#55FFFF', // Бирюзовый
                    '&c': '#FF5555', // Красный
                    '&d': '#FF55FF', // Пурпурный
                    '&e': '#FFFF55', // Желтый
                    '&f': '#FFFFFF'  // Белый
                };
                if (colorMap[colorCode]) {
                    tagColor = colorMap[colorCode];
                    // Добавляем тень для белого цвета (&f)
                    if (colorCode === '&f') {
                        guildTagSpan.style.textShadow = '0px 0px 2px rgba(0,0,0,0.3)';
                    }
                }
            }
            guildTagSpan.style.color = tagColor;
            guildTagSpan.style.fontFamily = 'VimeArtBold, sans-serif';
            guildTagSpan.textContent = friend.guild.tag;
            guildTagContainer.appendChild(guildTagSpan);
            
            // Добавляем закрывающую скобку серого цвета (&7)
            const closeBracket = document.createElement('span');
            closeBracket.style.color = '#AAAAAA'; // Цвет &7
            closeBracket.textContent = '>';
            guildTagContainer.appendChild(closeBracket);
            guildDiv.appendChild(guildTagContainer);
        }
        
        // Обрабатываем название гильдии с учетом форматирования Minecraft
        const guildNameSpan = document.createElement('span');
        guildNameSpan.style.marginLeft = '4px';
        guildNameSpan.style.fontFamily = 'VimeArtBold, sans-serif';
        
        // Преобразуем Minecraft форматирование в HTML
        let guildName = friend.guild.name;
        let formattedName = '';
        let currentColor = '';
        let isBold = false;
        let isItalic = false;
        
        const colorMap = {
            '&0': '#000000', // Черный
            '&1': '#0000AA', // Темно-синий
            '&2': '#00AA00', // Темно-зеленый
            '&3': '#00AAAA', // Темно-бирюзовый
            '&4': '#AA0000', // Темно-красный
            '&5': '#AA00AA', // Темно-пурпурный
            '&6': '#FFAA00', // Золотой
            '&7': '#AAAAAA', // Серый
            '&8': '#555555', // Темно-серый
            '&9': '#5555FF', // Синий
            '&a': '#55FF55', // Зеленый
            '&b': '#55FFFF', // Бирюзовый
            '&c': '#FF5555', // Красный
            '&d': '#FF55FF', // Пурпурный
            '&e': '#FFFF55', // Желтый
            '&f': '#FFFFFF'  // Белый
        };
        
        if (guildName.includes('&')) {
            for (let i = 0; i < guildName.length; i++) {
                if (guildName[i] === '&' && i + 1 < guildName.length) {
                    const code = guildName[i] + guildName[i + 1];
                    
                    if (code === '&l') {
                        isBold = true;
                        i++;
                    } else if (code === '&o') {
                        isItalic = true;
                        i++;
                    } else if (code === '&r') {
                        currentColor = '';
                        isBold = false;
                        isItalic = false;
                        i++;
                    } else if (colorMap[code]) {
                        currentColor = colorMap[code];
                        // Добавляем стиль тени для белого цвета
                        if (code === '&f') {
                            formattedName += '<span style="text-shadow: 0px 0px 2px rgba(0,0,0,0.3);">';
                        }
                        i++;
                    } else {
                        formattedName += guildName[i];
                    }
                } else {
                    formattedName += guildName[i];
                }
            }
            
            guildNameSpan.innerHTML = formattedName;
            if (currentColor) {
                guildNameSpan.style.color = currentColor;
            }
            if (isBold) {
                guildNameSpan.style.fontWeight = 'bold';
            }
            if (isItalic) {
                guildNameSpan.style.fontStyle = 'italic';
            }
        } else {
            guildNameSpan.textContent = guildName;
        }
        
        guildDiv.appendChild(guildNameSpan);
        
        infoDiv.appendChild(guildDiv);
    }
    
    // 3. Создаем элемент с последним входом
    const lastSeenDiv = document.createElement('div');
    lastSeenDiv.className = 'friend-last-seen';
    lastSeenDiv.style.fontSize = '0.7rem';
    lastSeenDiv.style.color = '#7f8c8d';
    lastSeenDiv.style.marginBottom = '2px';
    lastSeenDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    
    const lastSeen = new Date(friend.lastSeen * 1000);
    const now = new Date();
    
    // Вычисляем разницу времени в миллисекундах
    const diffMs = now - lastSeen;
    
    // Переводим в минуты, часы, дни
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    let lastSeenText;
    if (diffMinutes < 60) {
        lastSeenText = `Вход: ${diffMinutes} мин. назад`;
    } else if (diffHours < 24) {
        const remainMinutes = diffMinutes % 60;
        lastSeenText = `Вход: ${diffHours} ч. ${remainMinutes} мин. назад`;
    } else {
        lastSeenText = `Вход: ${diffDays} д. назад`;
    }
    
    lastSeenDiv.textContent = lastSeenText;
    infoDiv.appendChild(lastSeenDiv);
    
    // 4. Создаем элемент со статусом
    const statusDiv = document.createElement('div');
    statusDiv.style.fontSize = '0.7rem';
    statusDiv.style.color = '#7f8c8d'; 
    statusDiv.style.fontFamily = 'VimeArtBold, sans-serif';
    statusDiv.style.display = 'flex';
    statusDiv.style.alignItems = 'center';
    statusDiv.style.gap = '4px';
    
    // Добавляем индикатор статуса (аналогично профилю)
    const statusIndicator = document.createElement('div');
    statusIndicator.className = 'status-icon-square';
    statusIndicator.style.width = '8px';
    statusIndicator.style.height = '8px';
    statusIndicator.style.minWidth = '8px';
    statusIndicator.style.position = 'relative';
    statusIndicator.style.top = '0px';
    
    const statusTextSpan = document.createElement('span');
    
    // Получаем статус непосредственно из объекта сессии
    if (friendStatus === undefined) {
        // Нет данных о статусе - ошибка запроса или сервера
        statusIndicator.style.backgroundColor = '#95a5a6'; // Серый для ошибки/неизвестно
        statusIndicator.style.boxShadow = 'none';
        
        statusTextSpan.textContent = 'Неизвестно';
        statusTextSpan.style.color = '#95a5a6'; // Серый цвет для неизвестного статуса
    } else if (isOnline) {
        // Онлайн статус - берем сообщение из сессии
        statusIndicator.style.backgroundColor = '#2ecc71'; // Зеленый для онлайн
        statusIndicator.style.boxShadow = '0 0 6px #2ecc71';
        statusIndicator.style.animation = 'blink 2s ease-in-out infinite';
        
        // Отображаем конкретный статус из объекта сессии
        const message = friendStatus.message || 'Онлайн';
        statusTextSpan.textContent = message.replace(/^(Играет|Находится) (в|на) /, '');
        statusTextSpan.style.color = '#2ecc71'; // Зеленый цвет для онлайн
    } else {
        // Оффлайн статус
        statusIndicator.style.backgroundColor = '#e74c3c'; // Красный для оффлайн
        statusIndicator.style.boxShadow = '0 0 3px #e74c3c';
        
        statusTextSpan.textContent = 'Оффлайн';
        statusTextSpan.style.color = '#e74c3c'; // Красный цвет для оффлайн
    }
    
    statusDiv.appendChild(statusTextSpan);
    statusDiv.appendChild(statusIndicator);
    
    infoDiv.appendChild(statusDiv);
    
    friendContent.appendChild(infoDiv);
    
    // Добавляем элемент в DOM
    friendElement.appendChild(friendContent);
    
    return friendElement;
}

        // Добавляем обработчик нажатия на вкладку друзей для загрузки данных

        // Добавляем обработчик нажатия на кнопку повтора загрузки
document.addEventListener('DOMContentLoaded', function() {
    const retryBtn = document.getElementById('retry-friends-btn');
    if (retryBtn) {
        retryBtn.addEventListener('click', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const username = urlParams.get('username');
            
            if (username) {
                loadFriendsList(username);
            }
        });
    }
    
    // Добавляем обработчик клика на счетчик друзей
    const friendsCountLink = document.getElementById('friends-count-link');
    if (friendsCountLink) {
        friendsCountLink.addEventListener('click', function() {
            // Активируем вкладку друзей
            const friendsTab = document.getElementById('friends-tab');
            if (friendsTab) {
                const tabInstance = new bootstrap.Tab(friendsTab);
                tabInstance.show();
            }
        });
    }
    
    // Добавляем обработчик переключения на вкладку друзей
    const friendsTab = document.getElementById('friends-tab');
    if (friendsTab) {
        // Флаг, который показывает, были ли загружены статусы друзей
        let friendsStatusesLoaded = false;
        
        friendsTab.addEventListener('shown.bs.tab', function() {
            // Загружаем статусы только при первом переключении на вкладку
            if (!friendsStatusesLoaded) {
                const urlParams = new URLSearchParams(window.location.search);
                const username = urlParams.get('username');
                if (username) {
                    loadFriendsList(username);
                    friendsStatusesLoaded = true;
                }
            }
        });
    }
});

// Функция для скачивания файла
function downloadFile(url, fileName) {
    fetch(url)
        .then(response => response.blob())
        .then(blob => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        })
        .catch(error => {
            console.error('Ошибка при скачивании файла:', error);
            alert('Не удалось скачать файл. Попробуйте позже.');
        });
}
    </script>
    <script src="auth.js"></script>
</body>
</html> 